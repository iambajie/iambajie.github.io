<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>八戒大强攻</title>
  
  <subtitle>好久没吃人肉了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiapf.com/"/>
  <updated>2020-03-06T08:21:59.688Z</updated>
  <id>https://www.xiapf.com/</id>
  
  <author>
    <name>Xiapf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>监督学习笔记（一）——支持向量机</title>
    <link href="https://www.xiapf.com/blogs/svm/"/>
    <id>https://www.xiapf.com/blogs/svm/</id>
    <published>2020-03-06T08:20:10.000Z</published>
    <updated>2020-03-06T08:21:59.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>（1）支持向量：支持向量机用于解决分类问题，当给出一组线性可分的数据时，此时可以得出一条直线将数据分隔开，要求这条直线即求出了分类的依据，当根据距离分隔线最近的点，取其距离的最大值就能得到最优分割的直线。其中距离分隔线最近的点称为支持向量。</p><p>（2）机：机是指该方法是一个分类器，会产生二值决策机。</p><p>（3）优点：支持向量机方法只使用支持向量，并没有用全部的数据点，所以内存方面优于knn。</p><a id="more"></a><p>（4）缺点：支持向量机一般用于线性可分的数据，当数据线性不可分时无法使用。对于复杂数据需要借助核函数，将复杂数据映射到高维空间进行处理</p><h2 id="求解的理论依据"><a href="#求解的理论依据" class="headerlink" title="求解的理论依据"></a>求解的理论依据</h2><p>（1）确定分隔平面和输出函数</p><p>分隔平面：wT*x+b，其中w和b描述了所给数据的分隔平面</p><p>因为是二值分类器，输出值是-1和+1，所以使用signmoid函数，当点到直线的距离f(wT*x+b)&gt;0时属于 +1类，反之属于-1类。</p><p>（2）求距离：</p><p>数据点到分隔平面的距离记为<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150346.png" alt="点到平面的几何距离">)，要求得最佳分隔平面就要找到距离平面最佳的点的距离将其最大化，则为最佳分类，所以即求<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150600.png" alt="求解目标">)，但是该目标函数求解困难，因此使用拉格朗日乘子法进行转换带约束调节的目标函数：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150813.png" alt="转换函数">)，其中约束条件为：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件">，因为实际数据不可能存在100%线性可分所以此时加上一个松弛变量，可以允许一些点在分隔平面的另一边，此时前一个约束条件变为0&lt;=alpha&lt;=C，这里的常数C确保点距离平面的最大间隔和所有数据点的函数间隔小于1.0（因为是支持向量）</p><p>（3）问题转换</p><p>根据（2）中转换后的目标函数和约束条件可以看出，SVM（支持向量机，以下均简称为SVM）的主要求解目标转换为求alpha的值，通过alpha可以表示分隔平面。</p><h2 id="使用的算法"><a href="#使用的算法" class="headerlink" title="使用的算法"></a>使用的算法</h2><p>由求解的理论依据中可知，SVM需要求解的目标为带有约束条件的函数，一般采用二次规划求解方法，但是计算复杂，这里使用platt SMO算法求解。</p><p>（1）算法思路：每次选择一对alpha进行优化，当找到合适的两个alpha后，需要增大一个减小另一个，因为需要满足约束条件：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件">，合适是指两个alpha值要在间隔边界之外，同时没有被区间化处理或者不在边界上</p><p>（2）基本算法流程：以简单smo算法为例</p><p>#0.初始化alpha向量为0</p><p>#1.当迭代次数小于最大迭代次数（外循环）<br>    #2.对数据集中每个向量（内循环）<br>        #3.如果该向量可以被优化<br>            #4.随机找另一个向量<br>            #5.优化这两个向量<br>            #6.如果这两个向量不能被优化，退出内循环</p><p>#7.如果所有向量都不能被优化，增加迭代次数，进行下一次的循环</p><p>（3）完整platt smo 算法</p><p>platt smo算法在简化smo算法基础上提升时间，对数据量大的数据集执行时间大大减少。</p><p>相比于传统的二次规划求解方法，每次选取两个alpha进行优化，时间效率大幅提高。</p><p>算法流程：</p><p>#外循环 使用两种方式交替得到第一个alpha的值</p><p>#1.0 对所有数据点进行遍历扫描</p><p>#2.0 对非边界值即0&lt;alpha并且alpha&gt;c的alpha进行扫描</p><p>#内循环 采用最大化步长的方式得到第二个alpha的值</p><h2 id="核函数的引入"><a href="#核函数的引入" class="headerlink" title="核函数的引入"></a>核函数的引入</h2><p>当面对非线性数据的时候，需要使用核函数，将复杂数据映射到高维空间，此时分类器易于理解，即可使用SVM方法。</p><p>主要使用径向基函数的高斯版本：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306155004.png" alt="径向基函数"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X,A,kTup=<span class="params">()</span>)</span>:</span></span><br><span class="line">  m=shape(X)[<span class="number">0</span>]</span><br><span class="line">  K=zeros((m,<span class="number">1</span>))</span><br><span class="line">  <span class="comment">#对核函数的第一个参数进行不同情况的讨论</span></span><br><span class="line">  <span class="comment">#1.线性核</span></span><br><span class="line">  <span class="keyword">if</span>(kTup[<span class="number">0</span>]=<span class="string">"lin"</span>):</span><br><span class="line">    K=X*A.T</span><br><span class="line">  <span class="comment">#2.径向基核</span></span><br><span class="line">  <span class="keyword">elif</span>(kTup[<span class="number">0</span>]=<span class="string">"rbf"</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">      delta=X[i,:]-A</span><br><span class="line">      K[i]=delta*delta.T</span><br><span class="line">     K=exp(K/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))      </span><br><span class="line">  <span class="comment">#3.抛出异常</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError()</span><br><span class="line">  <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="应用实例——手写数字识别"><a href="#应用实例——手写数字识别" class="headerlink" title="应用实例——手写数字识别"></a>应用实例——手写数字识别</h2><p>识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</p><p>将图像转换为向量</p><p>（2）读取文件夹列表中各个图像文件</p><p>（3）处理分类问题</p><p>为方便处理，只保留了1和9两个数字，当是数字1时，分类为+1，当是数字9时分类为-1</p><p>#1.读入图像转换后的数据向量和标签属性</p><p>#2.调用platt smo算法得出alpha和b的值</p><p>#3.根据支持向量大于0的特性得出其中alpha&gt;0的支持向量，并得出支持向量的数据点和标签数据</p><p>#4.在训练集上得出分类结果</p><p>#5.将分类的结果应用于测试集</p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#plat smo可以处理数据量大的，上面simplesmo只能处理数据量较小的数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#platsmo的支持函数</span></span><br><span class="line"><span class="comment">#建立一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line"><span class="comment">#各种变量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMat,lableMat,C,toler,kTup)</span>:</span><span class="comment">#增加核函数初始化参数</span></span><br><span class="line">self.dataMat=dataMat</span><br><span class="line">self.lableMat=lableMat</span><br><span class="line">self.C=C</span><br><span class="line">self.toler=toler</span><br><span class="line">self.m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">self.alpha=mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">self.b=<span class="number">0</span></span><br><span class="line">self.echache=mat(zeros((self.m,<span class="number">2</span>)))<span class="comment">#第一列表示cache是否有效，第二列是实际的E（误差）值</span></span><br><span class="line"><span class="comment">#构建k</span></span><br><span class="line">self.k=mat(zeros((self.m,self.m)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line"><span class="comment">#调用函数，填充k</span></span><br><span class="line">self.k[:,i]=kernelTras(self.dataMat,self.dataMat[i,:],kTup)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存误差缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEK</span><span class="params">(oS,ke)</span>:</span></span><br><span class="line">fk=float(multiply(oS.alpha,oS.lableMat).T*oS.k[:,ke]+oS.b)</span><br><span class="line">EK=fk-float(oS.lableMat[ke])</span><br><span class="line"><span class="keyword">return</span> EK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算误差，并且存入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEK</span><span class="params">(oS,k)</span>:</span></span><br><span class="line">EK=calcEK(oS,k)</span><br><span class="line">oS.echache[k]=[<span class="number">1</span>,EK]</span><br><span class="line"></span><br><span class="line"><span class="comment">#内循环中的启发方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择第二个alpha值，保证每次优化都是最大的步长，如果是第一次进入循环就先随机选择一个alpha[j],反之进入循环，根据最大步长选择alpha[j]的值</span></span><br><span class="line"><span class="comment">#alphaj的值和前一个alphai的下标和误差Ei有关</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i,oS,Ei)</span>:</span></span><br><span class="line">maxk=<span class="number">-1</span></span><br><span class="line">maxDeltaE=<span class="number">0</span></span><br><span class="line">Ej=<span class="number">0</span></span><br><span class="line">oS.echache[i]=[<span class="number">1</span>,Ei]</span><br><span class="line"><span class="comment">#输入列表为目标的列表值，nozero返回不为空的值即非零alpha值</span></span><br><span class="line">validDeltaList=nonzero(oS.echache[:,<span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> (len(validDeltaList))&gt;<span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> validDeltaList:</span><br><span class="line"><span class="keyword">if</span>(k==i):</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">Ek=calcEK(oS,k)</span><br><span class="line">delta=abs(Ek-Ei)</span><br><span class="line"><span class="keyword">if</span>(delta&gt;maxDeltaE):</span><br><span class="line">maxk=k</span><br><span class="line">maxDeltaE=delta</span><br><span class="line">Ej=Ek</span><br><span class="line"><span class="keyword">return</span> maxk,Ej</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">j=selectRandom(i,oS.m)</span><br><span class="line">Ej=calcEK(oS,j)</span><br><span class="line"><span class="keyword">return</span> j,Ej</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerI</span><span class="params">(oS,i)</span>:</span></span><br><span class="line">exi=calcEK(oS,i)</span><br><span class="line"><span class="keyword">if</span> ((oS.lableMat[i]*exi&lt;-oS.toler) <span class="keyword">and</span> (oS.alpha[i]&lt;oS.C)) <span class="keyword">or</span> ((oS.lableMat[i]*exi&gt;oS.toler) <span class="keyword">and</span> (oS.alpha[i]&gt;<span class="number">0</span>)):</span><br><span class="line"><span class="comment">#1.3启发式找另一个向量</span></span><br><span class="line">j,exj=selectJ(i,oS,exi)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.4优化这两个向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#记录旧的，看优化之后有无变换</span></span><br><span class="line">alphaJold=oS.alpha[j].copy()</span><br><span class="line">alphaIold=oS.alpha[i].copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(oS.lableMat[i]!=oS.lableMat[j]):</span><br><span class="line">L=max(<span class="number">0</span>,oS.alpha[j]-oS.alpha[i])</span><br><span class="line">H=min(oS.C,oS.C+oS.alpha[j]-oS.alpha[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">L=max(<span class="number">0</span>,oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line">H=min(oS.C,oS.C+oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L==H):</span><br><span class="line">print(<span class="string">"L==H"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最优修改量</span></span><br><span class="line"><span class="comment">#eta=2.0*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#使用核函数之后，修正eta的值</span></span><br><span class="line">eta=<span class="number">2.0</span>*oS.k[i,j]-oS.k[i,i]-oS.k[j,j]</span><br><span class="line"><span class="keyword">if</span>(eta&gt;=<span class="number">0</span>):</span><br><span class="line">print(<span class="string">"eta&gt;=0"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">oS.alpha[j]-=oS.lableMat[j]*(exi-exj)/eta</span><br><span class="line">oS.alpha[j]=adjustBig(oS.alpha[j],H,L)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将j的更新存到缓存</span></span><br><span class="line">updateEK(oS,j)</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化j之后无变换</span></span><br><span class="line"><span class="keyword">if</span> abs(alphaJold-oS.alpha[j])&lt;<span class="number">0.00001</span>:</span><br><span class="line">print(<span class="string">"alphaJold-alpha[j])&lt;0.00001"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#优化j有变化，接着优化i</span></span><br><span class="line">oS.alpha[i]+=oS.lableMat[j]*oS.lableMat[i]*(alphaJold-oS.alpha[j])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将i的更新存到缓存</span></span><br><span class="line">updateEK(oS,i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置偏置量</span></span><br><span class="line"><span class="comment">#b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[i,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#使用核函数之后，修正b1,b2的值</span></span><br><span class="line">b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,i]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[i,j]</span><br><span class="line">b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,j]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[j,j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> oS.alpha[i]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[i]&lt;oS.C:</span><br><span class="line">oS.b=b1</span><br><span class="line"><span class="keyword">elif</span> oS.alpha[j]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[j]&lt;oS.C:</span><br><span class="line">oS.b=b2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">oS.b=(b1+b2)/<span class="number">2.0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#完整的platt smo 外循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn,labelArr,C,toler,maxIter,kTup=<span class="params">(<span class="string">"lin"</span>,<span class="number">0</span>)</span>)</span>:</span></span><br><span class="line"><span class="comment">#0.相关变量初始化</span></span><br><span class="line">oS=optStruct(mat(dataMatIn),mat(labelArr).transpose(),C,toler,kTup)</span><br><span class="line"></span><br><span class="line">entireSet=<span class="literal">True</span></span><br><span class="line">alphaChange=<span class="number">0</span></span><br><span class="line">iter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.主循环</span></span><br><span class="line"><span class="keyword">while</span> (iter&lt;maxIter) <span class="keyword">and</span> ((alphaChange&gt;<span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">alphaChange=<span class="number">0</span></span><br><span class="line"><span class="comment">#1.选择第一个alpha的两种循环</span></span><br><span class="line"><span class="comment">#1.0对所有数据集进行遍历</span></span><br><span class="line"><span class="keyword">if</span>(entireSet):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):</span><br><span class="line">alphaChange+=innerI(oS,i)</span><br><span class="line">print(<span class="string">"fullset: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line">iter+=<span class="number">1</span></span><br><span class="line"><span class="comment">#1.1对非边界值进行遍历</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nonBoundIs=nonzero((oS.alpha.A&gt;<span class="number">0</span>)*(oS.alpha.A&lt;C))[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">alphaChange+=innerI(oS,i)</span><br><span class="line">print(<span class="string">"nonbound: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line"></span><br><span class="line">iter+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(entireSet):</span><br><span class="line">entireSet=<span class="literal">False</span></span><br><span class="line"><span class="keyword">elif</span>(alphaChange==<span class="number">0</span>):</span><br><span class="line">entireSet=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oS.alpha,oS.b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用求得的alpha值求得分类的超平面，其中可以求出w的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcW</span><span class="params">(alpha,dataMatIn,labelArr)</span>:</span></span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m,n=shape(dataMat)</span><br><span class="line">w=zeros((n,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"><span class="comment">#其中起作用的只有支持向量，即不为0的alpha</span></span><br><span class="line">w+=multiply((alpha[i]*lableMat[i]),dataMat[i,:].T)</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在复杂数据上使用核函数</span></span><br><span class="line"><span class="comment">#将数据从一个特征空间映射到另一个空间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTras</span><span class="params">(X,A,kTup)</span>:</span></span><br><span class="line">m,n=shape(X)</span><br><span class="line">k=zeros((m,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#根据ktup的第一个参数来求核函数的值</span></span><br><span class="line"><span class="keyword">if</span>(kTup[<span class="number">0</span>]==<span class="string">"lin"</span>):</span><br><span class="line">k=X*A.T</span><br><span class="line"><span class="keyword">elif</span>(kTup[<span class="number">0</span>]==<span class="string">"rbf"</span>):</span><br><span class="line"><span class="comment">#对每个元素计算高斯值</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">deltaRow=X[j,:]-A</span><br><span class="line">k[j]=deltaRow*deltaRow.T</span><br><span class="line">k=exp(k/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))</span><br><span class="line"><span class="comment">#若元祖无法识别，则抛出异常</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">raise</span> NameError(<span class="string">"the keneral name wrong"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="comment">#识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.将图像转换为向量——将32*32的图像转换为1*1024的向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line"><span class="comment">#0.构造转换后返回的向量</span></span><br><span class="line">returnVect=zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line"><span class="comment">#1.处理图像</span></span><br><span class="line">fr=open(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32行的</span></span><br><span class="line">lineArr=fr.readline() <span class="comment">#每次读入一行</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32列的</span></span><br><span class="line">returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j]=int(lineArr[j])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.从文件夹中读入所有图片信息并存储为向量和标签——,为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImage</span><span class="params">(dirname)</span>:</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"><span class="comment">#0.用于存储标签</span></span><br><span class="line">hwLabels=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.用于存储数据向量</span></span><br><span class="line"><span class="comment">#得到文件夹下图像名称的列表 例：1_20.txt</span></span><br><span class="line">trainDirList=listdir(dirname)</span><br><span class="line">m=len(trainDirList)</span><br><span class="line"><span class="comment">#用于存储数据向量</span></span><br><span class="line">trainMat=zeros((m,<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.处理图像文件中的内容</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"><span class="comment">#图像文件完整名称</span></span><br><span class="line">fullName=trainDirList[i]</span><br><span class="line"><span class="comment">#图像文件去除后缀后的名称</span></span><br><span class="line">fileName=fullName.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#图像文件去除下划线后的名称</span></span><br><span class="line">className=int(fileName.split(<span class="string">"_"</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line"><span class="keyword">if</span>(className==<span class="number">1</span>):</span><br><span class="line">hwLabels.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">hwLabels.append(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#将图像文件中的内容转换为向量进行存储</span></span><br><span class="line">trainMat[i,:]=img2vector(<span class="string">"%s/%s"</span>%(dirname,fullName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> trainMat,hwLabels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.使用核函数进行分类测试的径向基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup=<span class="params">(<span class="string">"rbf"</span>,<span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">dataMatIn,labelArr=loadImage(<span class="string">"trainingDigits"</span>)</span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m,n=shape(dataMat)</span><br><span class="line"><span class="comment">#根据platt smo算法得到alpha,b的值</span></span><br><span class="line">alpha,b=smoP(dataMatIn,labelArr,<span class="number">200</span>,<span class="number">0.0001</span>,<span class="number">10000</span>,kTup)</span><br><span class="line">print(alpha[alpha&gt;<span class="number">0</span>])</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#得到支持向量</span></span><br><span class="line">sVInd=nonzero(alpha.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">sVs=dataMat[sVInd]</span><br><span class="line">sVlabel=lableMat[sVInd]</span><br><span class="line">print(<span class="string">"tere are "</span>+str(shape(sVs)[<span class="number">0</span>])+<span class="string">" support vectors"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在训练集上使用核函数</span></span><br><span class="line">error=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line"><span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"train error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">#在测试集上使用核函数</span></span><br><span class="line">dataMatIn,labelArr=loadImage(<span class="string">"testDigits"</span>)</span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">error=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line"><span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"test error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;p&gt;（1）支持向量：支持向量机用于解决分类问题，当给出一组线性可分的数据时，此时可以得出一条直线将数据分隔开，要求这条直线即求出了分类的依据，当根据距离分隔线最近的点，取其距离的最大值就能得到最优分割的直线。其中距离分隔线最近的点称为支持向量。&lt;/p&gt;&lt;p&gt;（2）机：机是指该方法是一个分类器，会产生二值决策机。&lt;/p&gt;&lt;p&gt;（3）优点：支持向量机方法只使用支持向量，并没有用全部的数据点，所以内存方面优于knn。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="支持向量机" scheme="https://www.xiapf.com/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（四）</title>
    <link href="https://www.xiapf.com/blogs/movStateNote/"/>
    <id>https://www.xiapf.com/blogs/movStateNote/</id>
    <published>2020-03-05T03:22:57.000Z</published>
    <updated>2020-03-05T03:27:13.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>（1）明确状态含义</p><p>首先要明确dp[i]的含义，例如在求分割回文字符串的次数中，dp[i]表示i个回文字符串的分割次数</p><p>（2）确定初始状态</p><p>可以考虑最多…的时候dp的状态</p><p>例如求分割回文字符串的次数，初始状态即为i个字符串最多分割i次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求分割回文字符串的次数</span></span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  dp[i]=i;</span><br><span class="line"><span class="comment">//i个字符串，最多分割i次</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>（3）确定状态转移方程</p><p>假设已知dp[i]的状态，列出dp[i+1]和dp[i]之间的关系式，即为状态转移方程</p><p>明确目标：要求dp{i]的值</p><p>例如求分割回文字符串的次数，其中状态转移方程如下：</p><p>当i从1变化到len之间，求dp[i]。当0~i本身是回文时，不需要分割，即dp[i]=0。该题dp[i+1]和dp[i]之间没有明确联系，可以从分割边界考虑。假设分割边界为j，已知dp[j]，求dp[i]，就需要分两种情况考虑</p><p>a）j+1~i之间是回文，那么dp[j]再分割一次就可以得到j之前的字符串和后面的回文，即dp[i]=dp[j]+1，但dp[i]有可能更小，所以dp[i]在dp[i]和dp[j]+1之间取小的</p><p>b）j+1~i之间不是回文，继续移动j，找到符合回文的子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>~i是回文)</span><br><span class="line">    dp[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>~i是回文)</span><br><span class="line">      dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）最终输出</p><p>一般输出为dp[len-1]，例如在求分割回文字符串的次数中，最终是求len个字符串的分割次数，即求dp[len-1]</p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p>（1）明确状态含义</p><p>股票有三种状态：买入，卖出，休息（不买入也不卖出）    最终状态为持有股票设置为0，不持有股票1</p><p>转换关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200304222109.png" alt="stock"></p><p>设置dp[i] [k] [s]表示第天股票的持有情况，k表示至今最多进行k笔交易，整个数组表示可以得到的最大利润</p><p>（2）确定状态转移方程</p><p>转换关系中就两种状态，因此分别考虑两种情况下的转移方程：</p><p>a）今天持有股票，即求dp[i] [k] [1]</p><p>持有股票有两种情况，一种是前一天本来就有股票，并且今天休息，即dp[i-1] [k] [1]；另一种是前一天没有股票，今天购入了，此时前一天进行了k-1笔交易，买入股票，说明利润减少，需要减掉买入的价格,即dp[i-1] [k-1] [0]-price[i]</p><p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i])</p><p>b）今天不持有股票，即求dp[i] [k] [0]</p><p>不持有股票也有两种情况，一种是前一天本来就没有股票，并且今天休息，即dp[i-1] [k] [0]；另一种是前一天有股票，今天卖出了，卖出股票，说明利润增加，需要加上卖出的价格,即dp[i-1] [k] [1]+price[i]</p><p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [0]=max(dp[i-1] [k] [0]]，dp[i-1] [k] [1]+price[i])</p><p>综合a和b，可以得出状态转移方程</p><p>（3）确定初始状态</p><p>因为状态转移方程中只有两个最终状态，所以对两个最终状态的初始情况进行讨论：</p><p>a）刚开始没有持有股票时，没有利润，即dp[0] [0]=0</p><p>b）刚开四持有股票，之前没有利润，亏损买入的价格，即dp[0] [1]=-price[0]</p><p>（4）最终输出</p><p>最后一天利润是最大的，此时不持有股票的利润肯定大于持有的，即dp[len-1] [k] [0]&gt;dp[len-1] [k] [1]，所以选择dp[len-1] [k] [1]</p><p>（5）实际应用</p><p>a）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p><p>此时k=1，代入方程得</p><p>dp[i] [1] [1]=max(dp[i-1] [1] [1]，dp[i-1] [0] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p><p>dp[i] [1] [0]=max(dp[i-1] [1] [0]，dp[i-1] [1] [1]+price[i])</p><p>可以看出，方程中k=1对转换无影响，所以省去k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此时k=无穷，那么k的值和k-1的值近似一样，因此k同样可以省略，此时的方程为</p><p>dp[i] [1]=max(dp[i-1] [1]，dp[i-1] [0]-price[i]) 其中dp[i-1] [0]不可以省略，因为其值已经不等于0</p><p>dp[i] [0]=max(dp[i-1] [0]，dp[i-1]  [1]+price[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，dp[i<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c）给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此时k从1变换到2，不为0是因为要有利润至少会有一笔交易，此时代码中将多一重循环</p><p>dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p><p>dp[i] [k] [0]=max(dp[i-1] [k] [0]，dp[i-1] [k] [1]+price[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//定义初始状态</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//刚开始时，不持有股票，利润为0</span></span><br><span class="line">      dp[i][k][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//刚开始时，持有股票，利润为亏损买入对应的股票</span></span><br><span class="line">      dp[i][k][<span class="number">1</span>]=-price[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][k][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">1</span>]，dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">    dp[i][k][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">0</span>]，dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+price[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;h3 id=&quot;一般思路&quot;&gt;&lt;a href=&quot;#一般思路&quot; class=&quot;headerlink&quot; title=&quot;一般思路&quot;&gt;&lt;/a&gt;一般思路&lt;/h3&gt;&lt;p&gt;（1）明确状态含义&lt;/p&gt;&lt;p&gt;首先要明确dp[i]的含义，例如在求分割回文字符串的次数中，dp[i]表示i个回文字符串的分割次数&lt;/p&gt;&lt;p&gt;（2）确定初始状态&lt;/p&gt;&lt;p&gt;可以考虑最多…的时候dp的状态&lt;/p&gt;&lt;p&gt;例如求分割回文字符串的次数，初始状态即为i个字符串最多分割i次&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//求分割回文字符串的次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;len;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dp[i]=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//i个字符串，最多分割i次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.xiapf.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>mac下搭建和使用mve</title>
    <link href="https://www.xiapf.com/blogs/useMVE/"/>
    <id>https://www.xiapf.com/blogs/useMVE/</id>
    <published>2020-03-04T03:47:55.000Z</published>
    <updated>2020-03-04T03:49:26.520Z</updated>
    
    <content type="html"><![CDATA[<p>mve可以将多角度的图片序列重构成三维点云</p><h2 id="一、搭建mve"><a href="#一、搭建mve" class="headerlink" title="一、搭建mve"></a>一、搭建mve</h2><p>搭建过程参照官方文档<a href="https://github.com/simonfuhrmann/mve" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/simonfuhrmann/mve</a></p><p>以下均在终端进行操作</p><p>1.从github上下载代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/simonfuhrmann/mve.git</span><br></pre></td></tr></table></figure><p>下载之后会在根目录建立mve文件夹</p><a id="more"></a><p>2.进入mve文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd mve</span><br></pre></td></tr></table></figure><p>进行编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>3.添加依赖库</p><p>编译过程中报错，是因为缺少依赖库，需要手动安装。主要是对图片处理的函数库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install libjpeg</span><br><span class="line">brew install libpng</span><br><span class="line">brew install libtiff</span><br></pre></td></tr></table></figure><p>此时就能成功编译，打开mve下的apps文件夹，当所有的文件夹下生成了”.o”后缀的文件，说明环境已经搭建好。</p><h2 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h2><p>1.在官网下载数据集</p><p><a href="http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/" target="_blank" rel="external nofollow noopener noreferrer">http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/</a></p><p>我选择的是der_hass-20140923数据集，里面包含雕像不同角度的79张图像，下载后进行解压</p><p>2.设置环境变量</p><p>生成点云过程中是使用apps下中的子文件夹实现，所以需要设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#进入根目录</span><br><span class="line">cd ~</span><br><span class="line">#给任意一个文件添加环境变量</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>输入vim命令后，进入输入环境变量页面，输入“O”，进入写模式，将apps下所有文件夹路径加入环境变量中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/Users/mve/apps/bundle2pset:$PATH</span><br><span class="line">#以下省略</span><br></pre></td></tr></table></figure><p>输入结束后，按esc，在文末输入”:wq”，退出并保存环境变量</p><p>生效环境变量，将环境变量应用到下载好的数据集下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 数据集路径名称</span><br></pre></td></tr></table></figure><p>查看环境变量是否生效，在数据集文件夹下打开终端，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>当环境变量中包含了apps下文件夹的路径，说明环境变量设置成功</p><p>3.重建三维生成点云</p><p>der_hass-20140923是下载的数据集，der_hass是生成数据所在的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makescene -i der_hass-20140923 der_hass</span><br></pre></td></tr></table></figure><p>按以下命令一个个运行，der_hass是生成的散文图所在的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sfmrecon der_hass</span><br><span class="line">dmrecon -s2 der_hass</span><br><span class="line">scene2pset -F2 der_hass der_hass/pset-L2.ply</span><br><span class="line">fssrecon der_hass/pset-L2.ply der_hass/surface-L2.ply</span><br><span class="line">meshclean -t10 der_hass/surface-L2.ply der_hass/surface-L2-clean.ply</span><br></pre></td></tr></table></figure><p>运行过程比较慢，需要耐心等待，大约需3小时左右，最终生成的点云文件为surface-L2-clean.ply</p><p>4.效果展示</p><p>使用meshlab打开点云文件，效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200120193729.png" alt="效果图"></p><p>可以看出生成的点云完整，不存在不连续的部分，实现了从图像-&gt;稀疏点云-&gt;稠密点云-&gt;点云表面重建的全过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mve可以将多角度的图片序列重构成三维点云&lt;/p&gt;&lt;h2 id=&quot;一、搭建mve&quot;&gt;&lt;a href=&quot;#一、搭建mve&quot; class=&quot;headerlink&quot; title=&quot;一、搭建mve&quot;&gt;&lt;/a&gt;一、搭建mve&lt;/h2&gt;&lt;p&gt;搭建过程参照官方文档&lt;a href=&quot;https://github.com/simonfuhrmann/mve&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://github.com/simonfuhrmann/mve&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以下均在终端进行操作&lt;/p&gt;&lt;p&gt;1.从github上下载代码&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/simonfuhrmann/mve.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;下载之后会在根目录建立mve文件夹&lt;/p&gt;
    
    </summary>
    
    
      <category term="点云" scheme="https://www.xiapf.com/categories/%E7%82%B9%E4%BA%91/"/>
    
    
      <category term="mve" scheme="https://www.xiapf.com/tags/mve/"/>
    
      <category term="点云" scheme="https://www.xiapf.com/tags/%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（三）</title>
    <link href="https://www.xiapf.com/blogs/listbNote/"/>
    <id>https://www.xiapf.com/blogs/listbNote/</id>
    <published>2020-03-03T07:18:41.000Z</published>
    <updated>2020-03-03T07:20:20.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于链表的算法"><a href="#关于链表的算法" class="headerlink" title="关于链表的算法"></a>关于链表的算法</h2><p>链表节点的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表常用算法思想包括：快慢指针（对空间复杂度有要求，可以考虑使用快慢指针）</p><a id="more"></a><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>新建两个指针，快指针走两步，慢指针走一步</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针法只使用两个指针，空间复杂度很小，只有O(1)</span></span><br><span class="line">ListNode* fast=head;<span class="comment">//快指针</span></span><br><span class="line">ListNode* slow=head;<span class="comment">//慢指针</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//慢指针走一步</span></span><br><span class="line">  slow=slow-&gt;next;</span><br><span class="line">  <span class="comment">//快指针走两步</span></span><br><span class="line">  fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>环形链表（判断链表中是否存在环）：</p><p>（1）判断有无环：可以利用快慢指针，如果存在环，那么在某一个链表节点快指针指向的节点就等于慢指针指向的节点（是节点整体相等，包括val和next，不能只用val判断），反之，则不存在环，整体问题抽象成追赶问题，因为存在环，所以一定能追赶上。</p><p>（2）求环的入口节点：当需要求环形入口节点的时候，首先将判断有无环，在相遇的时候break，此时假设链表中无环部分长度为a，环长度b，相遇时快指针比慢指针走了n个环长度，f=s+nb，又因为f=2s，所以s=nb，慢指针要走到环入口，需要长度为a+nb，所以慢指针需要再走a个长度，此时将fast设置为head，从head走到环入口长度正好为a，当两个指针指向相同链节点的时候，就到达了环的入口</p><h2 id="关于括号的算法"><a href="#关于括号的算法" class="headerlink" title="关于括号的算法"></a>关于括号的算法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">//用map存储括号的键值对</span></span><br><span class="line">unorder_map&lt;<span class="keyword">char</span>&gt; <span class="built_in">map</span>&#123;&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,&#123;&#125;&#125;;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//用栈存储读入的字符</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span>(字符串不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(当字符是左半边括号时)</span><br><span class="line">    左括号入栈；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    [</span><br><span class="line">    <span class="comment">//取栈顶元素</span></span><br><span class="line">    q=s.top();</span><br><span class="line">    <span class="keyword">if</span>(栈顶元素==<span class="built_in">map</span>[q])</span><br><span class="line">      出栈</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      未能匹配上</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//先出栈，当出栈后栈为空，说明当前右括号前面没有匹配的左括号，此时右括号入栈作为一个位置标记，计算后面的长度，如果在else里出栈，那么会面临出栈后，s.top()不存在的现象</span></span><br><span class="line">      s.pop();</span><br><span class="line">      <span class="comment">//栈为空，存入当前括号</span></span><br><span class="line">      <span class="keyword">if</span>(s.empty())</span><br><span class="line">      s.push(i)</span><br><span class="line">      <span class="comment">//栈不为空，获得长度</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        length=<span class="built_in">max</span>(length,i-s.top())</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>有效的括号（给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。）：在map中存储括号的键值对，利用map[值]=键，每次读入字符串的字符时，如果是左边括号就入栈，否则就是右边括号，需要进行检测是否配对，取这时栈顶的括号，如果键值对匹配上，则出栈，检测下一个，否则是没有匹配上。</p><p>最长有效括号（给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。）：</p><p>（1）初始化：用栈来存储括号，栈里保存括号位置的下标，为了保证获取长度，初始化栈为-1。</p><p>（2）当扫描到左括号的时候，入栈，当扫描到右括号的时候，此时将栈顶元素出栈，分为两种情况，一种是当栈为空的时候，说明之前没有匹配的左括号，把当前括号入栈，另一种栈不为空，说明有匹配的左括号，用当前位置减去栈顶的位置，并更新长度</p><h3 id="深度遍历-剪枝"><a href="#深度遍历-剪枝" class="headerlink" title="深度遍历+剪枝"></a>深度遍历+剪枝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入参数为当前由括号组成的路径，左子树括号的个数，右子树括号的个数，以及最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt;&gt; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件,此时出现了一条满足条件的路径:左右子树的括号个数都为0</span></span><br><span class="line">  <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">    res.push(str)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//剪枝：左子树的括号个数大于右子树的括号个数,出现不匹配</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//左边括号多，先生成左括号</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'('</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">  <span class="comment">//右边括号多，再生成右括号</span></span><br><span class="line">  <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'）'</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>括号的生成（给出 n 代表生成括号的对数，写出一个函数，使其能够生成所有可能的并且有效的括号组合）：实质是对括号做减法，当左括号数量大于0，就不断生成左括号，右括号数量大于0，生成右括号，但是存在不满足括号匹配的条件，当左括号数量大于右括号，此时需要剪枝（加一个判断条件，return）,当左右括号数量都为0，说明找到了一个合适的路径，将其存储下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于链表的算法&quot;&gt;&lt;a href=&quot;#关于链表的算法&quot; class=&quot;headerlink&quot; title=&quot;关于链表的算法&quot;&gt;&lt;/a&gt;关于链表的算法&lt;/h2&gt;&lt;p&gt;链表节点的定义&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ListNode* next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x):val(x),next(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;链表常用算法思想包括：快慢指针（对空间复杂度有要求，可以考虑使用快慢指针）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://www.xiapf.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="括号" scheme="https://www.xiapf.com/tags/%E6%8B%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（二）</title>
    <link href="https://www.xiapf.com/blogs/backTrackNote/"/>
    <id>https://www.xiapf.com/blogs/backTrackNote/</id>
    <published>2020-02-25T07:08:13.000Z</published>
    <updated>2020-03-04T04:56:30.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯一般用于找到满足要求的的所有解，即相当于构造一棵树，从跟节点出发，找到满足条件的所有路径，并进行保存，当目前的路径不符合条件的时候，需要回溯，即剪枝，删除不符合的分支，当到达结束的条件时，即找到了一个满足条件的解，再继续构造下一个符合条件的路径。</p><p>常用于解决树种求得所有解的问题和排列组合中求解问题，或者问题可以转换为求树中一条路径的问题，可以画图。</p><a id="more"></a><h3 id="关于树的回溯"><a href="#关于树的回溯" class="headerlink" title="关于树的回溯"></a>关于树的回溯</h3><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//result存储最终结果，res存储中间结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt; result,<span class="built_in">vector</span> res，….)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//处理当前节点</span></span><br><span class="line">   res.push(root-&gt;val)</span><br><span class="line"></span><br><span class="line">   …</span><br><span class="line"></span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（一般是值相等）并且到达根节点)</span><br><span class="line">  result.push(res)</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;left,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;right,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>找到所有满足目标节点的路径：每次把当前节点加入，并将目标值减去当前节点的值，判断当前叶子节点值（左右子树为空）与0是否相等，相等，则找到一个满足的结果，否则，继续对左右子树递归，此时若存在不满足条件的，需要回溯（pop）</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合求所有符合问题的解，基本框架：</p><p>组合问题按顺序读取，不需要设置used数组，排列问题则需要设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件：找到满足要求的一个解</span></span><br><span class="line">  <span class="keyword">if</span>(满足值为<span class="number">0</span>或者其他条件)</span><br><span class="line">  &#123;</span><br><span class="line">    result.push(res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;数组长度&amp;&amp;target-num[i]&gt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//避免重复元素得出重复组合</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;start&amp;&amp;num[i]==num[i<span class="number">-1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//全排列中不能使用上一层使用的元素</span></span><br><span class="line">      <span class="comment">//设置标志位或者其他判断条件</span></span><br><span class="line">      <span class="keyword">if</span>(!use[i])&#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//当时排列问题，并且有重复数字的时候，需要将上面两个条件结合</span></span><br><span class="line">    <span class="comment">//选择当前节点</span></span><br><span class="line">    res.push(num[i]);</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//选择了该节点，需要设置标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//[可以重复使用]</span></span><br><span class="line">    dfs(i,target-num[i]);</span><br><span class="line">    [<span class="comment">//不可以重复使用</span></span><br><span class="line">    [dfs(i+<span class="number">1</span>,target-num[i]);</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//回溯，取消当前选择，返回上一层</span></span><br><span class="line">    res.pop();</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//撤销选择，需要还原标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 应用场景：</p><p>组合求和（数组元素内部不重复，在数组中找到和为目标值的组合）：首先对数组排序，排序能更方便去重。在dfs函数中，每次传入数组中数据的位置和目标值，当剩余值大于等于0，进入循环，将当前数组值存入路径中，再继续递归，做下一次决策，由于可重复，所以下一次可以仍然从i开始，当满足条件时，将当前路径存入结果，此时回溯到上一层，继续寻找合适的路径。</p><p>组合求和（数组元素内部可能有重复，在数组中找到和为目标值的组合，此时不能重复使用数组的元素，解集不能包含重复的组合）：思路同上，因为不能重复使用数组元素，所以在for循环中dfs函数传值只鞥从i+1开始。与此同时，由于解集不能包含重复的组合，所以在排序后数组，当前一个数组元素和当前数组元素相同，那么当前元素得出的路径和上一个元素必定相同，因此这时需要跳过当前元素，对下一个元素处理。</p><p>全排列（给定一个没有重复数字的序列，返回其所有可能的全排列）：排列题是上一次选择的节点，这次不能再选择。每一层都可以选择一个未出现的元素，需要对数组元素设置标志位，当使用过，就将标志位置为1，此时也需要在for循环中加一层判断，查看当前数组是否被使用，当使用过时，需要跳过该元素，下一层继续选择，找到一个合适的结果后存储下来，接着撤销本次选择，返回上一层查看是否有其他结果。</p><p>全排列（给定一个可包含重复数字的序列，返回所有不重复的全排列）：思路同上，此时需要额外加个判断，看是否有重复的数字，有重复的数字则跳过。具体为：本次节点与前一个相同，并且前一个已使用过，说明已有相同的排列，则本次排列跳过。</p><p>n皇后问题：转换为全排列问题，在每一个的n个位置中选一个作为当前选择，n行做n个选择，并且是做做不重复的选择，正好构成一个排列，此时的排列满足不在同一行不在同一列，只要对当前的排列需要再满足题设条件即可，即不在主对角线，不在副对角线，vector<bool> master1;//副对角线和相同，都为i+j i为行，j为列，两者相加和是当前行，vector<bool> master2;//主对角线差相同，为i-j+n-1 i为行，j为列，再设置两个标志位进行判断，最后将得到的排列用题目中格式打印出来作为结果。</bool></bool></p><p>子集（给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集））：对不同子集个数进行深度遍历，此时需要在主函数中加一个循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>;i++)<span class="comment">//i的长度为0~nums.size(),所以需要加一</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//----通过i控制子集大小</span></span><br><span class="line">  dfs(start,i);</span><br><span class="line">  <span class="comment">//start是从数组中取元素的开始的位置，i是深度，即子集中元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分割字符串（给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串）：每次判断当前的起始至末尾位置是否是回文，如果是就将结果压入res，继续递归。通过不断变换分割的位置，来构造决策树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(start~i之间不是回文)</span><br><span class="line">    继续找下一个回文的位置</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//start~i之间是回文，压入结果内</span></span><br><span class="line">    res.push(s.substr(start,start+i+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">//继续看下一个分割位置</span></span><br><span class="line">    dfs(i+<span class="number">1</span>,depth)</span><br><span class="line">    <span class="comment">//撤销选择，回到上一层决策</span></span><br><span class="line">    res.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯法&quot;&gt;&lt;a href=&quot;#回溯法&quot; class=&quot;headerlink&quot; title=&quot;回溯法&quot;&gt;&lt;/a&gt;回溯法&lt;/h2&gt;&lt;p&gt;回溯一般用于找到满足要求的的所有解，即相当于构造一棵树，从跟节点出发，找到满足条件的所有路径，并进行保存，当目前的路径不符合条件的时候，需要回溯，即剪枝，删除不符合的分支，当到达结束的条件时，即找到了一个满足条件的解，再继续构造下一个符合条件的路径。&lt;/p&gt;&lt;p&gt;常用于解决树种求得所有解的问题和排列组合中求解问题，或者问题可以转换为求树中一条路径的问题，可以画图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="https://www.xiapf.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（一）</title>
    <link href="https://www.xiapf.com/blogs/treeNote/"/>
    <id>https://www.xiapf.com/blogs/treeNote/</id>
    <published>2020-02-24T08:56:00.000Z</published>
    <updated>2020-03-05T03:23:35.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于树的算法"><a href="#关于树的算法" class="headerlink" title="关于树的算法"></a>关于树的算法</h2><p>除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储根节点</span></span><br><span class="line">p.push(root)</span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取该层节点个数</span></span><br><span class="line">  <span class="built_in">width</span>=p.<span class="built_in">size</span>()</span><br><span class="line">  <span class="comment">//读取该层所有节点，并存储下一层节 点</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;<span class="built_in">width</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//读取队首节点</span></span><br><span class="line">    r=p.front()</span><br><span class="line">    出队</span><br><span class="line">    <span class="keyword">if</span>(r的左子树存在) 左子树入队</span><br><span class="line">    <span class="keyword">if</span>(r的右子树存在) 右子树入队</span><br><span class="line">  &#125;</span><br><span class="line">  存储每层的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>应用场景：</p><p>锯齿形层次遍历：需要把偶数行反序排列</p><p>求最大深度：每层入队时，增加一个层数</p><p>求最小深度（从根节点到最近叶子节点的最短路径上的节点数量）：每层遇到左右节点均为空的节点时，输出此时的层数</p><h3 id="前、中、后序遍历"><a href="#前、中、后序遍历" class="headerlink" title="前、中、后序遍历"></a>前、中、后序遍历</h3><p>a.前序 遍历特点：根-左-右</p><p>栈：每次先访问当前节点，并依次将右子树压入栈，再循环遍历左子树，根据先进后出的特点，循环结束后，下次将从最左边子树的右子树开始循环</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line"></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//右子树入栈</span></span><br><span class="line">    s.push(p-&gt;right)</span><br><span class="line">    <span class="comment">//不断遍历左子树</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top();</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.后序 遍历特点：左-右-根</p><p>栈：因为先对根节点访问较为简单，原理类似前序遍历，因此，可以先访问当前根节点，将左子树压入栈，再循环遍历右子树。循环结束，下一次是对最右边的左子树开始循环。形成结果是根-右-左，最后将结果逆序即可</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前根节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//左子树入栈</span></span><br><span class="line">    s.push(p-&gt;left)</span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    p=p-&gt;right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top;</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最终结果逆序</span></span><br><span class="line">reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>c.中序 遍历特点：左-根-右</p><p>栈：中序处理方法和上两种有所不同，需要不断循环先找到最左边叶子节点，在此过程中需要不断把当前遍历到的根节点入栈，栈中存储根节点和左子树节点，当循环结束时，从栈尾中取出节点，再不断对该节点的右子树循环，</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//循环过程中不断将根节点和左子树节点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//根节点入栈</span></span><br><span class="line">    s.push(p)</span><br><span class="line">    <span class="comment">//找到最左边的子树节点</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//访问当前栈尾节点，</span></span><br><span class="line">  p=s,top();</span><br><span class="line">  res.push(p-&gt;val)</span><br><span class="line">  <span class="comment">//从栈中取出根节点</span></span><br><span class="line">  出栈</span><br><span class="line">  <span class="comment">//循环右子树</span></span><br><span class="line">  p=p-&gt;right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>验证一棵树是否是二叉搜索树（二叉搜索树的特点是左子树小于根节点，根节点小于右子树）：可以通过中序遍历比较节点值来判断</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>总体框架：明确一个节点需要做的事，剩余的分别扔给左子树和右子树处理</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//递归结束的条件：一个节点需要做的事（可能有多个结束条件）</span></span><br><span class="line">  <span class="keyword">if</span>(到达树的末尾)</span><br><span class="line">  <span class="keyword">do</span>….</span><br><span class="line">  <span class="comment">//递归循环的条件剩余的交给左右子树处理</span></span><br><span class="line">  doTree(root-&gt;left,其他参数)</span><br><span class="line">  doTree(root-&gt;right,其他参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>具体而言，可以分为以下几类：</p><p>根据前序、中序遍历或者中序、后序遍历构造二叉树：根据前序根节点在首位，可以在中序遍历确定左右子树；根据后序根节点在尾部，可以在中序遍历确定左右子树</p><p> 伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">getTree</span><span class="params">(<span class="built_in">vector</span> p, <span class="keyword">int</span> pl,<span class="keyword">int</span> pr, <span class="built_in">vector</span> i, <span class="keyword">int</span> il,<span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(左位置大于右位置)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="comment">//根据前序或者后序遍历的特点找到根节点</span></span><br><span class="line">  pivot=p[pl]</span><br><span class="line">  <span class="comment">//根据根节点生成树节点</span></span><br><span class="line">  TreeNode root=<span class="keyword">new</span> TreeNode(pivot)</span><br><span class="line">  <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">  pivotindex=il</span><br><span class="line">  <span class="keyword">while</span>(i[pivotindex]!=pivot)</span><br><span class="line">  &#123;</span><br><span class="line">  pivotindex++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定左子树</span></span><br><span class="line">  root-&gt;left= getTree(p,I,左子树的位置)</span><br><span class="line">  <span class="comment">//确定右子树</span></span><br><span class="line">  root-&gt;right= getTree(p,I,右子树的位置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(递归到树的最后，即某一结束的条件)</span><br><span class="line">  ….</span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（达到某一个值）&amp;&amp; doTree（root-&gt;left）&amp;&amp; doTree（root-&gt;right）(左右子树分别满足条件，此时递归，位置也可放到<span class="keyword">return</span>后面))</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>判断树的结构和值是否相同，即是否是相同的树：一个节点判断值是否相同，且左右子树的值和结构是否一致（调用函数，即递归）</p><p>对称二叉树：克隆一个数，和原来的树比较结构是否一致，思路同上</p><p>平衡二叉树（每个节点的左右子树的高度差绝对值小于1）：判断当前节点的高度，且左右子树的高度是否满足高度差小于1（调用函数，即递归）  注：里面包含求树的高度，可以找出左右子树高的那边再加1（也是使用递归）</p><p>判断一个树的路径和是否和目标值相同：每次判断当前叶子节点值（左右子树为空）与目标值是否相等，否则，将目标值减去当前节点值继续对左右子树递归</p><p>转换为二叉搜索树：需要利用中点，将原有数据进行排序,每次需要确定构造的数据的左右位置</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transBTS</span><span class="params">(<span class="built_in">vector</span> num，<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//找到中点,构造根节点</span></span><br><span class="line">  <span class="comment">//(1)数组可以直接利用索引的1/2</span></span><br><span class="line">  <span class="comment">//(2)链表需要利用快慢指针，快指针走两步，慢指针走一步，快指针到末尾的时候，慢指针正好到中点</span></span><br><span class="line">  mid=…</span><br><span class="line">  TreeNode* root=<span class="keyword">new</span> TreeNode(num(mid))</span><br><span class="line">  <span class="comment">//递归构造左子树</span></span><br><span class="line">  root-&gt;left= transBTS(root-&gt;left,left,mid<span class="number">-1</span>)</span><br><span class="line">  <span class="comment">//递归构造右子树</span></span><br><span class="line">  root-&gt;right= transBTS(root-&gt;right, mid<span class="number">-1</span>,right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉搜索树的框架：利用左小右大的特点（类似二分查找）</p><p>​    伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BTS</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束条件</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val==num)</span><br><span class="line">  <span class="keyword">do</span>..(可以做增删改之类的操作)</span><br><span class="line">  <span class="comment">//循环条件</span></span><br><span class="line">  <span class="comment">//大于：对左子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&gt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;left,num)</span><br><span class="line">  <span class="comment">//小于：对右子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&lt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;right,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>二叉树的题目大多数是遍历的变形题，往两个方向考虑：使用bfs——层次遍历还是dfs——深度遍历/回溯、递归，当使用非递归，即层次遍历的时候注意叶子节点的判断。</p><p>例如求二叉树从根节点出发的路径和，可以使用层次遍历，使用两个栈，一个用来存储每层的节点，另一个用来存储每层相加的和，当出现叶子节点的时候就把相加的和累加上去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(栈不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>=p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//存储每层累加的和</span></span><br><span class="line">  <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">width</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    r=p.front();</span><br><span class="line">    <span class="comment">//把当前节点的值加上上一次的和的10倍</span></span><br><span class="line">    val=numQue.front()*<span class="number">10</span>+r-&gt;val;<span class="comment">//numQue中存储每层节点累加的和</span></span><br><span class="line">    p.pop();</span><br><span class="line">    numQue.pop();</span><br><span class="line">    <span class="keyword">if</span>(叶子节点)</span><br><span class="line">      res+=val;</span><br><span class="line">    <span class="keyword">if</span>(左子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(左子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(右子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(右<span class="number">2</span>子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于树的算法&quot;&gt;&lt;a href=&quot;#关于树的算法&quot; class=&quot;headerlink&quot; title=&quot;关于树的算法&quot;&gt;&lt;/a&gt;关于树的算法&lt;/h2&gt;&lt;p&gt;除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。&lt;/p&gt;&lt;h3 id=&quot;层次遍历&quot;&gt;&lt;a href=&quot;#层次遍历&quot; class=&quot;headerlink&quot; title=&quot;层次遍历&quot;&gt;&lt;/a&gt;层次遍历&lt;/h3&gt;&lt;p&gt;队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//队列存储根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.push(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(队列不为空)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//获取该层节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;=p.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//读取该层所有节点，并存储下一层节 点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i&amp;lt;&lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//读取队首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r=p.front()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    出队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的左子树存在) 左子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的右子树存在) 右子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  存储每层的结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://www.xiapf.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.xiapf.com/blogs/sort/"/>
    <id>https://www.xiapf.com/blogs/sort/</id>
    <published>2019-12-26T06:27:48.000Z</published>
    <updated>2020-01-20T12:17:50.705Z</updated>
    
    <content type="html"><![CDATA[<p>几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序</p><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后</p><p>​        第一次排序后：3，5，6，2，7，8，1，4，9</p><p>​        第二次排序后：3，5，2，6，7，1，4，8，9</p><a id="more"></a><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p>第一次：首先排第一个位置，先设min=0记录最小值位置，默认第一个位置，将6与3比较，3比6小，则min=1(代表3的位置)；再将3与5比较，3比5小，不改变min值；依次将min位置的数值依次与后续数字比较，比min小则更改min为更小值的位置，直到最后一个数字比完。此时min=7(1的位置)，将6与7对换，则第一次排序完成。</p><p>​        第一次排序后顺序是：1，3，5，7，2，9，8，6，4</p><p>第二次：排第二个位置，方法同上，设min=1代表默认第二个位置，即数值3默认最小值，将3依次与后续比较，找出最小值，min=最小值的位置，交换第二个位置的值3与min位置的值2，完成第二次排序。</p><p>​        第二次排序后：1，2，5，7，3，9，8，6，4</p><p>​        第三次排序后：1，2，3，7，5，9，8，6，4</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><p>​        第五次排序后顺序为：1，2，3，4，5，9，8，6，7</p><p>​        第六次排序后顺序为：1，2，3，4，5，6，8，9，7</p><p>​        第七次排序后顺序为：1，2，3，4，5，6，7，9，8</p><p>​        第八次排序后顺序为：1，2，3，4，5，6，7，8，9</p><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p>​        第一次排序后：6</p><p>​        第二次排序后：3，6</p><p>​        第三次排序后：3，5，6</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h6><p>同直接插入排序，但是在比较的时候，是折半比较，思想同折半查找</p><p>时间复杂度：O(n^2)</p><h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p>第一次：设步长d=5，则6和9；3和8；5和1；7和4；直接插入排序</p><p>​        第一次排序后：6，3，1，4，2，9，8，5，7</p><p>第二次：d = d/2 = 2，则6，1，2，8，7；3，4，9，5；直接插入排序</p><p>​        第二次排序后：1，3，2，4，6，5，7，9，8</p><p>第三次：d = d/2 = 1，则所有数据直接插入排序</p><p>​        第三次排序后：1，2，3，4，5，6，7，8，9</p><p>时间复杂度：O(nlog2^n)</p><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>第一次：选取第一个数6为轴，将第一个6与最后一个数字4比较（从后往前比），如果大于比较的数字，则调换，然后与原位置后面开始比（从前往后比），以此类推，第一次排完后，轴6的左边都小于6，右边都大于6。</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226160921.png" alt="快速排序i,j变化"></p><p>​        第一次排序后：4，3，5，1，2，6，8，9，7</p><p>第二次：则将上个比较后的轴的左右依次做快速排序，直到所有子表的表长不超过1</p><p>时间复杂度：O(nlog2^n)</p><h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>首先建立初始堆，按照顺序方式建立完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p><p>然后建立大顶堆，分别将有子节点的7，3，5，6从底层开始，分别与子节点比较，选大的作为父节点，即可得到最大的根节点的二叉树，即大顶堆</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226140326.png" alt="大顶堆"></p><p>然后，将堆顶拿下来，将叶子节点放上去，再次按照大顶堆方法，得到根节点，以此类推，最终得到有序数列</p><p>时间复杂度：O(nlog2^n)</p><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><p>对数组递归折半分割，直到分割成单个，然后递归合并比较，直到合并为整个数组</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226142419.png" alt="归并排序"></p><p>时间复杂度：O(nlog2^n)</p><p>总结：时间复杂度是nlog2^n的是：快些(希)归队(堆)，不稳定的是：快些(希)选队(堆)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序&lt;/p&gt;&lt;h6 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h6&gt;&lt;p&gt;第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后&lt;/p&gt;&lt;p&gt;​        第一次排序后：3，5，6，2，7，8，1，4，9&lt;/p&gt;&lt;p&gt;​        第二次排序后：3，5，2，6，7，1，4，8，9&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.xiapf.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.xiapf.com/blogs/hello-world/"/>
    <id>https://www.xiapf.com/blogs/hello-world/</id>
    <published>2019-12-13T12:52:51.111Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo部署时用户名密码设置</title>
    <link href="https://www.xiapf.com/blogs/hexo-deploy/"/>
    <id>https://www.xiapf.com/blogs/hexo-deploy/</id>
    <published>2019-12-13T06:48:37.000Z</published>
    <updated>2019-12-13T12:52:51.112Z</updated>
    
    <content type="html"><![CDATA[<p>hexo部署时用户名密码问题：</p><p>记住用户名密码，不用每次都输入用户名密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>清除用户名密码，防止用户名密码输入错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo部署时用户名密码问题：&lt;/p&gt;&lt;p&gt;记住用户名密码，不用每次都输入用户名密码&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/tags/hexo/"/>
    
      <category term="git" scheme="https://www.xiapf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>docker简易教程</title>
    <link href="https://www.xiapf.com/blogs/docker/"/>
    <id>https://www.xiapf.com/blogs/docker/</id>
    <published>2019-12-12T05:44:29.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker：虚拟化容器技术"><a href="#Docker：虚拟化容器技术" class="headerlink" title="Docker：虚拟化容器技术"></a>Docker：虚拟化容器技术</h2><p>三大组件：镜像，容器，仓库</p><pre><code>镜像：想象成系统iso或者ghost镜像容器：想象成一个系统环境仓库：想象成GitHub</code></pre><p>优点：隔离性   便捷性–移植和集群     轻量级   云支持</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Cenos7下安装docker</p><p>1.把yum包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3.设置yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>4.可以查看所有仓库中所有docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>5.安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-17.12.1.ce</span><br></pre></td></tr></table></figure><p>6.启动Docker，加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>7.验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="编辑容器"><a href="#编辑容器" class="headerlink" title="编辑容器"></a>编辑容器</h2><p>从仓库中拉去一个centos7的镜像 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doucker pull centos:7</span><br></pre></td></tr></table></figure><p>启动镜像生成容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -i -t &lt;IMAGE ID&gt; bash</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER ID&gt; bash</span><br></pre></td></tr></table></figure><p>此时就是进入了centos7的linux系统，可以在里安装jdk,tomcat等，然后部署war后，执行</p><p><code>curl localhost:端口号</code>    看看是否可以访问。</p><p>为了可以启动容器的时候，自动启动tomcat，可以写一个脚本，启动容器的时候，启动此脚本。<br>例如我在最根目录创建了runtomcat.sh的脚本<br>脚本内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/soft/jdk1.5.0_22</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">sh /soft/apache-tomcat-5.5.25/bin/catalina.sh run</span><br></pre></td></tr></table></figure><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>将原来的容器制成镜像–docker commit containerid new_image:tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit centos7_base centos:7.1</span><br></pre></td></tr></table></figure><p>使用新的镜像制成容器–docker run -d -p 主机端口:容器端口/tcp –name 容器名 镜像名:tag  </p><p>并执行docker内脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 18080:8080 --name centos7_1 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>宿主机端口是18080映射了容器内的8080tomcat端口，现在直接访问宿主机的ip:18080/cvbs就可以访问容器的web服务了。<br>查看docker运行情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144010.png" alt="查看docker运行情况"></p><p>可以看到此时新的容器已经启动了</p><p>再次制成一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 28080:8080 --name centos7_2 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>查看docker运行情况–<code>docker ps –a</code></p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144100.png" alt="查看docker运行情况"></p><p>此时可以看到已经部署了两个服务了，分别映射在宿主机的18080和28080端口</p><p>外部浏览器访问：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144117.png" alt="浏览器双端口访问"></p><p>可以看到两个端口都可以访问了</p><p>因为我是在虚拟机里安装，所以局域网中其他机器无法访问到此ip，</p><p>所以为了省略配置虚拟机对外暴露的ip等步骤，直接在主机中通过配置nginx做代理，配置如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144141.png" alt="nginx配置"></p><p>此时外部访问即可<code>http://10.45.12.120/cvbs</code>（我的局域网内ip）即可访问到docker中部署两个的应用。</p><p>注意：因为有些项目没有做分布式session处理，所以简单使用ip_hash策略解决session问题</p><h2 id="IDEA中配置docker"><a href="#IDEA中配置docker" class="headerlink" title="IDEA中配置docker"></a>IDEA中配置docker</h2><p>1.在根目录写Dockerfile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定基础镜像，在其上进行定制FROM java:8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制上下文目录下的target/demo-1.0.0.jar 到容器里</span></span><br><span class="line">ADD target/spring-boot-0.0.1-SNAPSHOT.jar test.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash方式执行，使test.jar可访问</span></span><br><span class="line"><span class="comment">#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。</span></span><br><span class="line">RUN bash -c <span class="string">"touch /test.jar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</span></span><br><span class="line">EXPOSE 8088</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器启动程序及参数   &lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"test.jar"</span>]</span><br></pre></td></tr></table></figure><p>2.在启动配置中配置dockerfile,image,container,port(宿主机和docker的端口映射)</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144221.png" alt="配置dockerfile"></p><p>3.Maven打包</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144237.png" alt="maven打包"></p><p>4.Docker部署</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144250.png" alt="docker部署"></p><p>5.启动Docker</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144304.png" alt="启动docker"></p><p>6.查看docker运行情况</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144319.png" alt="查看docker运行情况3"></p><p>7.浏览器访问成功</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144335.png" alt="浏览器访问"></p><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p><p>可以对各种虚拟化容器技术做统一的管理</p><p>实际项目中大量用到docker时，可以在研究k8s的实际使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;a href=&quot;#Docker：虚拟化容器技术&quot; class=&quot;headerlink&quot; title=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;/a&gt;Docker：虚拟化容器技术&lt;/h2&gt;&lt;p&gt;三大组件：镜像，容器，仓库&lt;/p&gt;&lt;pre&gt;&lt;code&gt;镜像：想象成系统iso或者ghost镜像

容器：想象成一个系统环境

仓库：想象成GitHub&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;优点：隔离性   便捷性–移植和集群     轻量级   云支持&lt;/p&gt;&lt;h2 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h2&gt;&lt;p&gt;Cenos7下安装docker&lt;/p&gt;&lt;p&gt;1.把yum包更新到最新&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://www.xiapf.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.xiapf.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>future与futuretask用法区别</title>
    <link href="https://www.xiapf.com/blogs/future-futuretask/"/>
    <id>https://www.xiapf.com/blogs/future-futuretask/</id>
    <published>2019-12-12T05:32:37.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Future和FutureTask方法区别，主要在于获取返回结果上。"><a href="#Future和FutureTask方法区别，主要在于获取返回结果上。" class="headerlink" title="Future和FutureTask方法区别，主要在于获取返回结果上。"></a>Future和FutureTask方法区别，主要在于获取返回结果上。</h6><p>Future方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(<span class="keyword">new</span> Test7());</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>submit里放的是实现callable接口的类，通过返回值submit.get()，获取返回结果6，如果test抛出异常，此时，主线程会捕获，打印3，不调用submit.get()，将不会捕获异常。</p><p>FutureTask方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Test8());</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(ft);</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            Object o1 = ft.get();</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor里放的是futuretask，futuretask包装了一层callable对象，此时要获取返回结果需要使用futuretask的get()方法，不能使用submit.get(),submit.get()会返回null;只用ft.get()会捕获异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;a href=&quot;#Future和FutureTask方法区别，主要在于获取返回结果上。&quot; class=&quot;headerlink&quot; title=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;/a&gt;Future和FutureTask方法区别，主要在于获取返回结果上。&lt;/h6&gt;&lt;p&gt;Future方式：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test7&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,TimeUnit.SECONDS,&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Future&amp;lt;?&amp;gt; submit = executor.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test7());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object o = submit.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executor.shutdown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://www.xiapf.com/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.xiapf.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://www.xiapf.com/tags/java/"/>
    
      <category term="future" scheme="https://www.xiapf.com/tags/future/"/>
    
  </entry>
  
  <entry>
    <title>用bp网络预测绿萝叶片面积</title>
    <link href="https://www.xiapf.com/blogs/bp-net/"/>
    <id>https://www.xiapf.com/blogs/bp-net/</id>
    <published>2019-12-11T02:46:04.000Z</published>
    <updated>2020-01-20T12:17:50.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。</p></blockquote><hr><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p><em>测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。<br>数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。</em><br><strong>其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。</strong></p><a id="more"></a><ul><li>计算面积的MATLAB程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%% 分割</span><br><span class="line">k=graythresh(I);              %得到最优阈值</span><br><span class="line">j=im2bw(I,k);                  %转换成二值图，k为分割阈值</span><br><span class="line">%imshow(j); </span><br><span class="line">f = bwmorph(j,&apos;open&apos;);  %开运算</span><br><span class="line">figure, imshow(f)</span><br><span class="line">%% 像素点统计</span><br><span class="line">[m,n]=size(f);</span><br><span class="line">k=0;</span><br><span class="line">for i=1:1:m</span><br><span class="line">    for j=1:1:n</span><br><span class="line">        if f(i,j)==0</span><br><span class="line">            k=k+1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">p=k/(m*n);</span><br><span class="line">s=21*29.7*p;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="bp网络设计"><a href="#bp网络设计" class="headerlink" title="bp网络设计"></a>bp网络设计</h1><p>bp网络示意图及各变量含义<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%8F%8A%E5%90%84%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png" alt="bp结构图片"></p><ol><li><p>结构选取<br>a.隐含层数量选取：单隐层结构选择，当仅有一层隐含层时，测试数据正确率已达100%，为降低网络复杂度，所以选择单隐层结构。<br>b.隐含层神经元个数选取</p><table><thead><tr><th align="left">隐含层神经元个数</th><th align="left">达到最小误差时需要迭代的次数</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">1873</td></tr><tr><td align="left">10</td><td align="left">2009</td></tr><tr><td align="left">15</td><td align="left">2259</td></tr></tbody></table><p>根据程序运行来看，当隐藏层神经元个数选择过小（小于5）收敛速度很慢，当到达最大迭代次数时，误差仍很大，当个数选择过大（大于15），网络出现振荡，因此，考虑隐藏层神经元个数在5-15之间，因为本实验数据集属性少，因此选择隐藏层神经元个数为5个，减少复杂度。<br> c.误差函数选择均方差公式：$[    {E_{k} } =1/2*( \hat{y}-y) ]$<br> d.结束条件：<br> 训练结束条件：当误差函数值小于1e-3或者迭代次数大于50000次时结束训练<br> 测试误差判断：当测试集输出面积和实际面积误差函数值大于1e-5时，预测错误，反之预测正确。</p></li><li><p>初始值设置<br>a.权值矩阵的初始值<br>产生0-1之间的随机数作为权值的初始值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srand(time(NULL));//设置随机数种子，使每次产生的随机序列不同</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">    w[i] = rand() % (N + 1) / (float)(N + 1);//N为设置的精度</span><br></pre></td></tr></table></figure><p>b.学习率的初始值<br>学习率控制着算法每一轮的迭代的更新步长，若太大则容易振荡，太小则收敛速度又过慢因此需要选择适合的初始值。<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%8F%98%E5%8C%96.png" alt="学习率变化图片"><br>由图可以看出，当学习率小于1时，网络训练次数多集中在1000以上，但当学习率大于5时，测试集数据会出现错误，因此选择训练次数少并且误差低的学习率=5.</p></li><li><p>数据归一化<br>前三列属性取值∈[2,9]，因此采用对数函数y=log10(x) 以10为底的对数函数转换。<br>最后一列属性取值∈[10,100]，因此采用反余弦函数y=atan(x)*2/PI，保证输入的数据在0-1之间，让网络更快的收敛。</p></li><li><p>前向传播和反向传播<br>a.前向传播<br>激活函数选择sigmod函数，第i个输入层神经元到第h个隐藏层神经元的权值为Vih,第h个隐藏层神经元输入为α=∑Vih<em>Xi，输出为bh;第h个输入层神经元到第j个隐藏层神经元的权值为Whj,第j个输出层神经元的输入β=∑Whj</em>bh,输出为<br>求出激活值，代入sigmod函数中，求得输出值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">   o1[j]=0.0;</span><br><span class="line">   for(int i=0;i&lt;inSum;i++)</span><br><span class="line">   //激活值</span><br><span class="line">   o1[j]=o1[j]+w[i][j]*x[i];</span><br><span class="line">   //实际输出</span><br><span class="line">   x1[j]=1.0/(1+exp(-o1[j]-b1[j])); //b1为偏置量</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>b.反向传播<br>网络在（Xk,Yk)上的均方差为，BP算法基于梯度下降的策略，以目标的负梯度方向进行调整在学习率下，采用链式法则对权值进行更新：<br>从输出层到隐藏层，有:<br>从隐藏层到输入层，有:</p></li></ol><ul><li>算法描述:<blockquote><p>在（0，1）范围内初始化权值和学习率<br>REPEAT<br>FOR all（Xk,Yk)：<br>输入正向传播公式计算输出<br>计算输出层需修改的梯度项gj<br>计算隐藏层层需修改的梯度项eh<br>根据公式更新权值wjh,vij<br>END FOR<br>UNTIL 达到停止条件</p></blockquote></li></ul><p>标准BP算法：上述算法是对每个样本更新权值，属于标准BP算法，参数更新的频繁<br>累积BP算法：当读取完所有样本之后才更新参数，参数更新的频率低<br>区别：累积BP算法在误差下降到一定阶段，下降回非常缓慢，所以往往标准BP算法能更快得到较好解。<br><em>使用标准BP算法：对每个样本更新权值</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        w1[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        w[i][j]+=rate_w*pp[j]*x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>使用累积BP算法：遍历完所有样本再更新权值<br>增加权值修改矩阵，将误差进行累加</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        chg_w2[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">        chg_b2[k]+=rate_b2*qq[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    &#125;</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        chg_w1[i][j]=chg_w1[i][j]+rate_w1*pp[j]*x[i];</span><br><span class="line">        chg_b1[j]+=rate_b1*pp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">548</td><td align="left">348</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">100%</td><td align="left">100%</td></tr></tbody></table><p>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>如果将长边短边合成一条边，效果还是一样吗？<br>将数据集中长边L1和短边L2相加得到叶子的长为L，输入的属性列变为长L,宽W,面积area<br>网络结构采取上述结构，训练效果如下图：<table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">566</td><td align="left">717</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">94.5%</td><td align="left">97.3%</td></tr></tbody></table></li></ul><p>因实验所用的叶片有破损存在，直接用长边加上短边得到的叶片长度存在一定误差，因此使用BP算法时，识别结果略有下降.<br>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr&gt;&lt;h1 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h1&gt;&lt;p&gt;&lt;em&gt;测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。&lt;br&gt;数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。&lt;/em&gt;&lt;br&gt;&lt;strong&gt;其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="神经网络" scheme="https://www.xiapf.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
