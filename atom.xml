<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>八戒大强攻</title>
  
  <subtitle>好久没吃人肉了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiapf.com/"/>
  <updated>2020-02-24T09:01:38.200Z</updated>
  <id>https://www.xiapf.com/</id>
  
  <author>
    <name>Xiapf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leecode算法学习笔记（一）</title>
    <link href="https://www.xiapf.com/blogs/treeNote/"/>
    <id>https://www.xiapf.com/blogs/treeNote/</id>
    <published>2020-02-24T08:56:00.000Z</published>
    <updated>2020-02-24T09:01:38.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-关于树的算法"><a href="#一、-关于树的算法" class="headerlink" title="一、 关于树的算法"></a>一、 关于树的算法</h2><p>除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。</p><h3 id="（1）-层次遍历"><a href="#（1）-层次遍历" class="headerlink" title="（1） 层次遍历"></a>（1） 层次遍历</h3><p>队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储根节点</span></span><br><span class="line">p.push(root)</span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取该层节点个数</span></span><br><span class="line">  <span class="built_in">width</span>=p.<span class="built_in">size</span>()</span><br><span class="line">  <span class="comment">//读取该层所有节点，并存储下一层节 点</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;<span class="built_in">width</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//读取队首节点</span></span><br><span class="line">    r=p.front()</span><br><span class="line">    出队</span><br><span class="line">    <span class="keyword">if</span>(r的左子树存在) 左子树入队</span><br><span class="line">    <span class="keyword">if</span>(r的右子树存在) 右子树入队</span><br><span class="line">  &#125;</span><br><span class="line">  存储每层的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>应用场景：</p><p>锯齿形层次遍历：需要把偶数行反序排列</p><p>求最大深度：每层入队时，增加一个层数</p><p>求最小深度（从根节点到最近叶子节点的最短路径上的节点数量）：每层遇到左右节点均为空的节点时，输出此时的层数</p><h3 id="（2）-前、中、后序遍历"><a href="#（2）-前、中、后序遍历" class="headerlink" title="（2） 前、中、后序遍历"></a>（2） 前、中、后序遍历</h3><p>a.前序 遍历特点：根-左-右</p><p>栈：每次先访问当前节点，并依次将右子树压入栈，再循环遍历左子树，根据先进后出的特点，循环结束后，下次将从最左边子树的右子树开始循环</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line"></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//右子树入栈</span></span><br><span class="line">    s.push(p-&gt;right)</span><br><span class="line">    <span class="comment">//不断遍历左子树</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top();</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.后序 遍历特点：左-右-根</p><p>栈：因为先对根节点访问较为简单，原理类似前序遍历，因此，可以先访问当前根节点，将左子树压入栈，再循环遍历右子树。循环结束，下一次是对最右边的左子树开始循环。形成结果是根-右-左，最后将结果逆序即可</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前根节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//左子树入栈</span></span><br><span class="line">    s.push(p-&gt;left)</span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    p=p-&gt;right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top;</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最终结果逆序</span></span><br><span class="line">reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>c.中序 遍历特点：左-根-右</p><p>栈：中序处理方法和上两种有所不同，需要不断循环先找到最左边叶子节点，在此过程中需要不断把当前遍历到的根节点入栈，栈中存储根节点和左子树节点，当循环结束时，从栈尾中取出节点，再不断对该节点的右子树循环，</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//循环过程中不断将根节点和左子树节点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//根节点入栈</span></span><br><span class="line">    s.push(p)</span><br><span class="line">    <span class="comment">//找到最左边的子树节点</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//访问当前栈尾节点，</span></span><br><span class="line">  p=s,top();</span><br><span class="line">  res.push(p-&gt;val)</span><br><span class="line">  <span class="comment">//从栈中取出根节点</span></span><br><span class="line">  出栈</span><br><span class="line">  <span class="comment">//循环右子树</span></span><br><span class="line">  p=p-&gt;right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>验证一棵树是否是二叉搜索树（二叉搜索树的特点是左子树小于根节点，根节点小于右子树）：可以通过中序遍历比较节点值来判断</p><h3 id="（3）-递归"><a href="#（3）-递归" class="headerlink" title="（3） 递归"></a>（3） 递归</h3><p>总体框架：明确一个节点需要做的事，剩余的分别扔给左子树和右子树处理</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//递归结束的条件：一个节点需要做的事（可能有多个结束条件）</span></span><br><span class="line">  <span class="keyword">if</span>(到达树的末尾)</span><br><span class="line">  <span class="keyword">do</span>….</span><br><span class="line">  <span class="comment">//递归循环的条件剩余的交给左右子树处理</span></span><br><span class="line">  doTree(root-&gt;left,其他参数)</span><br><span class="line">  doTree(root-&gt;right,其他参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>具体而言，可以分为以下几类：</p><p>根据前序、中序遍历或者中序、后序遍历构造二叉树：根据前序根节点在首位，可以在中序遍历确定左右子树；根据后序根节点在尾部，可以在中序遍历确定左右子树</p><p> 伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">getTree</span><span class="params">(<span class="built_in">vector</span> p, <span class="keyword">int</span> pl,<span class="keyword">int</span> pr, <span class="built_in">vector</span> i, <span class="keyword">int</span> il,<span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(左位置大于右位置)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="comment">//根据前序或者后序遍历的特点找到根节点</span></span><br><span class="line">  pivot=p[pl]</span><br><span class="line">  <span class="comment">//根据根节点生成树节点</span></span><br><span class="line">  TreeNode root=<span class="keyword">new</span> TreeNode(pivot)</span><br><span class="line">  <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">  pivotindex=il</span><br><span class="line">  <span class="keyword">while</span>(i[pivotindex]!=pivot)</span><br><span class="line">  &#123;</span><br><span class="line">  pivotindex++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定左子树</span></span><br><span class="line">  root-&gt;left= getTree(p,I,左子树的位置)</span><br><span class="line">  <span class="comment">//确定右子树</span></span><br><span class="line">  root-&gt;right= getTree(p,I,右子树的位置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(递归到树的最后，即某一结束的条件)</span><br><span class="line">  ….</span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（达到某一个值）&amp;&amp; doTree（root-&gt;left）&amp;&amp; doTree（root-&gt;right）(左右子树分别满足条件，此时递归，位置也可放到<span class="keyword">return</span>后面))</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>判断树的结构和值是否相同，即是否是相同的树：一个节点判断值是否相同，且左右子树的值和结构是否一致（调用函数，即递归）</p><p>对称二叉树：克隆一个数，和原来的树比较结构是否一致，思路同上</p><p>平衡二叉树（每个节点的左右子树的高度差绝对值小于1）：判断当前节点的高度，且左右子树的高度是否满足高度差小于1（调用函数，即递归）  注：里面包含求树的高度，可以找出左右子树高的那边再加1（也是使用递归）</p><p>判断一个树的路径和是否和目标值相同：每次判断当前叶子节点值（左右子树为空）与目标值是否相等，否则，将目标值减去当前节点值继续对左右子树递归</p><p>转换为二叉搜索树：需要利用中点，将原有数据进行排序,每次需要确定构造的数据的左右位置</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transBTS</span><span class="params">(<span class="built_in">vector</span> num，<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//找到中点,构造根节点</span></span><br><span class="line">  <span class="comment">//(1)数组可以直接利用索引的1/2</span></span><br><span class="line">  <span class="comment">//(2)链表需要利用快慢指针，快指针走两步，慢指针走一步，快指针到末尾的时候，慢指针正好到中点</span></span><br><span class="line">  mid=…</span><br><span class="line">  TreeNode* root=<span class="keyword">new</span> TreeNode(num(mid))</span><br><span class="line">  <span class="comment">//递归构造左子树</span></span><br><span class="line">  root-&gt;left= transBTS(root-&gt;left,left,mid<span class="number">-1</span>)</span><br><span class="line">  <span class="comment">//递归构造右子树</span></span><br><span class="line">  root-&gt;right= transBTS(root-&gt;right, mid<span class="number">-1</span>,right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉搜索树的框架：利用左小右大的特点（类似二分查找）</p><p>​    伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BTS</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束条件</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val==num)</span><br><span class="line">  <span class="keyword">do</span>..(可以做增删改之类的操作)</span><br><span class="line">  <span class="comment">//循环条件</span></span><br><span class="line">  <span class="comment">//大于：对左子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&gt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;left,num)</span><br><span class="line">  <span class="comment">//小于：对右子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&lt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;right,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-关于树的算法&quot;&gt;&lt;a href=&quot;#一、-关于树的算法&quot; class=&quot;headerlink&quot; title=&quot;一、 关于树的算法&quot;&gt;&lt;/a&gt;一、 关于树的算法&lt;/h2&gt;&lt;p&gt;除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。&lt;/p&gt;&lt;h3 id=&quot;（1）-层次遍历&quot;&gt;&lt;a href=&quot;#（1）-层次遍历&quot; class=&quot;headerlink&quot; title=&quot;（1） 层次遍历&quot;&gt;&lt;/a&gt;（1） 层次遍历&lt;/h3&gt;&lt;p&gt;队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//队列存储根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.push(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(队列不为空)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//获取该层节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;=p.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//读取该层所有节点，并存储下一层节 点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i&amp;lt;&lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//读取队首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r=p.front()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    出队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的左子树存在) 左子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的右子树存在) 右子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  存储每层的结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://www.xiapf.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.xiapf.com/blogs/sort/"/>
    <id>https://www.xiapf.com/blogs/sort/</id>
    <published>2019-12-26T06:27:48.000Z</published>
    <updated>2020-01-20T12:17:50.705Z</updated>
    
    <content type="html"><![CDATA[<p>几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序</p><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后</p><p>​        第一次排序后：3，5，6，2，7，8，1，4，9</p><p>​        第二次排序后：3，5，2，6，7，1，4，8，9</p><a id="more"></a><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p>第一次：首先排第一个位置，先设min=0记录最小值位置，默认第一个位置，将6与3比较，3比6小，则min=1(代表3的位置)；再将3与5比较，3比5小，不改变min值；依次将min位置的数值依次与后续数字比较，比min小则更改min为更小值的位置，直到最后一个数字比完。此时min=7(1的位置)，将6与7对换，则第一次排序完成。</p><p>​        第一次排序后顺序是：1，3，5，7，2，9，8，6，4</p><p>第二次：排第二个位置，方法同上，设min=1代表默认第二个位置，即数值3默认最小值，将3依次与后续比较，找出最小值，min=最小值的位置，交换第二个位置的值3与min位置的值2，完成第二次排序。</p><p>​        第二次排序后：1，2，5，7，3，9，8，6，4</p><p>​        第三次排序后：1，2，3，7，5，9，8，6，4</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><p>​        第五次排序后顺序为：1，2，3，4，5，9，8，6，7</p><p>​        第六次排序后顺序为：1，2，3，4，5，6，8，9，7</p><p>​        第七次排序后顺序为：1，2，3，4，5，6，7，9，8</p><p>​        第八次排序后顺序为：1，2，3，4，5，6，7，8，9</p><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p>​        第一次排序后：6</p><p>​        第二次排序后：3，6</p><p>​        第三次排序后：3，5，6</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h6><p>同直接插入排序，但是在比较的时候，是折半比较，思想同折半查找</p><p>时间复杂度：O(n^2)</p><h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p>第一次：设步长d=5，则6和9；3和8；5和1；7和4；直接插入排序</p><p>​        第一次排序后：6，3，1，4，2，9，8，5，7</p><p>第二次：d = d/2 = 2，则6，1，2，8，7；3，4，9，5；直接插入排序</p><p>​        第二次排序后：1，3，2，4，6，5，7，9，8</p><p>第三次：d = d/2 = 1，则所有数据直接插入排序</p><p>​        第三次排序后：1，2，3，4，5，6，7，8，9</p><p>时间复杂度：O(nlog2^n)</p><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>第一次：选取第一个数6为轴，将第一个6与最后一个数字4比较（从后往前比），如果大于比较的数字，则调换，然后与原位置后面开始比（从前往后比），以此类推，第一次排完后，轴6的左边都小于6，右边都大于6。</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226160921.png" alt="快速排序i,j变化"></p><p>​        第一次排序后：4，3，5，1，2，6，8，9，7</p><p>第二次：则将上个比较后的轴的左右依次做快速排序，直到所有子表的表长不超过1</p><p>时间复杂度：O(nlog2^n)</p><h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>首先建立初始堆，按照顺序方式建立完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p><p>然后建立大顶堆，分别将有子节点的7，3，5，6从底层开始，分别与子节点比较，选大的作为父节点，即可得到最大的根节点的二叉树，即大顶堆</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226140326.png" alt="大顶堆"></p><p>然后，将堆顶拿下来，将叶子节点放上去，再次按照大顶堆方法，得到根节点，以此类推，最终得到有序数列</p><p>时间复杂度：O(nlog2^n)</p><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><p>对数组递归折半分割，直到分割成单个，然后递归合并比较，直到合并为整个数组</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226142419.png" alt="归并排序"></p><p>时间复杂度：O(nlog2^n)</p><p>总结：时间复杂度是nlog2^n的是：快些(希)归队(堆)，不稳定的是：快些(希)选队(堆)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序&lt;/p&gt;&lt;h6 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h6&gt;&lt;p&gt;第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后&lt;/p&gt;&lt;p&gt;​        第一次排序后：3，5，6，2，7，8，1，4，9&lt;/p&gt;&lt;p&gt;​        第二次排序后：3，5，2，6，7，1，4，8，9&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.xiapf.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.xiapf.com/blogs/hello-world/"/>
    <id>https://www.xiapf.com/blogs/hello-world/</id>
    <published>2019-12-13T12:52:51.111Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo部署时用户名密码设置</title>
    <link href="https://www.xiapf.com/blogs/hexo-deploy/"/>
    <id>https://www.xiapf.com/blogs/hexo-deploy/</id>
    <published>2019-12-13T06:48:37.000Z</published>
    <updated>2019-12-13T12:52:51.112Z</updated>
    
    <content type="html"><![CDATA[<p>hexo部署时用户名密码问题：</p><p>记住用户名密码，不用每次都输入用户名密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>清除用户名密码，防止用户名密码输入错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo部署时用户名密码问题：&lt;/p&gt;&lt;p&gt;记住用户名密码，不用每次都输入用户名密码&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/tags/hexo/"/>
    
      <category term="git" scheme="https://www.xiapf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>docker简易教程</title>
    <link href="https://www.xiapf.com/blogs/docker/"/>
    <id>https://www.xiapf.com/blogs/docker/</id>
    <published>2019-12-12T05:44:29.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker：虚拟化容器技术"><a href="#Docker：虚拟化容器技术" class="headerlink" title="Docker：虚拟化容器技术"></a>Docker：虚拟化容器技术</h2><p>三大组件：镜像，容器，仓库</p><pre><code>镜像：想象成系统iso或者ghost镜像容器：想象成一个系统环境仓库：想象成GitHub</code></pre><p>优点：隔离性   便捷性–移植和集群     轻量级   云支持</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Cenos7下安装docker</p><p>1.把yum包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3.设置yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>4.可以查看所有仓库中所有docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>5.安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-17.12.1.ce</span><br></pre></td></tr></table></figure><p>6.启动Docker，加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>7.验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="编辑容器"><a href="#编辑容器" class="headerlink" title="编辑容器"></a>编辑容器</h2><p>从仓库中拉去一个centos7的镜像 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doucker pull centos:7</span><br></pre></td></tr></table></figure><p>启动镜像生成容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -i -t &lt;IMAGE ID&gt; bash</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER ID&gt; bash</span><br></pre></td></tr></table></figure><p>此时就是进入了centos7的linux系统，可以在里安装jdk,tomcat等，然后部署war后，执行</p><p><code>curl localhost:端口号</code>    看看是否可以访问。</p><p>为了可以启动容器的时候，自动启动tomcat，可以写一个脚本，启动容器的时候，启动此脚本。<br>例如我在最根目录创建了runtomcat.sh的脚本<br>脚本内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/soft/jdk1.5.0_22</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">sh /soft/apache-tomcat-5.5.25/bin/catalina.sh run</span><br></pre></td></tr></table></figure><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>将原来的容器制成镜像–docker commit containerid new_image:tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit centos7_base centos:7.1</span><br></pre></td></tr></table></figure><p>使用新的镜像制成容器–docker run -d -p 主机端口:容器端口/tcp –name 容器名 镜像名:tag  </p><p>并执行docker内脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 18080:8080 --name centos7_1 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>宿主机端口是18080映射了容器内的8080tomcat端口，现在直接访问宿主机的ip:18080/cvbs就可以访问容器的web服务了。<br>查看docker运行情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144010.png" alt="查看docker运行情况"></p><p>可以看到此时新的容器已经启动了</p><p>再次制成一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 28080:8080 --name centos7_2 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>查看docker运行情况–<code>docker ps –a</code></p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144100.png" alt="查看docker运行情况"></p><p>此时可以看到已经部署了两个服务了，分别映射在宿主机的18080和28080端口</p><p>外部浏览器访问：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144117.png" alt="浏览器双端口访问"></p><p>可以看到两个端口都可以访问了</p><p>因为我是在虚拟机里安装，所以局域网中其他机器无法访问到此ip，</p><p>所以为了省略配置虚拟机对外暴露的ip等步骤，直接在主机中通过配置nginx做代理，配置如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144141.png" alt="nginx配置"></p><p>此时外部访问即可<code>http://10.45.12.120/cvbs</code>（我的局域网内ip）即可访问到docker中部署两个的应用。</p><p>注意：因为有些项目没有做分布式session处理，所以简单使用ip_hash策略解决session问题</p><h2 id="IDEA中配置docker"><a href="#IDEA中配置docker" class="headerlink" title="IDEA中配置docker"></a>IDEA中配置docker</h2><p>1.在根目录写Dockerfile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定基础镜像，在其上进行定制FROM java:8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制上下文目录下的target/demo-1.0.0.jar 到容器里</span></span><br><span class="line">ADD target/spring-boot-0.0.1-SNAPSHOT.jar test.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash方式执行，使test.jar可访问</span></span><br><span class="line"><span class="comment">#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。</span></span><br><span class="line">RUN bash -c <span class="string">"touch /test.jar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</span></span><br><span class="line">EXPOSE 8088</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器启动程序及参数   &lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"test.jar"</span>]</span><br></pre></td></tr></table></figure><p>2.在启动配置中配置dockerfile,image,container,port(宿主机和docker的端口映射)</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144221.png" alt="配置dockerfile"></p><p>3.Maven打包</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144237.png" alt="maven打包"></p><p>4.Docker部署</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144250.png" alt="docker部署"></p><p>5.启动Docker</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144304.png" alt="启动docker"></p><p>6.查看docker运行情况</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144319.png" alt="查看docker运行情况3"></p><p>7.浏览器访问成功</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144335.png" alt="浏览器访问"></p><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p><p>可以对各种虚拟化容器技术做统一的管理</p><p>实际项目中大量用到docker时，可以在研究k8s的实际使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;a href=&quot;#Docker：虚拟化容器技术&quot; class=&quot;headerlink&quot; title=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;/a&gt;Docker：虚拟化容器技术&lt;/h2&gt;&lt;p&gt;三大组件：镜像，容器，仓库&lt;/p&gt;&lt;pre&gt;&lt;code&gt;镜像：想象成系统iso或者ghost镜像

容器：想象成一个系统环境

仓库：想象成GitHub&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;优点：隔离性   便捷性–移植和集群     轻量级   云支持&lt;/p&gt;&lt;h2 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h2&gt;&lt;p&gt;Cenos7下安装docker&lt;/p&gt;&lt;p&gt;1.把yum包更新到最新&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://www.xiapf.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.xiapf.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>future与futuretask用法区别</title>
    <link href="https://www.xiapf.com/blogs/future-futuretask/"/>
    <id>https://www.xiapf.com/blogs/future-futuretask/</id>
    <published>2019-12-12T05:32:37.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Future和FutureTask方法区别，主要在于获取返回结果上。"><a href="#Future和FutureTask方法区别，主要在于获取返回结果上。" class="headerlink" title="Future和FutureTask方法区别，主要在于获取返回结果上。"></a>Future和FutureTask方法区别，主要在于获取返回结果上。</h6><p>Future方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(<span class="keyword">new</span> Test7());</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>submit里放的是实现callable接口的类，通过返回值submit.get()，获取返回结果6，如果test抛出异常，此时，主线程会捕获，打印3，不调用submit.get()，将不会捕获异常。</p><p>FutureTask方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Test8());</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(ft);</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            Object o1 = ft.get();</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor里放的是futuretask，futuretask包装了一层callable对象，此时要获取返回结果需要使用futuretask的get()方法，不能使用submit.get(),submit.get()会返回null;只用ft.get()会捕获异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;a href=&quot;#Future和FutureTask方法区别，主要在于获取返回结果上。&quot; class=&quot;headerlink&quot; title=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;/a&gt;Future和FutureTask方法区别，主要在于获取返回结果上。&lt;/h6&gt;&lt;p&gt;Future方式：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test7&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,TimeUnit.SECONDS,&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Future&amp;lt;?&amp;gt; submit = executor.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test7());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object o = submit.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executor.shutdown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://www.xiapf.com/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.xiapf.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://www.xiapf.com/tags/java/"/>
    
      <category term="future" scheme="https://www.xiapf.com/tags/future/"/>
    
  </entry>
  
  <entry>
    <title>用bp网络预测绿萝叶片面积</title>
    <link href="https://www.xiapf.com/blogs/bp-net/"/>
    <id>https://www.xiapf.com/blogs/bp-net/</id>
    <published>2019-12-11T02:46:04.000Z</published>
    <updated>2020-01-20T12:17:50.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。</p></blockquote><hr><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p><em>测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。<br>数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。</em><br><strong>其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。</strong></p><a id="more"></a><ul><li>计算面积的MATLAB程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%% 分割</span><br><span class="line">k=graythresh(I);              %得到最优阈值</span><br><span class="line">j=im2bw(I,k);                  %转换成二值图，k为分割阈值</span><br><span class="line">%imshow(j); </span><br><span class="line">f = bwmorph(j,&apos;open&apos;);  %开运算</span><br><span class="line">figure, imshow(f)</span><br><span class="line">%% 像素点统计</span><br><span class="line">[m,n]=size(f);</span><br><span class="line">k=0;</span><br><span class="line">for i=1:1:m</span><br><span class="line">    for j=1:1:n</span><br><span class="line">        if f(i,j)==0</span><br><span class="line">            k=k+1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">p=k/(m*n);</span><br><span class="line">s=21*29.7*p;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="bp网络设计"><a href="#bp网络设计" class="headerlink" title="bp网络设计"></a>bp网络设计</h1><p>bp网络示意图及各变量含义<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%8F%8A%E5%90%84%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png" alt="bp结构图片"></p><ol><li><p>结构选取<br>a.隐含层数量选取：单隐层结构选择，当仅有一层隐含层时，测试数据正确率已达100%，为降低网络复杂度，所以选择单隐层结构。<br>b.隐含层神经元个数选取</p><table><thead><tr><th align="left">隐含层神经元个数</th><th align="left">达到最小误差时需要迭代的次数</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">1873</td></tr><tr><td align="left">10</td><td align="left">2009</td></tr><tr><td align="left">15</td><td align="left">2259</td></tr></tbody></table><p>根据程序运行来看，当隐藏层神经元个数选择过小（小于5）收敛速度很慢，当到达最大迭代次数时，误差仍很大，当个数选择过大（大于15），网络出现振荡，因此，考虑隐藏层神经元个数在5-15之间，因为本实验数据集属性少，因此选择隐藏层神经元个数为5个，减少复杂度。<br> c.误差函数选择均方差公式：$[    {E_{k} } =1/2*( \hat{y}-y) ]$<br> d.结束条件：<br> 训练结束条件：当误差函数值小于1e-3或者迭代次数大于50000次时结束训练<br> 测试误差判断：当测试集输出面积和实际面积误差函数值大于1e-5时，预测错误，反之预测正确。</p></li><li><p>初始值设置<br>a.权值矩阵的初始值<br>产生0-1之间的随机数作为权值的初始值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srand(time(NULL));//设置随机数种子，使每次产生的随机序列不同</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">    w[i] = rand() % (N + 1) / (float)(N + 1);//N为设置的精度</span><br></pre></td></tr></table></figure><p>b.学习率的初始值<br>学习率控制着算法每一轮的迭代的更新步长，若太大则容易振荡，太小则收敛速度又过慢因此需要选择适合的初始值。<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%8F%98%E5%8C%96.png" alt="学习率变化图片"><br>由图可以看出，当学习率小于1时，网络训练次数多集中在1000以上，但当学习率大于5时，测试集数据会出现错误，因此选择训练次数少并且误差低的学习率=5.</p></li><li><p>数据归一化<br>前三列属性取值∈[2,9]，因此采用对数函数y=log10(x) 以10为底的对数函数转换。<br>最后一列属性取值∈[10,100]，因此采用反余弦函数y=atan(x)*2/PI，保证输入的数据在0-1之间，让网络更快的收敛。</p></li><li><p>前向传播和反向传播<br>a.前向传播<br>激活函数选择sigmod函数，第i个输入层神经元到第h个隐藏层神经元的权值为Vih,第h个隐藏层神经元输入为α=∑Vih<em>Xi，输出为bh;第h个输入层神经元到第j个隐藏层神经元的权值为Whj,第j个输出层神经元的输入β=∑Whj</em>bh,输出为<br>求出激活值，代入sigmod函数中，求得输出值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">   o1[j]=0.0;</span><br><span class="line">   for(int i=0;i&lt;inSum;i++)</span><br><span class="line">   //激活值</span><br><span class="line">   o1[j]=o1[j]+w[i][j]*x[i];</span><br><span class="line">   //实际输出</span><br><span class="line">   x1[j]=1.0/(1+exp(-o1[j]-b1[j])); //b1为偏置量</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>b.反向传播<br>网络在（Xk,Yk)上的均方差为，BP算法基于梯度下降的策略，以目标的负梯度方向进行调整在学习率下，采用链式法则对权值进行更新：<br>从输出层到隐藏层，有:<br>从隐藏层到输入层，有:</p></li></ol><ul><li>算法描述:<blockquote><p>在（0，1）范围内初始化权值和学习率<br>REPEAT<br>FOR all（Xk,Yk)：<br>输入正向传播公式计算输出<br>计算输出层需修改的梯度项gj<br>计算隐藏层层需修改的梯度项eh<br>根据公式更新权值wjh,vij<br>END FOR<br>UNTIL 达到停止条件</p></blockquote></li></ul><p>标准BP算法：上述算法是对每个样本更新权值，属于标准BP算法，参数更新的频繁<br>累积BP算法：当读取完所有样本之后才更新参数，参数更新的频率低<br>区别：累积BP算法在误差下降到一定阶段，下降回非常缓慢，所以往往标准BP算法能更快得到较好解。<br><em>使用标准BP算法：对每个样本更新权值</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        w1[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        w[i][j]+=rate_w*pp[j]*x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>使用累积BP算法：遍历完所有样本再更新权值<br>增加权值修改矩阵，将误差进行累加</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        chg_w2[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">        chg_b2[k]+=rate_b2*qq[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    &#125;</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        chg_w1[i][j]=chg_w1[i][j]+rate_w1*pp[j]*x[i];</span><br><span class="line">        chg_b1[j]+=rate_b1*pp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">548</td><td align="left">348</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">100%</td><td align="left">100%</td></tr></tbody></table><p>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>如果将长边短边合成一条边，效果还是一样吗？<br>将数据集中长边L1和短边L2相加得到叶子的长为L，输入的属性列变为长L,宽W,面积area<br>网络结构采取上述结构，训练效果如下图：<table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">566</td><td align="left">717</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">94.5%</td><td align="left">97.3%</td></tr></tbody></table></li></ul><p>因实验所用的叶片有破损存在，直接用长边加上短边得到的叶片长度存在一定误差，因此使用BP算法时，识别结果略有下降.<br>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr&gt;&lt;h1 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h1&gt;&lt;p&gt;&lt;em&gt;测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。&lt;br&gt;数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。&lt;/em&gt;&lt;br&gt;&lt;strong&gt;其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="https://www.xiapf.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
