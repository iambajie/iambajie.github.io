<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>八戒大强攻</title>
  
  <subtitle>好久没吃人肉了</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiapf.com/"/>
  <updated>2020-03-24T09:45:28.247Z</updated>
  <id>https://www.xiapf.com/</id>
  
  <author>
    <name>Xiapf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>监督学习笔记（三）——logistic回归</title>
    <link href="https://www.xiapf.com/blogs/logistic/"/>
    <id>https://www.xiapf.com/blogs/logistic/</id>
    <published>2020-03-24T09:43:06.000Z</published>
    <updated>2020-03-24T09:45:28.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>（1）数据拟合</p><p>给出一些数据，用一条直线来拟合这些数据称作logictic回归</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324153824.png" alt="直线拟合"></p><p>用logistic回归来进行数据分类是通过给出的所有数据点拟合出分类边界的直线，确定这条直线的系数就称为回归系数，当用回归系数乘以当前特征则得出该条直线：</p><p>z=w0 * x0+w1 * x1+…+wn * xn，其中w0<del>wn是回归习俗，x0</del>xn是各个特征，得出的z是当前特征下的预测值。</p><a id="more"></a><p>为了表示直线上下的浮动，需要将x0设置为1，这时的w0就相当于直线方程中的偏置b.</p><p>（2）分类函数</p><p>当logistic回归用作二值分类器的时候，可以用sigmoid函数进行类别判定，sigmoid（x)=1/1+e-x，图像如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324154722.png" alt="sigmoid"></p><p>当z&gt;0.5时，函数值趋近与1，当z&lt;0.5时，函数趋近于0。可以利用这个特性，对将每个特征乘以回归系数得到的输出类别进行判定。</p><p>因此logistic回归就是要求最佳的回归系数，这是求解最优问题，可以使用梯度上升的方法。</p><p>（3）寻求最优</p><p>梯度上升算法是通过每次都向梯度变化最佳的的地方走，最终找到最优值，迭代公式为：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324155903.png" alt="迭代公式"></p><p>其中w是回归系数，alpha是每次沿着梯度方向变化的步长，f(w)是梯度变化函数，即损失函数。这里明确一点，求最佳的回归系数的过程中沿着梯度变化最佳的方向变化，这里的最佳可以理解为是误差最小，也就是w0 * x0+w1 * x1+…+wn * xn得出的预测值f和实际值之间的误差最小，那么就是最佳的方向，即对所有特征来说 f(w)=∑（y-f)xi，这是对公式的直观理解，<a href="https://blog.csdn.net/CharlieLincy/article/details/70767791" target="_blank" rel="external nofollow noopener noreferrer">这里也有对人做了对整个过程的详细推导</a>。到这里为止，logistic回归的核心思想很明确了，就是在一个循环中，对所有的向量乘以当前的回归系数，根据得出的误差调整回归系数，不断循环，直至回归系数稳定。</p><h3 id="和SVM的区别"><a href="#和SVM的区别" class="headerlink" title="和SVM的区别"></a>和SVM的区别</h3><p>相同点：二者都是分类器</p><p>不同点：</p><p>logistic回归用到了所有数据点，svm只用了靠近分类平面的点即支持向量。</p><p>logistic回归利用极大似然估计的思想求解参数，svm通过最大化几何间隔求得最优平面</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="梯度上升"><a href="#梯度上升" class="headerlink" title="梯度上升"></a>梯度上升</h3><p>批处理的方式，将所有数据点一次输入处理</p><p>（1）初始化回归系数，以及每次向梯度方向变化的步长</p><p>根据每个特征的个数，将回归系数初始化为1，假设有3个特征，则回归系数被初始化为3*1的列向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m,n=shape(dataMat)</span><br><span class="line">weights=ones((n,<span class="number">1</span>))</span><br><span class="line">alpha=<span class="number">0.01</span></span><br></pre></td></tr></table></figure><p>（2）不断迭代，直至回归系数稳定</p><p>一般来说，回归系数稳定很难判定，因此通过控制迭代次数来修正回归系数</p><p>这里的dataMat格式为<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324163550.png" alt="dataMat">，每个数据点都有三个特征</p><p>weight的格式为<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324164025.png" alt="weights">，两者相乘，拿第一行来说得到x01w0+x11w1+x21*w0，每行都得出这个值，将每行的结果通过sigmoid函数预测即可得到预测得值，用实际值减去该值，则为误差值。因为这个结果时100 *1 的矩阵，所以实际标签矩阵也应该是100 * 1的矩阵，因此，输入的labelMat需要进行转置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对输入的数据进行处理</span></span><br><span class="line">labelMat=labelMat.transpose()</span><br><span class="line">numIter=<span class="number">500</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numIter):</span><br><span class="line">  h=sigmoid(dataMat*weight)</span><br><span class="line">  error=y-h</span><br><span class="line">  weights=weights+alpha*dataMat.transpose()*error <span class="comment">#这里error是100 *1 的矩阵，矩阵乘法要求行列相同，因此x应该转换为3*100的矩阵进行计算</span></span><br></pre></td></tr></table></figure><h3 id="随机梯度上升"><a href="#随机梯度上升" class="headerlink" title="随机梯度上升"></a>随机梯度上升</h3><p>上面的批处理方式的梯度上升方法每次都要遍历整个数据集，当数据量大的时候就比较费时，因此引入一种在线学习方式的梯度上升，每次随机选择一个样本对回归系数进行修正</p><p>（1）初始化回归系数</p><p>因为每次是对一个数据点处理，因此，只需要初始化一个长度为n的数组，n是数据集中数据特征的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m,n=shape(dataMat)</span><br><span class="line">weights=ones(n)</span><br></pre></td></tr></table></figure><p>（2）每次的步长都更新</p><p>当刚开始的时候离最优值很远，可以步长大点，快速向最优值逼近，当到后面的时候，需要减小步长，慢慢逼近，不然可能会错过最优值。</p><p>j控制迭代次数，i控制每个样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alpha=<span class="number">4</span>/(<span class="number">1</span>+i+j)+<span class="number">0.01</span></span><br></pre></td></tr></table></figure><p>（3）随机选择样本修正回归系数</p><p>设置一个dataIndex里面存储0<del>m-1的数字，每次通过random.uniform生成一个在0</del>len(dataIndex)之间的随机数，代表此次选择这行的样本进行回归系数的修正，每次将该次选择的随机数在dataIndex中删除，防止下次重复选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为了实现对应位置相乘dataMat需要转换为数组</span></span><br><span class="line">dataArr=array(dataMat)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(numIter):</span><br><span class="line">  dataIndex=list(range(m))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    alpha=<span class="number">4</span>/(<span class="number">1</span>+i+j)+<span class="number">0.01</span></span><br><span class="line">    </span><br><span class="line">    randomIndex=int(random.uniform(<span class="number">0</span>,len(dataIndex)))</span><br><span class="line">    chooseIndex=dataIndex[randomIndex]</span><br><span class="line">    h=sigmoid(dataArr[chooseIndex]*weights) <span class="comment">#datamat[i]是1*3数组，weights是1*3数组，对应位置相乘</span></span><br><span class="line">    error=labelMat[chooseIndex]-h</span><br><span class="line">    weights=weights+alpha*error*dataMat[]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">del</span>(dataIndex[randomIndex])</span><br></pre></td></tr></table></figure><p>该方法不需要对矩阵进行转置，运算简洁，同时每次迭代就修改回归系数m次，而批处理的方法每次只能修改一次，这种方法只需要迭代很少的次数，回归系数就趋于稳定了。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>因为数据集本身只有两列，即两个数据特征，因此x0设置为1，w0作为偏置，最终得出的拟和直线为y=w0+w1x1+w2x2，因为使用的是sigmoid函数，分割的直线的y值应该是0，因为sigmoid(0)=0.5，直线转换为w0+w1x1+w2x2=0 =&gt; x2=-w0-w1x1/w2，用plt.plot(x,x2)，这里的x可以在x的取值范围内，取一定步长进行显示（利用arange），可以将图像画出来，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324170500.png" alt="效果图"></p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>问题：用logistic回归预测得疝气病的病马死亡率</p><h3 id="数据集描述"><a href="#数据集描述" class="headerlink" title="数据集描述"></a>数据集描述</h3><p>数据集是从UCI上下载的，里面包含22列属性，其中前21列是马的一些生理特征，最后一列是是否存活，属于类别标签。该案例是从前21列的特征中的出回归系数，得到拟合的回归直线，对马是否存活进行分类。</p><p>该数据集中部分数据（约30%）丢失，对特征丢失的情况进行处理：由于logistic回归中z=w0x0+w1x1+…，其中当特征等于0的时候不影响等式的结果，同时因为使用的判定类别的函数为sigmoid函数，当取值为0，即simoid(0)=0.5，不影响分类，所有丢失的特质均设置为0；对类别标签丢失的情况进行处理：当类别标签丢失的时候无法判断马的存活情况，因此将该条数据丢弃。</p><h3 id="应用描述"><a href="#应用描述" class="headerlink" title="应用描述"></a>应用描述</h3><p>（1）类别判定</p><p>对输入的向量乘以回归系数求和，如果大于0.5，则分类为1，反之分类为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prob=sigmoid(sum(inX*weights))</span><br><span class="line"><span class="keyword">if</span> prob&gt;<span class="number">0.5</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>（2）建立logistic回归模型并进行测试</p><p>训练集建立模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">trainingFile=open(<span class="string">"horseColicTraining.txt"</span>)</span><br><span class="line">trainingMat=[]</span><br><span class="line">trainingLabels=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> curLine <span class="keyword">in</span> trainingFile.readlines():</span><br><span class="line">pstLine=curLine.strip().split(<span class="string">"\t"</span>)</span><br><span class="line">dataList=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">dataList.append(float(pstLine[j]))</span><br><span class="line">trainingMat.append(dataList)</span><br><span class="line">trainingLabels.append(float(pstLine[<span class="number">21</span>]))</span><br><span class="line"></span><br><span class="line">weights=stoGradAscent1(trainingMat,trainingLabels,<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>测试次测试错误率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">testFile=open(<span class="string">"horseColicTest.txt"</span>)</span><br><span class="line"></span><br><span class="line">testMat=[]</span><br><span class="line">testLabels=[]</span><br><span class="line"><span class="keyword">for</span> curLine <span class="keyword">in</span> testFile.readlines():</span><br><span class="line">pstLine=curLine.strip().split(<span class="string">"\t"</span>)</span><br><span class="line">dataList=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">dataList.append(float(pstLine[j]))</span><br><span class="line">testMat.append(dataList)</span><br><span class="line">testLabels.append(float(pstLine[<span class="number">21</span>]))</span><br><span class="line"></span><br><span class="line">error=<span class="number">0</span></span><br><span class="line">n=shape(testMat)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">predictData=classfyVec(testMat[i],weights)</span><br><span class="line"><span class="keyword">if</span>(predictData!=testLabels[i]):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line">errorRate=float(error)/n</span><br><span class="line">print(<span class="string">"error rate is:"</span>+str(errorRate))</span><br></pre></td></tr></table></figure><p>（3）取平均数</p><p>一次数据可能存在偶然性，因此运行10次取平均值，作为该模型的分类正确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numTest=<span class="number">10</span></span><br><span class="line">errorCount=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numTest):</span><br><span class="line">errorCount+=colicTest()</span><br><span class="line"></span><br><span class="line">allError=float(errorCount/<span class="number">10</span>)</span><br><span class="line">print(<span class="string">"the average of ten times error is:"</span>)</span><br><span class="line">print(allError)</span><br></pre></td></tr></table></figure><p>最终运行10次的结果为：</p><blockquote><p>error rate is:0.6268656716417911<br>error rate is:0.3582089552238806<br>error rate is:0.26865671641791045<br>error rate is:0.2537313432835821<br>error rate is:0.44776119402985076<br>error rate is:0.29850746268656714<br>error rate is:0.47761194029850745<br>error rate is:0.26865671641791045<br>error rate is:0.26865671641791045<br>error rate is:0.5522388059701493<br>the average of ten times error is:<br>25.6</p></blockquote><p>平均错误率25%左右，因为数据集有30%的数据丢失，因此错误率相对较高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;h3 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; title=&quot;原理分析&quot;&gt;&lt;/a&gt;原理分析&lt;/h3&gt;&lt;p&gt;（1）数据拟合&lt;/p&gt;&lt;p&gt;给出一些数据，用一条直线来拟合这些数据称作logictic回归&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200324153824.png&quot; alt=&quot;直线拟合&quot;&gt;&lt;/p&gt;&lt;p&gt;用logistic回归来进行数据分类是通过给出的所有数据点拟合出分类边界的直线，确定这条直线的系数就称为回归系数，当用回归系数乘以当前特征则得出该条直线：&lt;/p&gt;&lt;p&gt;z=w0 * x0+w1 * x1+…+wn * xn，其中w0&lt;del&gt;wn是回归习俗，x0&lt;/del&gt;xn是各个特征，得出的z是当前特征下的预测值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="logistic" scheme="https://www.xiapf.com/tags/logistic/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（五）面试高频题——topk问题</title>
    <link href="https://www.xiapf.com/blogs/topK/"/>
    <id>https://www.xiapf.com/blogs/topK/</id>
    <published>2020-03-23T10:56:18.000Z</published>
    <updated>2020-03-23T10:57:39.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个数组，求数组中前k个最大/最小的数或者求数组中第k个最大/最小的数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>（1）思路：调用sort函数将数组排序，选择前k个或者第k个输出</p><p>（2）复杂度分析：</p><p>时间复杂度：主要是在比较排序上了，该方法对整个数组排序，c++中的sort使用的是快速排序，时间复杂度为O(nlogn)</p><p>空间复杂度：没有用到额外的空间，复杂度为O（1）</p><a id="more"></a><p>（3）代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>（1）思路：</p><p>维护一个k个元素的堆，将数组中元素和队首元素比较，形成最终稳定的堆：</p><p>求前k个最大的数即需要维护一个小顶堆，队首是最小的元素，当读入的数据大于等于队首元素，则加入堆中，保证其余元素都大于队首的元素，每次仅需比较队首元素即可，当遍历到最后，堆中剩下前k个最大的数；</p><p>当求前k个最小的数即需要维护一个大顶堆，队首是最大的元素，当读入的数据小于等于队首元素，则加入堆中，保证其他元素都小于队首的元素，最终，堆中剩下前k个最小的数。</p><p>（2）复杂度分析：</p><p>时间复杂度：每次维护一个k个元素的堆，相当于建立一个二叉树，深度是logk，最差的情况是n个数都需要排序比较，则复杂度是O（nlogk）</p><p>空间复杂度：用到了k大小的堆，复杂度为O（k）</p><p>（3）代码：</p><p>以求前k个最大的元素为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.建小顶堆 后两个元素缺省，自动建立大顶堆</span></span><br><span class="line">prioriy_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">  p.push(num[i])</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//2.队首元素比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;num.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//队首元素小，则把新元素加入</span></span><br><span class="line">  <span class="keyword">if</span>(p.top()&lt;num[i])</span><br><span class="line">  &#123;</span><br><span class="line">    p.pop();</span><br><span class="line">    p.push(num[i]);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>（1）思路：快速排序是以一个基准点进行排序，当在基准点的左边都是小于该数的，右边都是大于该数的。从这个思路出发可以想到，求前k个最小的数可以转换为在第k个位置进行排序，左边是小于的数，右边是大于的数，求前k个最小的数就是前k个数。因为快速排序时每次排序可以得到当前基准点的位置，以此判断是否在第k个位置。这种方法不用遍历整个数组，排序的次数减少了。快速排序处理两边的数，这边只需要对一边的数进行排序。</p><p>当求前k个最大的数时可以进行转换：首先第k个最大的数，如果6个数，从小到大排列，则索引是6-k，即求第6-k个最小的数，前k个最大的数，就是从该位置到数组末尾。</p><p>eg.假设有6个数字2，5，7，1，3，9，排序之后为1，2，3，5，7，9，求第3大的数字即5，从左往右数，元素5的索引为3，3=6-3（k的值），所以第k个最大的数=第6-k个最小的数</p><p>（2）复杂度分析：</p><p>时间复杂度：相比较sort方法来说，减少了排序的次数，获取每次排序的位置，当该位置小于k，则说明下一次排序需要在当前位置和right位置之间寻找第k个位置，反之需要在left和当前位置之间寻找。每次减少一半需要排序的数字，则为n+n/2+…=O（n）</p><p>空间复杂度：递归调用栈，复杂度为O（n）</p><p>（3）代码：</p><p>以求前k个最大的元素为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">int</span> pos=num.<span class="built_in">size</span>()-k <span class="comment">//进行位置转换</span></span><br><span class="line">quickSort(num,<span class="number">0</span>,num.<span class="built_in">size</span>(),pos)</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序函数</span></span><br><span class="line"><span class="keyword">void</span> quickSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num,<span class="keyword">int</span> lef,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> p=partition(num,left,right);</span><br><span class="line">  <span class="keyword">if</span>(p==k)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;k)</span><br><span class="line">      quickSort(num,left,p<span class="number">-1</span>,k)</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       quickSort(num,p+<span class="number">1</span>,right,k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序位置函数</span></span><br><span class="line"><span class="keyword">int</span> partition(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i=left;</span><br><span class="line">  <span class="keyword">int</span> j=right;</span><br><span class="line">  <span class="keyword">int</span> base=num[i];</span><br><span class="line">  <span class="comment">//找到基准值的位置</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//找到比基准值小的</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]&gt;=base)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="comment">//找到比基准值大的</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]&lt;=base)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">      swap(num[i],num[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  num[left]=num[i];</span><br><span class="line">  num[i]=base;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;给出一个数组，求数组中前k个最大/最小的数或者求数组中第k个最大/最小的数。&lt;/p&gt;&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h3 id=&quot;暴力法&quot;&gt;&lt;a href=&quot;#暴力法&quot; class=&quot;headerlink&quot; title=&quot;暴力法&quot;&gt;&lt;/a&gt;暴力法&lt;/h3&gt;&lt;p&gt;（1）思路：调用sort函数将数组排序，选择前k个或者第k个输出&lt;/p&gt;&lt;p&gt;（2）复杂度分析：&lt;/p&gt;&lt;p&gt;时间复杂度：主要是在比较排序上了，该方法对整个数组排序，c++中的sort使用的是快速排序，时间复杂度为O(nlogn)&lt;/p&gt;&lt;p&gt;空间复杂度：没有用到额外的空间，复杂度为O（1）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="topK" scheme="https://www.xiapf.com/tags/topK/"/>
    
  </entry>
  
  <entry>
    <title>非监督学习笔记（一）——K均值聚类</title>
    <link href="https://www.xiapf.com/blogs/kMeans/"/>
    <id>https://www.xiapf.com/blogs/kMeans/</id>
    <published>2020-03-19T07:46:28.000Z</published>
    <updated>2020-03-19T07:51:58.568Z</updated>
    
    <content type="html"><![CDATA[<p>非监督学习和监督学习不同，监督学习知道需要寻找的内容，即目标变量，会通过数据训练出能得出目标变量学习模型，而监督学习不知道目标变量，非监督学习中有一种聚类方法，把相似的点放在一个簇（类）中，类似于全自动分类，度量数据的相似有很多函数，包括欧式距离，球面距离等。</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>k均值聚类属于一种聚类算法，通过给定的数值k，将数据点分为k类，分类依据为相似的数据点放到一个簇里，这里簇的中心称为质心，一般可以用距离公式来度量数据点之间的相似度。假设以欧式距离作为相似度评价依据，则点到各个质心中的最小距离的那个簇是该数据点所在的位置，最终可以将数据分为k类。</p><a id="more"></a><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>注：因为度量数据之间相似度的函数通常都需要将数据转换为矩阵进行处理，所以程序中需要注意数据的存储形式，如果是列表形式需要转换为矩阵进行处理。</p><p>当有赋值操作的时候，mat类型不能直接赋值，需要转换为list类型。例如，matop=matop.tolist()[0]</p><p>（1）读入数据</p><p>根据输入的文件名读入数据，根据相似度计算方法，需要把数据转换为float数值类型，同时转换为矩阵</p><p>（2）确定相似度计算方法</p><p>以欧式距离为例：计算两个矩阵对应位置相减平方求和，最后再开根号作为两个矩阵之间的距离</p><p>sqrt(sum(power)(veca-vecb))   列表或者矩阵之间求次方用power函数</p><p>（3）确定初始质心选择方法</p><p>设定输入的数据形式为（x,y）</p><p>一般初始质心使用随机选择的方法，为了将随机矩阵的值控制在数据范围内，根据每列的最大值和最小值，生成k*n（n此时为2）个随机数据，以此作为初始的k个质心。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取数据点的列数</span></span><br><span class="line">n=shape(data)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#随机数组</span></span><br><span class="line">centroids=mat(zeros((k,n)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">  minI=min(data[:,i])</span><br><span class="line">  maxI=max(data[:,i])</span><br><span class="line">  rangeI=float(maxI-minI)</span><br><span class="line">  centroids[:,i]=mat(minI+rangeI*rand(k,<span class="number">1</span>))<span class="comment">#返回k*1个0~1之间的随机数</span></span><br></pre></td></tr></table></figure><p>（4）根据相似度将数据分类</p><p>a）初始化质心：以随机选择的方式</p><p>b）当簇仍在发生变化</p><p>对每个数据点，计算当前点到各个质心的距离，选择最近的距离，将该点放入</p><p>将簇内所有数据点取均值，重新计算当前的质心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n=shape(data)[<span class="number">0</span>]</span><br><span class="line">clusterAssment=mat(zeros((n,<span class="number">2</span>)))<span class="comment">#存储对应行的点属于哪个簇，以及误差</span></span><br><span class="line"><span class="keyword">while</span>(簇在变化):</span><br><span class="line">  flag=false<span class="comment">#标记簇是否在变化</span></span><br><span class="line">  <span class="comment">#1.对每个数据点</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    minDist=inf</span><br><span class="line">    minIndex=<span class="number">-1</span></span><br><span class="line">    <span class="comment">#计算该点到各个质心的距离</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">      pstCurret=distmes(centroids[k,:],data[i,:])<span class="comment">#distmes为相似度计算方法</span></span><br><span class="line">      <span class="keyword">if</span>(pstCurret&lt;minDist):</span><br><span class="line">        最小值交换</span><br><span class="line">    <span class="keyword">if</span>(clusterAssment[i,<span class="number">0</span>]!=minIndex):</span><br><span class="line">      flag=true<span class="comment">#说明簇还在变化</span></span><br><span class="line">     <span class="comment">#2.将点加入到簇中</span></span><br><span class="line">    clusterAssment[i,:]=minIndex,minDist**<span class="number">2</span></span><br><span class="line">  <span class="comment">#3.对每个簇（即质心），对簇内数据点取均值</span></span><br><span class="line">  <span class="keyword">for</span> cent <span class="keyword">in</span> range(k):</span><br><span class="line">    pstCurret=data[nonzero(clusterAssment[:,<span class="number">0</span>].A[<span class="number">0</span>]==cent)]</span><br><span class="line">    centroids[cent,:]=mean(pstCurret,axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><p>k均值聚类算法依赖与用户给定的数值k，此时无法确定根据k得出的簇是最优的。评价算法的优劣是根据误差平方和（称SSE），即数据真实值为y，预测值为y1，则误差平方和为（y-y1）2，k均值聚类算法的改进是根据SSE最小时，将数据分为k个类。</p><p>初始时将所有数据点作为一个簇，每次将簇一分为二，选择哪个簇进行划分要看能否最大化减少sse，当划分之后的sse比原来的小，则保存当前的质心，最终得到的簇误差平方和最小，改进的算法也称二分k均值聚类。</p><p>（1）将所有数据作为一个簇，取均值得到初始的质心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所有数据取均值</span></span><br><span class="line">centroids0=mean(data,axis=<span class="number">0</span>).tolist[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#转换为矩阵形式</span></span><br><span class="line">centroids=mat(centroids0)</span><br><span class="line"><span class="comment">#求初始质心到各点的距离</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">  clusterAssment[i,<span class="number">1</span>]=distmes(centroids,data[i,:])**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>（2）当簇的长度小于k</p><p>a）对所有簇</p><p>将簇一分为二，得到此时的误差，找到一分为二之后误差最小的簇</p><p>b）误差最小的簇，将其保存</p><p>注：当有赋值操作的时候，mat类型不能直接赋值，需要转换为list类型。例如，matop=matop.tolist()[0]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将每个质心放入一个大列表中进行操作</span></span><br><span class="line">centroList=[centroids0]</span><br><span class="line"><span class="keyword">while</span>(len(centroList)&lt;k):</span><br><span class="line">  lossSSE=inf</span><br><span class="line">  <span class="comment">#1.对所有簇，找误差最小的</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(centroList)):</span><br><span class="line">    <span class="comment">#当前簇的所有数据点 clusterAssment第0列</span></span><br><span class="line">    pstCurrent=data[nonzero(clusterAssment[:,<span class="number">0</span>].A==i)[<span class="number">0</span>],:]</span><br><span class="line">    <span class="comment">#二分簇</span></span><br><span class="line">    centroids,splitCluster=kmeans(pstCurrent,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#求误差</span></span><br><span class="line">    sseSplit=sum(splitCluster[:,<span class="number">1</span>])</span><br><span class="line">    sseNotSplit=sum(clusterAssment[nonzero(clusterAssment[:,<span class="number">0</span>].A!=i)[<span class="number">0</span>],<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span>(sseSplit+sseNotSplit&lt;lossSSE):</span><br><span class="line">      bestCent=i</span><br><span class="line">      bestCluster=splitCluster.copy()</span><br><span class="line">      bestCentroid=centroids</span><br><span class="line">      lossSSE=sseSplit+sseNotSplit</span><br><span class="line">   <span class="comment">#2.更新簇的结果，一个取代成为第i个簇，另一个成为第m+1个簇，原来一共有m个簇</span></span><br><span class="line">  bestCluster[nonzero(bestCluster[:,<span class="number">0</span>].A==<span class="number">0</span>)[<span class="number">0</span>],<span class="number">0</span>]=bestCent</span><br><span class="line">  bestCluster[nonzero(bestCluster[:,<span class="number">0</span>].A==<span class="number">1</span>)[<span class="number">0</span>],<span class="number">0</span>]=len(centroList)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#3.将最佳分类的质心加入簇列表 二分类所以质心是两个</span></span><br><span class="line">  centroList[bestCent]=bestCentroid[<span class="number">0</span>,:].tolist()[<span class="number">0</span>]</span><br><span class="line">  centroList.append(bestCentroid[<span class="number">1</span>,:].tolist()[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#4.将簇分类的结果加入列表中</span></span><br><span class="line">  clusterAssment[nonzero(clusterAssment[:,<span class="number">0</span>].A==bestCent)[<span class="number">0</span>],:]=bestCluster</span><br></pre></td></tr></table></figure><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>给出地图上一些点的经度和纬度，将其分为合适的类，使得通过中心点能很快到达其余点。同时观察不同的簇数目k的分类效果。</p><p>（1）数据来源</p><p>从谷歌api上获取一些club的经度和纬度保存为place.txt，其中每一行代表一个club的位置，最后两行保存了对应地点的纬度和经度</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200319144017.png" alt="数据点"></p><p>（2）运行kmeans.clubsCluster(“place.txt”,5)</p><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200319150954.png" alt="效果图"></p><p>可以看出数据点被分成了5个簇，每个簇的中心用“+”号标记出来了，此时从簇的中心到其余点是最近的。</p><p>（3）观察不同k下的运行结果</p><p>当分的簇越多，簇的误差就越小，但是数量越多不符合实际，因此需要找一个折中点。</p><p>（4）程序：</p><p>a）相似度计算方法使用球面距离公式：</p><p>设所求点A纬度角β1，经度角α1， 点B 纬度角β2， 经度角α2  R*arccos[cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2] </p><p>b）聚类：</p><p>1.读入文件中最后两行数据，并转换为数值类型的mat类型矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fr=open(filename)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">  <span class="comment">#以\t分割每行数据，并且去掉每行最后的回车符</span></span><br><span class="line">  lineList=line.rstrip(<span class="string">"\n"</span>).split(<span class="string">"\t"</span>)</span><br><span class="line">  dataList.append((float(lineList[<span class="number">4</span>],float(lineList[<span class="number">5</span>])))</span><br><span class="line">dataList=mat(dataList)</span><br></pre></td></tr></table></figure><p>2.使用二分k均值分类，得出最佳分类簇centroids</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centroids,clusterAssment=biKmeans(dataList,k,distMes=球面距离公式)</span><br></pre></td></tr></table></figure><p>3.画图</p><p>将得到的分类结果展示出来，使用matplotlib库中的pyplot进行画图</p><p>画图准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig=plt.figure()</span><br><span class="line"><span class="comment">#设置显示图形的位置和比例</span></span><br><span class="line">ret=[<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>]</span><br><span class="line">.....</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>画背景</p><p>读入背景图片，并显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img=plt.imread(背景图片)</span><br><span class="line"><span class="comment">#按照横纵坐标数据比列设置坐标轴,并会去掉预设坐标数字</span></span><br><span class="line">axpos=dict[xticks[],yticks[]]</span><br><span class="line"><span class="comment">#为显示的图像设置底层区域</span></span><br><span class="line">axis0=fig.add_axis(ret,label=<span class="string">""</span>,**axpos)</span><br><span class="line">axis0.imshow(img)</span><br></pre></td></tr></table></figure><p>加上**axpos效果，此时按照数据点数值大小设置坐标轴</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200319150954.png" alt="加上**axpos"></p><p>去掉**axpos效果，发现坐标轴数字出现重叠</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200319151338.png" alt="去掉**axpos"></p><p>画数据点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置图案标记</span></span><br><span class="line">markerList=[<span class="string">'s'</span>,....]</span><br><span class="line"><span class="comment">#为显示的图像增加子区域,frameon设置是否覆盖下面的区域</span></span><br><span class="line">axis1=fig.add_axis(ret,label=<span class="string">""</span>,frameon=false)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">  <span class="comment">#获取第i个簇的数据点</span></span><br><span class="line">  pstCurrent=dataList[nonzero(clusterAssment[:,<span class="number">0</span>].A==i)[<span class="number">0</span>],:]</span><br><span class="line">  pstMarker=markerList[i/len]</span><br><span class="line">  <span class="comment">#二维转换为一维显示</span></span><br><span class="line"> axis1.scatter(pstCurrent[:,<span class="number">0</span>].flattern().A[<span class="number">0</span>],pstCurrent[:,<span class="number">1</span>].flattern().A[<span class="number">0</span>],marker=pstMarker,s=<span class="number">90</span>)</span><br></pre></td></tr></table></figure><p>注：</p><p>1.subplot，add_axis的区别</p><p>subplot是设置一整个区域中的子图，不存在重叠：subplot(221)表示将显示图像的区域分为2*2个，当前图案显示在第一个位置。</p><p>add_axis是设置同一个图像中的区域，存在重叠。</p><p>2.scatter，plot的区别</p><p>scatter是绘制数据点，属于离散型图案</p><p>plot是将数据点连接起来，属于连续型图案</p><p>画每个簇的中心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(k):  </span><br><span class="line">  axis1.scatter(centroids[i,<span class="number">0</span>],centroids[i,<span class="number">1</span>],marker=<span class="string">"+"</span>,s=<span class="number">300</span>)<span class="comment">#每个质心颜色会不一样</span></span><br><span class="line">  或者 axis1.scatter(centroids[:,<span class="number">0</span>].flattern().A[<span class="number">0</span>],centroids[:,<span class="number">1</span>].flattern().A[<span class="number">0</span>],marker=<span class="string">"+"</span>,s=<span class="number">300</span>)<span class="comment">#每个质心颜色一样</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非监督学习和监督学习不同，监督学习知道需要寻找的内容，即目标变量，会通过数据训练出能得出目标变量学习模型，而监督学习不知道目标变量，非监督学习中有一种聚类方法，把相似的点放在一个簇（类）中，类似于全自动分类，度量数据的相似有很多函数，包括欧式距离，球面距离等。&lt;/p&gt;&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;p&gt;k均值聚类属于一种聚类算法，通过给定的数值k，将数据点分为k类，分类依据为相似的数据点放到一个簇里，这里簇的中心称为质心，一般可以用距离公式来度量数据点之间的相似度。假设以欧式距离作为相似度评价依据，则点到各个质心中的最小距离的那个簇是该数据点所在的位置，最终可以将数据分为k类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="k均值聚类" scheme="https://www.xiapf.com/tags/k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>监督学习笔记（二）——朴素贝叶斯分类器</title>
    <link href="https://www.xiapf.com/blogs/bayes/"/>
    <id>https://www.xiapf.com/blogs/bayes/</id>
    <published>2020-03-12T11:25:59.000Z</published>
    <updated>2020-03-12T11:27:00.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>（1）问题原理：朴素贝叶斯分类的依据是概率，假设需要分为两类c1和c2，则某个数据点属于哪一类，需要计算p(c1|x)和p{c2|x)，即计算数据点x来自c1和来自c2中的概率哪个大，如果p(c1|x)&gt;p{c2|x)，则x被分到c1类别中，反之被分到c2类别中。</p><p>（2）计算原理：上述概率属于条件概率，根据公式p(c|x)=p(x|c) * p(c)/ p(x)可以得到，当求（x,y）来自哪个类别时，即用（x,y）替换x，即求p(c|x,y),代入条件概率公式中得，p(c|x,y)=p(x,y|c) * p(c)/p(x,y)，因此问题转换为求p(x,y|c) * p(c)/p(x,y)中三个概率的值。</p><a id="more"></a><p>求p(c)：对于所有数据点来说，p(c)是出现某类别的数据/总数据</p><p>求p(x,y|c)：因为朴素贝叶斯的假设是所有特征是独立的，那么p(x,y|c)=p(x1,y1|c) * p(x2,y2|c) *… * p(xn,yn|c)，p(xi,yi|c)是求在某个类别下，每个特征的数据占当前类别总数据的概率，每个特征的概率求解出后连乘即可得到该概率</p><p>求p(x,y)：因为对于所有类别来说p(x,y)都是相同的，所以只要比较上面两个概率乘积的大小即可</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>以二分类为例子：</p><p>（1）载入数据集</p><p>1.读取文件路径，并将读取的文件按照单词进行划分，划分使用正则表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex=re.compile(<span class="string">"\\W+"</span>)</span><br><span class="line">listToken=regex.split(file)</span><br></pre></td></tr></table></figure><p>2.将数据进行存储，同时存储数据标签</p><p>注：因为此时存储的数据集是文本，在测试和训练的时候需要转换为单词向量的形式</p><p>输入词汇表和需要变为单词向量的文本，在词汇表中出现的单词的位置，在单词向量中对应设置为1，其余为0，这样就能构造出单词向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> inputWord:</span><br><span class="line">  <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">    returnVec[vocaList.index(word)]+=<span class="number">1</span><span class="comment">#在词汇表中单词的位置的，对应的单词向量的位置设置为1</span></span><br></pre></td></tr></table></figure><p>（ * ）可增加的部分：删除高频词</p><p>因为有些词例如a,about,the等这些常用词在很多地方都会出现，这些高频出现的词，可能会对分类的概率产生影响，可以对所有数据进行遍历，找到出现频率最高的单词在词汇表中删除（可以取前20或30等，根据数据量决定）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcTopWord</span><span class="params">(fullText,vocabList)</span>:</span></span><br><span class="line">  //存储出现概率及单词，用到键值对</span><br><span class="line">  wordList=&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> word <span class="keyword">in</span> fullText:</span><br><span class="line">    wordlist[word]=fullText.(word)<span class="comment">#在整篇文档计算单词出现的次数，count</span></span><br><span class="line">  //从大到小排序,用值排序</span><br><span class="line">  rankList=sorted(wordList.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>（2）得出词汇表</p><p>找到数据集中不重复的单词作为词汇表，为后续统计每个单词出现的频率（即每个特征的概率）做准备</p><p>用set得到不重复的单词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataWord <span class="keyword">in</span> dataSet:</span><br><span class="line">vocaList=vocaList|set(dataWord)</span><br></pre></td></tr></table></figure><p>（3）随机选择一部分作为测试集和训练集</p><p>将训练集设置为总数据集数量，测试集用随机数设置（random.uniform）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trainSet=list(range(lenData))</span><br><span class="line"><span class="comment">#假设随机选择5个测试集</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  <span class="comment">#得出位置 int类型</span></span><br><span class="line">  testIndex=(int)(random.uniform(<span class="number">0</span>,len(trainSet)))</span><br><span class="line">  <span class="comment">#测试集的数据位置</span></span><br><span class="line">  testSet.appen(trainSet[testIndex])</span><br><span class="line">  <span class="comment">#训练集的数据位置</span></span><br><span class="line">  <span class="keyword">del</span>(trainSet[testIndex])</span><br></pre></td></tr></table></figure><p>（4）根据训练集训练贝叶斯分类器</p><p>1.计算p(c)、p(x,y|c)</p><p>计算p(c)：因为是两个类别，只需要计算p(c)，用1-p(c)可以得出另一个类别出现的概率。p(c)通过对类别标记中1出现的次数求和即为1类别出现的次数，再除以文档总数，即为p(c)</p><p>计算p(x,y|c)：对所有数据进行遍历，分布对0类别和1类别下，所有单词出现的概率进行计算</p><p>注：为防止出现很多很小的数：计算概率时用log，即p(x,y|c)用logp(x,y|c)表示</p><p>为防止各个特征的概率相乘出现0：初始设置p(x,y|c)=1，p(c)=2</p><p>2.训练的结果就是得出训练集下数据属于不同类别的概率</p><p>以两个类别为例，即最终得出在0类别和1类别下所有特征的出现的概率p(x,y|c0)，p(x,y|c1)和0类别、1类别数据出现的概率p(c)，得出这两个概率后，用测试集数据乘以不同类别下的p(ci|x,y)（即用数据 *p(x,y|ci) * p(c)），比较p(x,y|c0)和p(x,y|c1)得出分属的类别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#已求出p0V,p1V,pAuixs</span></span><br><span class="line"><span class="comment">#属于两个类别的概率，进行比较即可</span></span><br><span class="line">p1=sum(inputMatrix*p1V)+log(pAuixs)</span><br><span class="line">p0=sum(inputMatrix*p0V)+log(<span class="number">1</span>-pAuixs)</span><br></pre></td></tr></table></figure><p>（5）在测试集上，使用贝叶斯分类器，分类结果和实际标记对比，得出总体错误率</p><p>1.计算条件概率，即比较两个类别的概率，确定分类的结果</p><p>2.与实际结果比对，分类错误则进行标记</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>广告内容倾向分类</p><p>该案例使用feedparse获取网页的rss源，对网页所有目录的列表读取其中的概要，输入两个网页，根据两个网页中单词出现的概率来进行分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#获得不重复的单词列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line"><span class="comment">#set返回的是不重复的数据</span></span><br><span class="line">vocaList=set([])</span><br><span class="line"><span class="keyword">for</span> dataWord <span class="keyword">in</span> dataSet:</span><br><span class="line">vocaList=vocaList|set(dataWord)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list(vocaList)<span class="comment">#返回列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.0词袋模型，每个词可以出现多次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2Vec</span><span class="params">(vocaList,inputWord)</span>:</span></span><br><span class="line">returnVec=[<span class="number">0</span>]*len(vocaList)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> inputWord:</span><br><span class="line"><span class="keyword">if</span>(word <span class="keyword">in</span> vocaList):</span><br><span class="line">returnVec[vocaList.index(word)]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"the word:"</span>+str(word)+<span class="string">" is not in the vocaList"</span>)</span><br><span class="line"><span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用朴素贝叶斯进行文档分类</span></span><br><span class="line"><span class="comment">#主要是进行概率比较，条件概率定义为p(c|w)=p(w|c)*p(c)/p(w),对所有类别来说，p(w)都是相同的，因此可以不计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCatalog)</span>:</span></span><br><span class="line"><span class="comment">#0.计算不同类别下的文档概率即p(c)</span></span><br><span class="line"><span class="comment">#此处是二值分类，另一个概率可以用1-p(c)来计算</span></span><br><span class="line"><span class="comment">#0.0文档的个数</span></span><br><span class="line">numDocu=len(trainMatrix)</span><br><span class="line"><span class="comment">#0.1侮辱性文档的概率</span></span><br><span class="line"></span><br><span class="line">pAuixs=sum(trainCatalog)/numDocu</span><br><span class="line"><span class="comment">#0.2初始化累加值</span></span><br><span class="line"><span class="comment">#每行词汇的长度</span></span><br><span class="line">numWords=len(trainMatrix[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#因为是独立的概率，如果其中一个为0，整个为0，避免这种情况，初始化为1</span></span><br><span class="line"><span class="comment">#p1num=zeros((numWords))</span></span><br><span class="line"><span class="comment">#p0num=zeros(numWords)</span></span><br><span class="line"><span class="comment">#p1Denom=0</span></span><br><span class="line"><span class="comment">#p0Denom=0</span></span><br><span class="line">p1num=ones((numWords))</span><br><span class="line">p0num=ones(numWords)</span><br><span class="line">p1Denom=<span class="number">2</span></span><br><span class="line">p0Denom=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.按照不同类别计算p(w|c)即计算不同类别下词向量出现的次数</span></span><br><span class="line"><span class="comment">#根据当前类别下每个词出现的次数除以在该类别下所有单词出现的次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(numDocu):</span><br><span class="line"><span class="comment">#1.0 侮辱类别</span></span><br><span class="line"><span class="keyword">if</span>(trainCatalog[i]==<span class="number">1</span>):</span><br><span class="line">p1num+=trainMatrix[i]</span><br><span class="line">p1Denom+=sum(trainMatrix[i])</span><br><span class="line"><span class="comment">#1.1 非侮辱类别</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p0num+=trainMatrix[i]</span><br><span class="line">p0Denom+=sum(trainMatrix[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了避免出现过小的数,出现下溢出，使用log</span></span><br><span class="line">p1Vec=log(p1num/p1Denom)</span><br><span class="line">p0Vec=log(p0num/p0Denom)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p0Vec,p1Vec,pAuixs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#朴素贝叶斯分类器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classfyNB</span><span class="params">(wordVec,p0Vec,p1Vec,pAuixs)</span>:</span></span><br><span class="line"><span class="comment">#比较单词向量乘以p(w|c)*p(c),因为p(w|c)使用了log处理，所以，这边的pauixs也需要加上log,log相加代表相乘</span></span><br><span class="line"><span class="comment">#因为是独立的，所以计算每个单词出现的概率p(wi|c)，因为做了log处理，这里sum等同于去掉log后概率相乘</span></span><br><span class="line">p1=sum(wordVec*p1Vec)+log(pAuixs)</span><br><span class="line">p0=sum(wordVec*p0Vec)+log(<span class="number">1</span>-pAuixs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p1&gt;p0):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试分类器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment">#0.载入实验样本</span></span><br><span class="line">listPosts,listLabels=loadDataSet();</span><br><span class="line"><span class="comment">#1.生成词汇表</span></span><br><span class="line">vocabList=createVocabList(listPosts)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.文本转换为单词向量，方法中是对每行文本进行转换</span></span><br><span class="line">m=len(listPosts)</span><br><span class="line">wordVec=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">wordVec.append(setOfWords2Vec(vocabList,listPosts[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.构造贝叶斯分类器</span></span><br><span class="line">p0Vec,p1Vec,pAuixs=trainNB0(wordVec,listLabels)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.测试数据进行测试</span></span><br><span class="line"><span class="comment">#4.0构造测试数据</span></span><br><span class="line">testList=[<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line"><span class="comment">#4.1转换为单词向量</span></span><br><span class="line">testVec=setOfWords2Vec(vocabList,testList)</span><br><span class="line"><span class="comment">#4.2计算概率</span></span><br><span class="line">testP=classfyNB(testVec,p0Vec,p1Vec,pAuixs)</span><br><span class="line">print(str(testList)+<span class="string">" is:"</span>+str(testP))</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.测试数据进行测试</span></span><br><span class="line"><span class="comment">#4.0构造测试数据</span></span><br><span class="line">testList=[<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line"><span class="comment">#4.1转换为单词向量</span></span><br><span class="line">testVec=setOfWords2Vec(vocabList,testList)</span><br><span class="line"><span class="comment">#4.2计算概率</span></span><br><span class="line">testP=classfyNB(testVec,p0Vec,p1Vec,pAuixs)</span><br><span class="line">print(str(testList)+<span class="string">" is:"</span>+str(testP))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用贝叶斯分类器进行垃圾邮件过滤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件内的文本，对长度小于两个的单词进行过滤</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(file)</span>:</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#0.正则表达式进行分割</span></span><br><span class="line">regex=re.compile(<span class="string">"\\W+"</span>)</span><br><span class="line"><span class="comment">#1.对读入的问津进行分割</span></span><br><span class="line"><span class="comment">#file=file.encode('utf-8')</span></span><br><span class="line"></span><br><span class="line">listTokens=regex.split(file)</span><br><span class="line"><span class="keyword">return</span> [token.lower() <span class="keyword">for</span> token <span class="keyword">in</span> listTokens <span class="keyword">if</span> len(token)&gt;<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用朴素贝叶斯分类器对个人广告区域进行倾向分类</span></span><br><span class="line"><span class="comment">#从rss中获取文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本中出现频率前30的去掉</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcMostFreq</span><span class="params">(vocabList,fullList)</span>:</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="comment">#代表键值对</span></span><br><span class="line">wordFreq=&#123;&#125;</span><br><span class="line"><span class="comment">#对整篇文档计算单词表中单词出现的频率</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> vocabList:</span><br><span class="line">wordFreq[token]=fullList.count(token)</span><br><span class="line"><span class="comment">#按照字典中值进行排序（即出现的次数），以第几个域排序，按照降序排列</span></span><br><span class="line"><span class="comment">#此时变为了列表，可以返回前30个</span></span><br><span class="line">freqList=sorted(wordFreq.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">return</span> freqList[:<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入的参数为：从feedparse中获取的网页的rss源，feed0是0网页，里面的内容标记为0，feed1是1网页，里面的内容标记为1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loacWords</span><span class="params">(feed0,feed1)</span>:</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="comment">#0.获取文本</span></span><br><span class="line">docList=[]</span><br><span class="line">classList=[]</span><br><span class="line">wordList=[]</span><br><span class="line">fullList=[]</span><br><span class="line"><span class="comment">#feed0['entries']是获取所有条目的列表</span></span><br><span class="line">minlen=min(len(feed0[<span class="string">'entries'</span>]),len(feed1[<span class="string">'entries'</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(minlen):</span><br><span class="line"><span class="comment">#对第i个条目的概要提取内容，并进行单词划分</span></span><br><span class="line">wordList=textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">docList.append(wordList)</span><br><span class="line">classList.append(<span class="string">"0"</span>)</span><br><span class="line"><span class="comment">#把所有单词加入到一个列表方便计数</span></span><br><span class="line">fullList.extend(wordList)</span><br><span class="line"></span><br><span class="line">wordList=textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">docList.append(wordList)</span><br><span class="line">classList.append(<span class="string">"1"</span>)</span><br><span class="line"><span class="comment">#把所有单词加入到一个列表方便计数</span></span><br><span class="line">fullList.extend(wordList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.构建词汇表</span></span><br><span class="line">vocabList=createVocabList(docList);</span><br><span class="line"></span><br><span class="line"><span class="comment">##0000.增加的部分，将文本中高频出现的前30个单词从词汇表中去除</span></span><br><span class="line">mostFreq=calcMostFreq(vocabList,fullList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#freq是键值对，[0]第0个代表单词，[1]第一个代表出现的次数</span></span><br><span class="line"><span class="keyword">for</span> freq <span class="keyword">in</span> mostFreq:</span><br><span class="line"><span class="keyword">if</span> freq[<span class="number">0</span>] <span class="keyword">in</span> vocabList:</span><br><span class="line">vocabList.remove(freq[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.文本转换为单词向量</span></span><br><span class="line"><span class="comment">#inputWord=[]</span></span><br><span class="line"><span class="comment">#for i in range(2*minlen):</span></span><br><span class="line"><span class="comment">#inputWord[i]=bagOfWords2Vec(vocabList,docList[i])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.随机选取20个作为测试集</span></span><br><span class="line">trainingSet=list(range(<span class="number">2</span>*minlen))</span><br><span class="line">testingSet=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line"><span class="comment">#生成随机浮点数 random.uniform</span></span><br><span class="line">testIndex=(int)(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">testingSet.append(trainingSet[testIndex])</span><br><span class="line"><span class="keyword">del</span>(trainingSet[testIndex])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串转换为数字</span></span><br><span class="line">classList=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> classList]</span><br><span class="line"><span class="comment">#4.剩余的作为训练集，计算分类器的概率，用于分类</span></span><br><span class="line">traingData=[]</span><br><span class="line">traingLabels=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trainingSet:</span><br><span class="line"><span class="comment">#2.文本转换为单词向量</span></span><br><span class="line">traingData.append(bagOfWords2Vec(vocabList,docList[i]))</span><br><span class="line">traingLabels.append(classList[i])</span><br><span class="line">p0Vec,p1Vec,pAuixs=trainNB0(traingData,traingLabels)</span><br><span class="line"><span class="comment">#5.对测试集进行测试</span></span><br><span class="line">error=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> testingSet:</span><br><span class="line">testingData=bagOfWords2Vec(vocabList,docList[i])</span><br><span class="line">testResult=classfyNB(testingData,p0Vec,p1Vec,pAuixs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(testResult!=classList[i]):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"the error rate is:"</span>+str((float)(error)/<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vocabList,p0Vec,p1Vec</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h2&gt;&lt;p&gt;（1）问题原理：朴素贝叶斯分类的依据是概率，假设需要分为两类c1和c2，则某个数据点属于哪一类，需要计算p(c1|x)和p{c2|x)，即计算数据点x来自c1和来自c2中的概率哪个大，如果p(c1|x)&amp;gt;p{c2|x)，则x被分到c1类别中，反之被分到c2类别中。&lt;/p&gt;&lt;p&gt;（2）计算原理：上述概率属于条件概率，根据公式p(c|x)=p(x|c) * p(c)/ p(x)可以得到，当求（x,y）来自哪个类别时，即用（x,y）替换x，即求p(c|x,y),代入条件概率公式中得，p(c|x,y)=p(x,y|c) * p(c)/p(x,y)，因此问题转换为求p(x,y|c) * p(c)/p(x,y)中三个概率的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="贝叶斯分类" scheme="https://www.xiapf.com/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>监督学习笔记（一）——支持向量机</title>
    <link href="https://www.xiapf.com/blogs/svm/"/>
    <id>https://www.xiapf.com/blogs/svm/</id>
    <published>2020-03-06T08:20:10.000Z</published>
    <updated>2020-03-06T08:30:33.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>（1）支持向量：支持向量机用于解决分类问题，当给出一组线性可分的数据时，此时可以得出一条直线将数据分隔开，要求这条直线即求出了分类的依据，当根据距离分隔线最近的点，取其距离的最大值就能得到最优分割的直线。其中距离分隔线最近的点称为支持向量。</p><p>（2）机：机是指该方法是一个分类器，会产生二值决策机。</p><p>（3）优点：支持向量机方法只使用支持向量，并没有用全部的数据点，所以内存方面优于knn。</p><a id="more"></a><p>（4）缺点：支持向量机一般用于线性可分的数据，当数据线性不可分时无法使用。对于复杂数据需要借助核函数，将复杂数据映射到高维空间进行处理</p><h2 id="求解的理论依据"><a href="#求解的理论依据" class="headerlink" title="求解的理论依据"></a>求解的理论依据</h2><p>（1）确定分隔平面和输出函数</p><p>分隔平面：wT*x+b，其中w和b描述了所给数据的分隔平面</p><p>因为是二值分类器，输出值是-1和+1，所以使用signmoid函数，当点到直线的距离f(wT*x+b)&gt;0时属于 +1类，反之属于-1类。</p><p>（2）求距离：</p><p>数据点到分隔平面的距离记为<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150346.png" alt="点到平面的几何距离"></p><p>要求得最佳分隔平面就要找到距离平面最佳的点的距离将其最大化，则为最佳分类，所以即求<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150600.png" alt="求解目标"></p><p>但是该目标函数求解困难，因此使用拉格朗日乘子法进行转换带约束调节的目标函数：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150813.png" alt="转换函数"></p><p>其中约束条件为：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件"></p><p>因为实际数据不可能存在100%线性可分所以此时加上一个松弛变量，可以允许一些点在分隔平面的另一边，此时前一个约束条件变为0&lt;=alpha&lt;=C，这里的常数C确保点距离平面的最大间隔和所有数据点的函数间隔小于1.0（因为是支持向量）</p><p>（3）问题转换</p><p>根据（2）中转换后的目标函数和约束条件可以看出，SVM（支持向量机，以下均简称为SVM）的主要求解目标转换为求alpha的值，通过alpha可以表示分隔平面。</p><h2 id="使用的算法"><a href="#使用的算法" class="headerlink" title="使用的算法"></a>使用的算法</h2><p>由求解的理论依据中可知，SVM需要求解的目标为带有约束条件的函数，一般采用二次规划求解方法，但是计算复杂，这里使用platt SMO算法求解。</p><p>（1）算法思路：每次选择一对alpha进行优化，当找到合适的两个alpha后，需要增大一个减小另一个，因为需要满足约束条件：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件">，合适是指两个alpha值要在间隔边界之外，同时没有被区间化处理或者不在边界上</p><p>（2）基本算法流程：以简单smo算法为例</p><blockquote><p>#0.初始化alpha向量为0</p><p>#1.当迭代次数小于最大迭代次数（外循环）<br>    #2.对数据集中每个向量（内循环）<br>        #3.如果该向量可以被优化<br>            #4.随机找另一个向量<br>            #5.优化这两个向量<br>            #6.如果这两个向量不能被优化，跳出内循环</p><p>#7.如果所有向量都不能被优化，增加迭代次数，进行下一次的循环</p></blockquote><p>（3）完整platt smo 算法</p><p>platt smo算法在简化smo算法基础上提升时间，对数据量大的数据集执行时间大大减少。</p><p>相比于传统的二次规划求解方法，每次选取两个alpha进行优化，时间效率大幅提高。</p><p>算法流程：</p><blockquote><p>#外循环 使用两种方式交替得到第一个alpha的值</p><p>#1.0 对所有数据点进行遍历扫描</p><p>#2.0 对非边界值即0&lt;alpha并且alpha&gt;c的alpha进行扫描</p><p>#内循环 采用最大化步长的方式得到第二个alpha的值</p></blockquote><h2 id="核函数的引入"><a href="#核函数的引入" class="headerlink" title="核函数的引入"></a>核函数的引入</h2><p>当面对非线性数据的时候，需要使用核函数，将复杂数据映射到高维空间，此时分类器易于理解，即可使用SVM方法。</p><p>主要使用径向基函数的高斯版本：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306155004.png" alt="径向基函数"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X,A,kTup=<span class="params">()</span>)</span>:</span></span><br><span class="line">  m=shape(X)[<span class="number">0</span>]</span><br><span class="line">  K=zeros((m,<span class="number">1</span>))</span><br><span class="line">  <span class="comment">#对核函数的第一个参数进行不同情况的讨论</span></span><br><span class="line">  <span class="comment">#1.线性核</span></span><br><span class="line">  <span class="keyword">if</span>(kTup[<span class="number">0</span>]=<span class="string">"lin"</span>):</span><br><span class="line">    K=X*A.T</span><br><span class="line">  <span class="comment">#2.径向基核</span></span><br><span class="line">  <span class="keyword">elif</span>(kTup[<span class="number">0</span>]=<span class="string">"rbf"</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">      delta=X[i,:]-A</span><br><span class="line">      K[i]=delta*delta.T</span><br><span class="line">     K=exp(K/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))      </span><br><span class="line">  <span class="comment">#3.抛出异常</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError()</span><br><span class="line">  <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="应用实例——手写数字识别"><a href="#应用实例——手写数字识别" class="headerlink" title="应用实例——手写数字识别"></a>应用实例——手写数字识别</h2><p>识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</p><p>（1）将图像转换为向量</p><p>（2）读取文件夹列表中各个图像文件</p><p>（3）处理分类问题</p><p>为方便处理，只保留了1和9两个数字，当是数字1时，分类为+1，当是数字9时分类为-1</p><blockquote><p>#1.读入图像转换后的数据向量和标签属性</p><p>#2.调用platt smo算法得出alpha和b的值</p><p>#3.根据支持向量大于0的特性得出其中alpha&gt;0的支持向量，并得出支持向量的数据点和标签数据</p><p>#4.在训练集上得出分类结果</p><p>#5.将分类的结果应用于测试集</p></blockquote><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#plat smo可以处理数据量大的，上面simplesmo只能处理数据量较小的数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#platsmo的支持函数</span></span><br><span class="line"><span class="comment">#建立一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line"><span class="comment">#各种变量初始化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMat,lableMat,C,toler,kTup)</span>:</span><span class="comment">#增加核函数初始化参数</span></span><br><span class="line">self.dataMat=dataMat</span><br><span class="line">self.lableMat=lableMat</span><br><span class="line">self.C=C</span><br><span class="line">self.toler=toler</span><br><span class="line">self.m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">self.alpha=mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">self.b=<span class="number">0</span></span><br><span class="line">self.echache=mat(zeros((self.m,<span class="number">2</span>)))<span class="comment">#第一列表示cache是否有效，第二列是实际的E（误差）值</span></span><br><span class="line"><span class="comment">#构建k</span></span><br><span class="line">self.k=mat(zeros((self.m,self.m)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line"><span class="comment">#调用函数，填充k</span></span><br><span class="line">self.k[:,i]=kernelTras(self.dataMat,self.dataMat[i,:],kTup)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存误差缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEK</span><span class="params">(oS,ke)</span>:</span></span><br><span class="line">fk=float(multiply(oS.alpha,oS.lableMat).T*oS.k[:,ke]+oS.b)</span><br><span class="line">EK=fk-float(oS.lableMat[ke])</span><br><span class="line"><span class="keyword">return</span> EK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算误差，并且存入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEK</span><span class="params">(oS,k)</span>:</span></span><br><span class="line">EK=calcEK(oS,k)</span><br><span class="line">oS.echache[k]=[<span class="number">1</span>,EK]</span><br><span class="line"></span><br><span class="line"><span class="comment">#内循环中的启发方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择第二个alpha值，保证每次优化都是最大的步长，如果是第一次进入循环就先随机选择一个alpha[j],反之进入循环，根据最大步长选择alpha[j]的值</span></span><br><span class="line"><span class="comment">#alphaj的值和前一个alphai的下标和误差Ei有关</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i,oS,Ei)</span>:</span></span><br><span class="line">maxk=<span class="number">-1</span></span><br><span class="line">maxDeltaE=<span class="number">0</span></span><br><span class="line">Ej=<span class="number">0</span></span><br><span class="line">oS.echache[i]=[<span class="number">1</span>,Ei]</span><br><span class="line"><span class="comment">#输入列表为目标的列表值，nozero返回不为空的值即非零alpha值</span></span><br><span class="line">validDeltaList=nonzero(oS.echache[:,<span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> (len(validDeltaList))&gt;<span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> validDeltaList:</span><br><span class="line"><span class="keyword">if</span>(k==i):</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">Ek=calcEK(oS,k)</span><br><span class="line">delta=abs(Ek-Ei)</span><br><span class="line"><span class="keyword">if</span>(delta&gt;maxDeltaE):</span><br><span class="line">maxk=k</span><br><span class="line">maxDeltaE=delta</span><br><span class="line">Ej=Ek</span><br><span class="line"><span class="keyword">return</span> maxk,Ej</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">j=selectRandom(i,oS.m)</span><br><span class="line">Ej=calcEK(oS,j)</span><br><span class="line"><span class="keyword">return</span> j,Ej</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerI</span><span class="params">(oS,i)</span>:</span></span><br><span class="line">exi=calcEK(oS,i)</span><br><span class="line"><span class="keyword">if</span> ((oS.lableMat[i]*exi&lt;-oS.toler) <span class="keyword">and</span> (oS.alpha[i]&lt;oS.C)) <span class="keyword">or</span> ((oS.lableMat[i]*exi&gt;oS.toler) <span class="keyword">and</span> (oS.alpha[i]&gt;<span class="number">0</span>)):</span><br><span class="line"><span class="comment">#1.3启发式找另一个向量</span></span><br><span class="line">j,exj=selectJ(i,oS,exi)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.4优化这两个向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#记录旧的，看优化之后有无变换</span></span><br><span class="line">alphaJold=oS.alpha[j].copy()</span><br><span class="line">alphaIold=oS.alpha[i].copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(oS.lableMat[i]!=oS.lableMat[j]):</span><br><span class="line">L=max(<span class="number">0</span>,oS.alpha[j]-oS.alpha[i])</span><br><span class="line">H=min(oS.C,oS.C+oS.alpha[j]-oS.alpha[i])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">L=max(<span class="number">0</span>,oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line">H=min(oS.C,oS.C+oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L==H):</span><br><span class="line">print(<span class="string">"L==H"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最优修改量</span></span><br><span class="line"><span class="comment">#eta=2.0*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#使用核函数之后，修正eta的值</span></span><br><span class="line">eta=<span class="number">2.0</span>*oS.k[i,j]-oS.k[i,i]-oS.k[j,j]</span><br><span class="line"><span class="keyword">if</span>(eta&gt;=<span class="number">0</span>):</span><br><span class="line">print(<span class="string">"eta&gt;=0"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">oS.alpha[j]-=oS.lableMat[j]*(exi-exj)/eta</span><br><span class="line">oS.alpha[j]=adjustBig(oS.alpha[j],H,L)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将j的更新存到缓存</span></span><br><span class="line">updateEK(oS,j)</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化j之后无变换</span></span><br><span class="line"><span class="keyword">if</span> abs(alphaJold-oS.alpha[j])&lt;<span class="number">0.00001</span>:</span><br><span class="line">print(<span class="string">"alphaJold-alpha[j])&lt;0.00001"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#优化j有变化，接着优化i</span></span><br><span class="line">oS.alpha[i]+=oS.lableMat[j]*oS.lableMat[i]*(alphaJold-oS.alpha[j])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将i的更新存到缓存</span></span><br><span class="line">updateEK(oS,i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置偏置量</span></span><br><span class="line"><span class="comment">#b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[i,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line"><span class="comment">#使用核函数之后，修正b1,b2的值</span></span><br><span class="line">b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,i]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[i,j]</span><br><span class="line">b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,j]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[j,j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> oS.alpha[i]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[i]&lt;oS.C:</span><br><span class="line">oS.b=b1</span><br><span class="line"><span class="keyword">elif</span> oS.alpha[j]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[j]&lt;oS.C:</span><br><span class="line">oS.b=b2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">oS.b=(b1+b2)/<span class="number">2.0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#完整的platt smo 外循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn,labelArr,C,toler,maxIter,kTup=<span class="params">(<span class="string">"lin"</span>,<span class="number">0</span>)</span>)</span>:</span></span><br><span class="line"><span class="comment">#0.相关变量初始化</span></span><br><span class="line">oS=optStruct(mat(dataMatIn),mat(labelArr).transpose(),C,toler,kTup)</span><br><span class="line"></span><br><span class="line">entireSet=<span class="literal">True</span></span><br><span class="line">alphaChange=<span class="number">0</span></span><br><span class="line">iter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.主循环</span></span><br><span class="line"><span class="keyword">while</span> (iter&lt;maxIter) <span class="keyword">and</span> ((alphaChange&gt;<span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">alphaChange=<span class="number">0</span></span><br><span class="line"><span class="comment">#1.选择第一个alpha的两种循环</span></span><br><span class="line"><span class="comment">#1.0对所有数据集进行遍历</span></span><br><span class="line"><span class="keyword">if</span>(entireSet):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):</span><br><span class="line">alphaChange+=innerI(oS,i)</span><br><span class="line">print(<span class="string">"fullset: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line">iter+=<span class="number">1</span></span><br><span class="line"><span class="comment">#1.1对非边界值进行遍历</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nonBoundIs=nonzero((oS.alpha.A&gt;<span class="number">0</span>)*(oS.alpha.A&lt;C))[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">alphaChange+=innerI(oS,i)</span><br><span class="line">print(<span class="string">"nonbound: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line"></span><br><span class="line">iter+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(entireSet):</span><br><span class="line">entireSet=<span class="literal">False</span></span><br><span class="line"><span class="keyword">elif</span>(alphaChange==<span class="number">0</span>):</span><br><span class="line">entireSet=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oS.alpha,oS.b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用求得的alpha值求得分类的超平面，其中可以求出w的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcW</span><span class="params">(alpha,dataMatIn,labelArr)</span>:</span></span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m,n=shape(dataMat)</span><br><span class="line">w=zeros((n,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"><span class="comment">#其中起作用的只有支持向量，即不为0的alpha</span></span><br><span class="line">w+=multiply((alpha[i]*lableMat[i]),dataMat[i,:].T)</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在复杂数据上使用核函数</span></span><br><span class="line"><span class="comment">#将数据从一个特征空间映射到另一个空间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTras</span><span class="params">(X,A,kTup)</span>:</span></span><br><span class="line">m,n=shape(X)</span><br><span class="line">k=zeros((m,<span class="number">1</span>))</span><br><span class="line"><span class="comment">#根据ktup的第一个参数来求核函数的值</span></span><br><span class="line"><span class="keyword">if</span>(kTup[<span class="number">0</span>]==<span class="string">"lin"</span>):</span><br><span class="line">k=X*A.T</span><br><span class="line"><span class="keyword">elif</span>(kTup[<span class="number">0</span>]==<span class="string">"rbf"</span>):</span><br><span class="line"><span class="comment">#对每个元素计算高斯值</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">deltaRow=X[j,:]-A</span><br><span class="line">k[j]=deltaRow*deltaRow.T</span><br><span class="line">k=exp(k/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))</span><br><span class="line"><span class="comment">#若元祖无法识别，则抛出异常</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">raise</span> NameError(<span class="string">"the keneral name wrong"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="comment">#识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.将图像转换为向量——将32*32的图像转换为1*1024的向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line"><span class="comment">#0.构造转换后返回的向量</span></span><br><span class="line">returnVect=zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line"><span class="comment">#1.处理图像</span></span><br><span class="line">fr=open(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32行的</span></span><br><span class="line">lineArr=fr.readline() <span class="comment">#每次读入一行</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32列的</span></span><br><span class="line">returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j]=int(lineArr[j])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.从文件夹中读入所有图片信息并存储为向量和标签——,为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImage</span><span class="params">(dirname)</span>:</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"><span class="comment">#0.用于存储标签</span></span><br><span class="line">hwLabels=[]</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.用于存储数据向量</span></span><br><span class="line"><span class="comment">#得到文件夹下图像名称的列表 例：1_20.txt</span></span><br><span class="line">trainDirList=listdir(dirname)</span><br><span class="line">m=len(trainDirList)</span><br><span class="line"><span class="comment">#用于存储数据向量</span></span><br><span class="line">trainMat=zeros((m,<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.处理图像文件中的内容</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line"><span class="comment">#图像文件完整名称</span></span><br><span class="line">fullName=trainDirList[i]</span><br><span class="line"><span class="comment">#图像文件去除后缀后的名称</span></span><br><span class="line">fileName=fullName.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#图像文件去除下划线后的名称</span></span><br><span class="line">className=int(fileName.split(<span class="string">"_"</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line"><span class="keyword">if</span>(className==<span class="number">1</span>):</span><br><span class="line">hwLabels.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">hwLabels.append(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#将图像文件中的内容转换为向量进行存储</span></span><br><span class="line">trainMat[i,:]=img2vector(<span class="string">"%s/%s"</span>%(dirname,fullName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> trainMat,hwLabels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.使用核函数进行分类测试的径向基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup=<span class="params">(<span class="string">"rbf"</span>,<span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">dataMatIn,labelArr=loadImage(<span class="string">"trainingDigits"</span>)</span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m,n=shape(dataMat)</span><br><span class="line"><span class="comment">#根据platt smo算法得到alpha,b的值</span></span><br><span class="line">alpha,b=smoP(dataMatIn,labelArr,<span class="number">200</span>,<span class="number">0.0001</span>,<span class="number">10000</span>,kTup)</span><br><span class="line">print(alpha[alpha&gt;<span class="number">0</span>])</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#得到支持向量</span></span><br><span class="line">sVInd=nonzero(alpha.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">sVs=dataMat[sVInd]</span><br><span class="line">sVlabel=lableMat[sVInd]</span><br><span class="line">print(<span class="string">"tere are "</span>+str(shape(sVs)[<span class="number">0</span>])+<span class="string">" support vectors"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在训练集上使用核函数</span></span><br><span class="line">error=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line"><span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"train error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">#在测试集上使用核函数</span></span><br><span class="line">dataMatIn,labelArr=loadImage(<span class="string">"testDigits"</span>)</span><br><span class="line">dataMat=mat(dataMatIn)</span><br><span class="line">lableMat=mat(labelArr).transpose()</span><br><span class="line">m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">error=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line"><span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">error+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"test error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;p&gt;（1）支持向量：支持向量机用于解决分类问题，当给出一组线性可分的数据时，此时可以得出一条直线将数据分隔开，要求这条直线即求出了分类的依据，当根据距离分隔线最近的点，取其距离的最大值就能得到最优分割的直线。其中距离分隔线最近的点称为支持向量。&lt;/p&gt;&lt;p&gt;（2）机：机是指该方法是一个分类器，会产生二值决策机。&lt;/p&gt;&lt;p&gt;（3）优点：支持向量机方法只使用支持向量，并没有用全部的数据点，所以内存方面优于knn。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="支持向量机" scheme="https://www.xiapf.com/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（四）</title>
    <link href="https://www.xiapf.com/blogs/movStateNote/"/>
    <id>https://www.xiapf.com/blogs/movStateNote/</id>
    <published>2020-03-05T03:22:57.000Z</published>
    <updated>2020-03-05T03:27:13.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>（1）明确状态含义</p><p>首先要明确dp[i]的含义，例如在求分割回文字符串的次数中，dp[i]表示i个回文字符串的分割次数</p><p>（2）确定初始状态</p><p>可以考虑最多…的时候dp的状态</p><p>例如求分割回文字符串的次数，初始状态即为i个字符串最多分割i次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求分割回文字符串的次数</span></span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  dp[i]=i;</span><br><span class="line"><span class="comment">//i个字符串，最多分割i次</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>（3）确定状态转移方程</p><p>假设已知dp[i]的状态，列出dp[i+1]和dp[i]之间的关系式，即为状态转移方程</p><p>明确目标：要求dp{i]的值</p><p>例如求分割回文字符串的次数，其中状态转移方程如下：</p><p>当i从1变化到len之间，求dp[i]。当0~i本身是回文时，不需要分割，即dp[i]=0。该题dp[i+1]和dp[i]之间没有明确联系，可以从分割边界考虑。假设分割边界为j，已知dp[j]，求dp[i]，就需要分两种情况考虑</p><p>a）j+1~i之间是回文，那么dp[j]再分割一次就可以得到j之前的字符串和后面的回文，即dp[i]=dp[j]+1，但dp[i]有可能更小，所以dp[i]在dp[i]和dp[j]+1之间取小的</p><p>b）j+1~i之间不是回文，继续移动j，找到符合回文的子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>~i是回文)</span><br><span class="line">    dp[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>~i是回文)</span><br><span class="line">      dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）最终输出</p><p>一般输出为dp[len-1]，例如在求分割回文字符串的次数中，最终是求len个字符串的分割次数，即求dp[len-1]</p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p>（1）明确状态含义</p><p>股票有三种状态：买入，卖出，休息（不买入也不卖出）    最终状态为持有股票设置为0，不持有股票1</p><p>转换关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200304222109.png" alt="stock"></p><p>设置dp[i] [k] [s]表示第天股票的持有情况，k表示至今最多进行k笔交易，整个数组表示可以得到的最大利润</p><p>（2）确定状态转移方程</p><p>转换关系中就两种状态，因此分别考虑两种情况下的转移方程：</p><p>a）今天持有股票，即求dp[i] [k] [1]</p><p>持有股票有两种情况，一种是前一天本来就有股票，并且今天休息，即dp[i-1] [k] [1]；另一种是前一天没有股票，今天购入了，此时前一天进行了k-1笔交易，买入股票，说明利润减少，需要减掉买入的价格,即dp[i-1] [k-1] [0]-price[i]</p><p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i])</p><p>b）今天不持有股票，即求dp[i] [k] [0]</p><p>不持有股票也有两种情况，一种是前一天本来就没有股票，并且今天休息，即dp[i-1] [k] [0]；另一种是前一天有股票，今天卖出了，卖出股票，说明利润增加，需要加上卖出的价格,即dp[i-1] [k] [1]+price[i]</p><p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [0]=max(dp[i-1] [k] [0]]，dp[i-1] [k] [1]+price[i])</p><p>综合a和b，可以得出状态转移方程</p><p>（3）确定初始状态</p><p>因为状态转移方程中只有两个最终状态，所以对两个最终状态的初始情况进行讨论：</p><p>a）刚开始没有持有股票时，没有利润，即dp[0] [0]=0</p><p>b）刚开四持有股票，之前没有利润，亏损买入的价格，即dp[0] [1]=-price[0]</p><p>（4）最终输出</p><p>最后一天利润是最大的，此时不持有股票的利润肯定大于持有的，即dp[len-1] [k] [0]&gt;dp[len-1] [k] [1]，所以选择dp[len-1] [k] [1]</p><p>（5）实际应用</p><p>a）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p><p>此时k=1，代入方程得</p><p>dp[i] [1] [1]=max(dp[i-1] [1] [1]，dp[i-1] [0] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p><p>dp[i] [1] [0]=max(dp[i-1] [1] [0]，dp[i-1] [1] [1]+price[i])</p><p>可以看出，方程中k=1对转换无影响，所以省去k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此时k=无穷，那么k的值和k-1的值近似一样，因此k同样可以省略，此时的方程为</p><p>dp[i] [1]=max(dp[i-1] [1]，dp[i-1] [0]-price[i]) 其中dp[i-1] [0]不可以省略，因为其值已经不等于0</p><p>dp[i] [0]=max(dp[i-1] [0]，dp[i-1]  [1]+price[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，dp[i<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c）给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>此时k从1变换到2，不为0是因为要有利润至少会有一笔交易，此时代码中将多一重循环</p><p>dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p><p>dp[i] [k] [0]=max(dp[i-1] [k] [0]，dp[i-1] [k] [1]+price[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//定义初始状态</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//刚开始时，不持有股票，利润为0</span></span><br><span class="line">      dp[i][k][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//刚开始时，持有股票，利润为亏损买入对应的股票</span></span><br><span class="line">      dp[i][k][<span class="number">1</span>]=-price[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][k][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">1</span>]，dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">    dp[i][k][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">0</span>]，dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+price[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;h3 id=&quot;一般思路&quot;&gt;&lt;a href=&quot;#一般思路&quot; class=&quot;headerlink&quot; title=&quot;一般思路&quot;&gt;&lt;/a&gt;一般思路&lt;/h3&gt;&lt;p&gt;（1）明确状态含义&lt;/p&gt;&lt;p&gt;首先要明确dp[i]的含义，例如在求分割回文字符串的次数中，dp[i]表示i个回文字符串的分割次数&lt;/p&gt;&lt;p&gt;（2）确定初始状态&lt;/p&gt;&lt;p&gt;可以考虑最多…的时候dp的状态&lt;/p&gt;&lt;p&gt;例如求分割回文字符串的次数，初始状态即为i个字符串最多分割i次&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//求分割回文字符串的次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;len;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dp[i]=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//i个字符串，最多分割i次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.xiapf.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>mac下搭建和使用mve</title>
    <link href="https://www.xiapf.com/blogs/useMVE/"/>
    <id>https://www.xiapf.com/blogs/useMVE/</id>
    <published>2020-03-04T03:47:55.000Z</published>
    <updated>2020-03-06T08:31:26.870Z</updated>
    
    <content type="html"><![CDATA[<p>mve可以将多角度的图片序列重构成三维点云</p><h2 id="搭建mve"><a href="#搭建mve" class="headerlink" title="搭建mve"></a>搭建mve</h2><p>搭建过程参照官方文档<a href="https://github.com/simonfuhrmann/mve" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/simonfuhrmann/mve</a></p><p>以下均在终端进行操作</p><p>1.从github上下载代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/simonfuhrmann/mve.git</span><br></pre></td></tr></table></figure><p>下载之后会在根目录建立mve文件夹</p><a id="more"></a><p>2.进入mve文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd mve</span><br></pre></td></tr></table></figure><p>进行编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>3.添加依赖库</p><p>编译过程中报错，是因为缺少依赖库，需要手动安装。主要是对图片处理的函数库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install libjpeg</span><br><span class="line">brew install libpng</span><br><span class="line">brew install libtiff</span><br></pre></td></tr></table></figure><p>此时就能成功编译，打开mve下的apps文件夹，当所有的文件夹下生成了”.o”后缀的文件，说明环境已经搭建好。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.在官网下载数据集</p><p><a href="http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/" target="_blank" rel="external nofollow noopener noreferrer">http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/</a></p><p>我选择的是der_hass-20140923数据集，里面包含雕像不同角度的79张图像，下载后进行解压</p><p>2.设置环境变量</p><p>生成点云过程中是使用apps下中的子文件夹实现，所以需要设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#进入根目录</span><br><span class="line">cd ~</span><br><span class="line">#给任意一个文件添加环境变量</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>输入vim命令后，进入输入环境变量页面，输入“O”，进入写模式，将apps下所有文件夹路径加入环境变量中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/Users/mve/apps/bundle2pset:$PATH</span><br><span class="line">#以下省略</span><br></pre></td></tr></table></figure><p>输入结束后，按esc，在文末输入”:wq”，退出并保存环境变量</p><p>生效环境变量，将环境变量应用到下载好的数据集下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 数据集路径名称</span><br></pre></td></tr></table></figure><p>查看环境变量是否生效，在数据集文件夹下打开终端，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>当环境变量中包含了apps下文件夹的路径，说明环境变量设置成功</p><p>3.重建三维生成点云</p><p>der_hass-20140923是下载的数据集，der_hass是生成数据所在的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makescene -i der_hass-20140923 der_hass</span><br></pre></td></tr></table></figure><p>按以下命令一个个运行，der_hass是生成的散文图所在的文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sfmrecon der_hass</span><br><span class="line">dmrecon -s2 der_hass</span><br><span class="line">scene2pset -F2 der_hass der_hass/pset-L2.ply</span><br><span class="line">fssrecon der_hass/pset-L2.ply der_hass/surface-L2.ply</span><br><span class="line">meshclean -t10 der_hass/surface-L2.ply der_hass/surface-L2-clean.ply</span><br></pre></td></tr></table></figure><p>运行过程比较慢，需要耐心等待，大约需3小时左右，最终生成的点云文件为surface-L2-clean.ply</p><p>4.效果展示</p><p>使用meshlab打开点云文件，效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200120193729.png" alt="效果图"></p><p>可以看出生成的点云完整，不存在不连续的部分，实现了从图像-&gt;稀疏点云-&gt;稠密点云-&gt;点云表面重建的全过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mve可以将多角度的图片序列重构成三维点云&lt;/p&gt;&lt;h2 id=&quot;搭建mve&quot;&gt;&lt;a href=&quot;#搭建mve&quot; class=&quot;headerlink&quot; title=&quot;搭建mve&quot;&gt;&lt;/a&gt;搭建mve&lt;/h2&gt;&lt;p&gt;搭建过程参照官方文档&lt;a href=&quot;https://github.com/simonfuhrmann/mve&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;https://github.com/simonfuhrmann/mve&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以下均在终端进行操作&lt;/p&gt;&lt;p&gt;1.从github上下载代码&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/simonfuhrmann/mve.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;下载之后会在根目录建立mve文件夹&lt;/p&gt;
    
    </summary>
    
    
      <category term="点云" scheme="https://www.xiapf.com/categories/%E7%82%B9%E4%BA%91/"/>
    
    
      <category term="mve" scheme="https://www.xiapf.com/tags/mve/"/>
    
      <category term="点云" scheme="https://www.xiapf.com/tags/%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（三）</title>
    <link href="https://www.xiapf.com/blogs/listbNote/"/>
    <id>https://www.xiapf.com/blogs/listbNote/</id>
    <published>2020-03-03T07:18:41.000Z</published>
    <updated>2020-03-03T07:20:20.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于链表的算法"><a href="#关于链表的算法" class="headerlink" title="关于链表的算法"></a>关于链表的算法</h2><p>链表节点的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表常用算法思想包括：快慢指针（对空间复杂度有要求，可以考虑使用快慢指针）</p><a id="more"></a><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>新建两个指针，快指针走两步，慢指针走一步</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针法只使用两个指针，空间复杂度很小，只有O(1)</span></span><br><span class="line">ListNode* fast=head;<span class="comment">//快指针</span></span><br><span class="line">ListNode* slow=head;<span class="comment">//慢指针</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//慢指针走一步</span></span><br><span class="line">  slow=slow-&gt;next;</span><br><span class="line">  <span class="comment">//快指针走两步</span></span><br><span class="line">  fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>环形链表（判断链表中是否存在环）：</p><p>（1）判断有无环：可以利用快慢指针，如果存在环，那么在某一个链表节点快指针指向的节点就等于慢指针指向的节点（是节点整体相等，包括val和next，不能只用val判断），反之，则不存在环，整体问题抽象成追赶问题，因为存在环，所以一定能追赶上。</p><p>（2）求环的入口节点：当需要求环形入口节点的时候，首先将判断有无环，在相遇的时候break，此时假设链表中无环部分长度为a，环长度b，相遇时快指针比慢指针走了n个环长度，f=s+nb，又因为f=2s，所以s=nb，慢指针要走到环入口，需要长度为a+nb，所以慢指针需要再走a个长度，此时将fast设置为head，从head走到环入口长度正好为a，当两个指针指向相同链节点的时候，就到达了环的入口</p><h2 id="关于括号的算法"><a href="#关于括号的算法" class="headerlink" title="关于括号的算法"></a>关于括号的算法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">//用map存储括号的键值对</span></span><br><span class="line">unorder_map&lt;<span class="keyword">char</span>&gt; <span class="built_in">map</span>&#123;&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,&#123;&#125;&#125;;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//用栈存储读入的字符</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span>(字符串不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(当字符是左半边括号时)</span><br><span class="line">    左括号入栈；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    [</span><br><span class="line">    <span class="comment">//取栈顶元素</span></span><br><span class="line">    q=s.top();</span><br><span class="line">    <span class="keyword">if</span>(栈顶元素==<span class="built_in">map</span>[q])</span><br><span class="line">      出栈</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      未能匹配上</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//先出栈，当出栈后栈为空，说明当前右括号前面没有匹配的左括号，此时右括号入栈作为一个位置标记，计算后面的长度，如果在else里出栈，那么会面临出栈后，s.top()不存在的现象</span></span><br><span class="line">      s.pop();</span><br><span class="line">      <span class="comment">//栈为空，存入当前括号</span></span><br><span class="line">      <span class="keyword">if</span>(s.empty())</span><br><span class="line">      s.push(i)</span><br><span class="line">      <span class="comment">//栈不为空，获得长度</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        length=<span class="built_in">max</span>(length,i-s.top())</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>有效的括号（给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。）：在map中存储括号的键值对，利用map[值]=键，每次读入字符串的字符时，如果是左边括号就入栈，否则就是右边括号，需要进行检测是否配对，取这时栈顶的括号，如果键值对匹配上，则出栈，检测下一个，否则是没有匹配上。</p><p>最长有效括号（给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。）：</p><p>（1）初始化：用栈来存储括号，栈里保存括号位置的下标，为了保证获取长度，初始化栈为-1。</p><p>（2）当扫描到左括号的时候，入栈，当扫描到右括号的时候，此时将栈顶元素出栈，分为两种情况，一种是当栈为空的时候，说明之前没有匹配的左括号，把当前括号入栈，另一种栈不为空，说明有匹配的左括号，用当前位置减去栈顶的位置，并更新长度</p><h3 id="深度遍历-剪枝"><a href="#深度遍历-剪枝" class="headerlink" title="深度遍历+剪枝"></a>深度遍历+剪枝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入参数为当前由括号组成的路径，左子树括号的个数，右子树括号的个数，以及最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt;&gt; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件,此时出现了一条满足条件的路径:左右子树的括号个数都为0</span></span><br><span class="line">  <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">    res.push(str)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//剪枝：左子树的括号个数大于右子树的括号个数,出现不匹配</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//左边括号多，先生成左括号</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'('</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">  <span class="comment">//右边括号多，再生成右括号</span></span><br><span class="line">  <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'）'</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>括号的生成（给出 n 代表生成括号的对数，写出一个函数，使其能够生成所有可能的并且有效的括号组合）：实质是对括号做减法，当左括号数量大于0，就不断生成左括号，右括号数量大于0，生成右括号，但是存在不满足括号匹配的条件，当左括号数量大于右括号，此时需要剪枝（加一个判断条件，return）,当左右括号数量都为0，说明找到了一个合适的路径，将其存储下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于链表的算法&quot;&gt;&lt;a href=&quot;#关于链表的算法&quot; class=&quot;headerlink&quot; title=&quot;关于链表的算法&quot;&gt;&lt;/a&gt;关于链表的算法&lt;/h2&gt;&lt;p&gt;链表节点的定义&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ListNode* next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x):val(x),next(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;链表常用算法思想包括：快慢指针（对空间复杂度有要求，可以考虑使用快慢指针）&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="https://www.xiapf.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="括号" scheme="https://www.xiapf.com/tags/%E6%8B%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（二）</title>
    <link href="https://www.xiapf.com/blogs/backTrackNote/"/>
    <id>https://www.xiapf.com/blogs/backTrackNote/</id>
    <published>2020-02-25T07:08:13.000Z</published>
    <updated>2020-03-04T04:56:30.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯一般用于找到满足要求的的所有解，即相当于构造一棵树，从跟节点出发，找到满足条件的所有路径，并进行保存，当目前的路径不符合条件的时候，需要回溯，即剪枝，删除不符合的分支，当到达结束的条件时，即找到了一个满足条件的解，再继续构造下一个符合条件的路径。</p><p>常用于解决树种求得所有解的问题和排列组合中求解问题，或者问题可以转换为求树中一条路径的问题，可以画图。</p><a id="more"></a><h3 id="关于树的回溯"><a href="#关于树的回溯" class="headerlink" title="关于树的回溯"></a>关于树的回溯</h3><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//result存储最终结果，res存储中间结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt; result,<span class="built_in">vector</span> res，….)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//处理当前节点</span></span><br><span class="line">   res.push(root-&gt;val)</span><br><span class="line"></span><br><span class="line">   …</span><br><span class="line"></span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（一般是值相等）并且到达根节点)</span><br><span class="line">  result.push(res)</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;left,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;right,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>找到所有满足目标节点的路径：每次把当前节点加入，并将目标值减去当前节点的值，判断当前叶子节点值（左右子树为空）与0是否相等，相等，则找到一个满足的结果，否则，继续对左右子树递归，此时若存在不满足条件的，需要回溯（pop）</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合求所有符合问题的解，基本框架：</p><p>组合问题按顺序读取，不需要设置used数组，排列问题则需要设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件：找到满足要求的一个解</span></span><br><span class="line">  <span class="keyword">if</span>(满足值为<span class="number">0</span>或者其他条件)</span><br><span class="line">  &#123;</span><br><span class="line">    result.push(res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;数组长度&amp;&amp;target-num[i]&gt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//避免重复元素得出重复组合</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;start&amp;&amp;num[i]==num[i<span class="number">-1</span>])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//全排列中不能使用上一层使用的元素</span></span><br><span class="line">      <span class="comment">//设置标志位或者其他判断条件</span></span><br><span class="line">      <span class="keyword">if</span>(!use[i])&#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//当时排列问题，并且有重复数字的时候，需要将上面两个条件结合</span></span><br><span class="line">    <span class="comment">//选择当前节点</span></span><br><span class="line">    res.push(num[i]);</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//选择了该节点，需要设置标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//[可以重复使用]</span></span><br><span class="line">    dfs(i,target-num[i]);</span><br><span class="line">    [<span class="comment">//不可以重复使用</span></span><br><span class="line">    [dfs(i+<span class="number">1</span>,target-num[i]);</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//回溯，取消当前选择，返回上一层</span></span><br><span class="line">    res.pop();</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//撤销选择，需要还原标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 应用场景：</p><p>组合求和（数组元素内部不重复，在数组中找到和为目标值的组合）：首先对数组排序，排序能更方便去重。在dfs函数中，每次传入数组中数据的位置和目标值，当剩余值大于等于0，进入循环，将当前数组值存入路径中，再继续递归，做下一次决策，由于可重复，所以下一次可以仍然从i开始，当满足条件时，将当前路径存入结果，此时回溯到上一层，继续寻找合适的路径。</p><p>组合求和（数组元素内部可能有重复，在数组中找到和为目标值的组合，此时不能重复使用数组的元素，解集不能包含重复的组合）：思路同上，因为不能重复使用数组元素，所以在for循环中dfs函数传值只鞥从i+1开始。与此同时，由于解集不能包含重复的组合，所以在排序后数组，当前一个数组元素和当前数组元素相同，那么当前元素得出的路径和上一个元素必定相同，因此这时需要跳过当前元素，对下一个元素处理。</p><p>全排列（给定一个没有重复数字的序列，返回其所有可能的全排列）：排列题是上一次选择的节点，这次不能再选择。每一层都可以选择一个未出现的元素，需要对数组元素设置标志位，当使用过，就将标志位置为1，此时也需要在for循环中加一层判断，查看当前数组是否被使用，当使用过时，需要跳过该元素，下一层继续选择，找到一个合适的结果后存储下来，接着撤销本次选择，返回上一层查看是否有其他结果。</p><p>全排列（给定一个可包含重复数字的序列，返回所有不重复的全排列）：思路同上，此时需要额外加个判断，看是否有重复的数字，有重复的数字则跳过。具体为：本次节点与前一个相同，并且前一个已使用过，说明已有相同的排列，则本次排列跳过。</p><p>n皇后问题：转换为全排列问题，在每一个的n个位置中选一个作为当前选择，n行做n个选择，并且是做做不重复的选择，正好构成一个排列，此时的排列满足不在同一行不在同一列，只要对当前的排列需要再满足题设条件即可，即不在主对角线，不在副对角线，vector<bool> master1;//副对角线和相同，都为i+j i为行，j为列，两者相加和是当前行，vector<bool> master2;//主对角线差相同，为i-j+n-1 i为行，j为列，再设置两个标志位进行判断，最后将得到的排列用题目中格式打印出来作为结果。</bool></bool></p><p>子集（给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集））：对不同子集个数进行深度遍历，此时需要在主函数中加一个循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>;i++)<span class="comment">//i的长度为0~nums.size(),所以需要加一</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//----通过i控制子集大小</span></span><br><span class="line">  dfs(start,i);</span><br><span class="line">  <span class="comment">//start是从数组中取元素的开始的位置，i是深度，即子集中元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分割字符串（给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串）：每次判断当前的起始至末尾位置是否是回文，如果是就将结果压入res，继续递归。通过不断变换分割的位置，来构造决策树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(start~i之间不是回文)</span><br><span class="line">    继续找下一个回文的位置</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//start~i之间是回文，压入结果内</span></span><br><span class="line">    res.push(s.substr(start,start+i+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">//继续看下一个分割位置</span></span><br><span class="line">    dfs(i+<span class="number">1</span>,depth)</span><br><span class="line">    <span class="comment">//撤销选择，回到上一层决策</span></span><br><span class="line">    res.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯法&quot;&gt;&lt;a href=&quot;#回溯法&quot; class=&quot;headerlink&quot; title=&quot;回溯法&quot;&gt;&lt;/a&gt;回溯法&lt;/h2&gt;&lt;p&gt;回溯一般用于找到满足要求的的所有解，即相当于构造一棵树，从跟节点出发，找到满足条件的所有路径，并进行保存，当目前的路径不符合条件的时候，需要回溯，即剪枝，删除不符合的分支，当到达结束的条件时，即找到了一个满足条件的解，再继续构造下一个符合条件的路径。&lt;/p&gt;&lt;p&gt;常用于解决树种求得所有解的问题和排列组合中求解问题，或者问题可以转换为求树中一条路径的问题，可以画图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="https://www.xiapf.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Leecode算法学习笔记（一）</title>
    <link href="https://www.xiapf.com/blogs/treeNote/"/>
    <id>https://www.xiapf.com/blogs/treeNote/</id>
    <published>2020-02-24T08:56:00.000Z</published>
    <updated>2020-03-10T09:46:57.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于树的算法"><a href="#关于树的算法" class="headerlink" title="关于树的算法"></a>关于树的算法</h2><p>除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储根节点</span></span><br><span class="line">p.push(root)</span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取该层节点个数</span></span><br><span class="line">  <span class="built_in">width</span>=p.<span class="built_in">size</span>()</span><br><span class="line">  <span class="comment">//读取该层所有节点，并存储下一层节 点</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;<span class="built_in">width</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//读取队首节点</span></span><br><span class="line">    r=p.front()</span><br><span class="line">    出队</span><br><span class="line">    <span class="keyword">if</span>(r的左子树存在) 左子树入队</span><br><span class="line">    <span class="keyword">if</span>(r的右子树存在) 右子树入队</span><br><span class="line">  &#125;</span><br><span class="line">  存储每层的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>应用场景：</p><p>锯齿形层次遍历：需要把偶数行反序排列</p><p>求最大深度：每层入队时，增加一个层数</p><p>求最小深度（从根节点到最近叶子节点的最短路径上的节点数量）：每层遇到左右节点均为空的节点时，输出此时的层数</p><h3 id="前、中、后序遍历"><a href="#前、中、后序遍历" class="headerlink" title="前、中、后序遍历"></a>前、中、后序遍历</h3><p>a.前序 遍历特点：根-左-右</p><p>栈：每次先访问当前节点，并依次将右子树压入栈，再循环遍历左子树，根据先进后出的特点，循环结束后，下次将从最左边子树的右子树开始循环</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line"></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//右子树入栈</span></span><br><span class="line">    s.push(p-&gt;right)</span><br><span class="line">    <span class="comment">//不断遍历左子树</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top();</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.后序 遍历特点：左-右-根</p><p>栈：因为先对根节点访问较为简单，原理类似前序遍历，因此，可以先访问当前根节点，将左子树压入栈，再循环遍历右子树。循环结束，下一次是对最右边的左子树开始循环。形成结果是根-右-左，最后将结果逆序即可</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前根节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//左子树入栈</span></span><br><span class="line">    s.push(p-&gt;left)</span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    p=p-&gt;right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top;</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最终结果逆序</span></span><br><span class="line">reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>c.中序 遍历特点：左-根-右</p><p>栈：中序处理方法和上两种有所不同，需要不断循环先找到最左边叶子节点，在此过程中需要不断把当前遍历到的根节点入栈，栈中存储根节点和左子树节点，当循环结束时，从栈尾中取出节点，再不断对该节点的右子树循环，</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//循环过程中不断将根节点和左子树节点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//根节点入栈</span></span><br><span class="line">    s.push(p)</span><br><span class="line">    <span class="comment">//找到最左边的子树节点</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//访问当前栈尾节点，</span></span><br><span class="line">  p=s,top();</span><br><span class="line">  res.push(p-&gt;val)</span><br><span class="line">  <span class="comment">//从栈中取出根节点</span></span><br><span class="line">  出栈</span><br><span class="line">  <span class="comment">//循环右子树</span></span><br><span class="line">  p=p-&gt;right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>验证一棵树是否是二叉搜索树（二叉搜索树的特点是左子树小于根节点，根节点小于右子树）：可以通过中序遍历比较节点值来判断</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>总体框架：明确一个节点需要做的事，剩余的分别扔给左子树和右子树处理</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//递归结束的条件：一个节点需要做的事（可能有多个结束条件）</span></span><br><span class="line">  <span class="keyword">if</span>(到达树的末尾)</span><br><span class="line">  <span class="keyword">do</span>….</span><br><span class="line">  <span class="comment">//递归循环的条件剩余的交给左右子树处理</span></span><br><span class="line">  doTree(root-&gt;left,其他参数)</span><br><span class="line">  doTree(root-&gt;right,其他参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>具体而言，可以分为以下几类：</p><p>根据前序、中序遍历或者中序、后序遍历构造二叉树：根据前序根节点在首位，可以在中序遍历确定左右子树；根据后序根节点在尾部，可以在中序遍历确定左右子树</p><p> 伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">getTree</span><span class="params">(<span class="built_in">vector</span> p, <span class="keyword">int</span> pl,<span class="keyword">int</span> pr, <span class="built_in">vector</span> i, <span class="keyword">int</span> il,<span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(左位置大于右位置)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="comment">//根据前序或者后序遍历的特点找到根节点</span></span><br><span class="line">  pivot=p[pl]</span><br><span class="line">  <span class="comment">//根据根节点生成树节点</span></span><br><span class="line">  TreeNode root=<span class="keyword">new</span> TreeNode(pivot)</span><br><span class="line">  <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">  pivotindex=il</span><br><span class="line">  <span class="keyword">while</span>(i[pivotindex]!=pivot)</span><br><span class="line">  &#123;</span><br><span class="line">  pivotindex++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定左子树</span></span><br><span class="line">  root-&gt;left= getTree(p,I,左子树的位置)</span><br><span class="line">  <span class="comment">//确定右子树</span></span><br><span class="line">  root-&gt;right= getTree(p,I,右子树的位置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(递归到树的最后，即某一结束的条件)</span><br><span class="line">  ….</span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（达到某一个值）&amp;&amp; doTree（root-&gt;left）&amp;&amp; doTree（root-&gt;right）(左右子树分别满足条件，此时递归，位置也可放到<span class="keyword">return</span>后面))</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>判断树的结构和值是否相同，即是否是相同的树：一个节点判断值是否相同，且左右子树的值和结构是否一致（调用函数，即递归）</p><p>对称二叉树：克隆一个数，和原来的树比较结构是否一致，思路同上</p><p>平衡二叉树（每个节点的左右子树的高度差绝对值小于1）：判断当前节点的高度，且左右子树的高度是否满足高度差小于1（调用函数，即递归）  注：里面包含求树的高度，可以找出左右子树高的那边再加1（也是使用递归）</p><p>判断一个树的路径和是否和目标值相同：每次判断当前叶子节点值（左右子树为空）与目标值是否相等，否则，将目标值减去当前节点值继续对左右子树递归</p><p>转换为二叉搜索树：需要利用中点，将原有数据进行排序,每次需要确定构造的数据的左右位置</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transBTS</span><span class="params">(<span class="built_in">vector</span> num，<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">  <span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//找到中点,构造根节点</span></span><br><span class="line">  <span class="comment">//(1)数组可以直接利用索引的1/2</span></span><br><span class="line">  <span class="comment">//(2)链表需要利用快慢指针，快指针走两步，慢指针走一步，快指针到末尾的时候，慢指针正好到中点</span></span><br><span class="line">  mid=…</span><br><span class="line">  TreeNode* root=<span class="keyword">new</span> TreeNode(num(mid))</span><br><span class="line">  <span class="comment">//递归构造左子树</span></span><br><span class="line">  root-&gt;left= transBTS(root-&gt;left,left,mid<span class="number">-1</span>)</span><br><span class="line">  <span class="comment">//递归构造右子树</span></span><br><span class="line">  root-&gt;right= transBTS(root-&gt;right, mid<span class="number">-1</span>,right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉搜索树的框架：利用左小右大的特点（类似二分查找）</p><p>​    伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BTS</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束条件</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val==num)</span><br><span class="line">  <span class="keyword">do</span>..(可以做增删改之类的操作)</span><br><span class="line">  <span class="comment">//循环条件</span></span><br><span class="line">  <span class="comment">//大于：对左子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&gt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;left,num)</span><br><span class="line">  <span class="comment">//小于：对右子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&lt;num)</span><br><span class="line">  <span class="keyword">return</span> BTS(root-&gt;right,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求“树的高度”类型题"><a href="#求“树的高度”类型题" class="headerlink" title="求“树的高度”类型题"></a>求“树的高度”类型题</h3><p>1.求树的高度</p><p>采用递归，自底向上</p><p>找到最底层节点，每次返回当前节点的左子树高度和右子树高度的较大值，则当前节点的高度为max(left,right)+1，一直向上递归。如图所示的二叉树：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p><p>从根节点递归，一直找到最左边的节点1，此时它的左右子树均为空，left=0,right=0,所以它的高度为1，接着返回上一层节点7的右子树4的高度，同理，节点4的高度为1，因此7的高度为max(depth(1),depth(4))+1，以此类推，一直向上找到根节点的高度即为树的高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前节点的左子树高度</span></span><br><span class="line">  <span class="keyword">int</span> l=depth(root-&gt;left);</span><br><span class="line">  <span class="comment">//当前节点的右子树高度</span></span><br><span class="line">  <span class="keyword">int</span> r=depth(root-&gt;left);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回当前节点的高度为两者中大的那个再加一</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.求二叉树直径，即任意两个结点路径长度中的最大值</p><p>思路同求树的高度：任意两个节点之间的距离是当前节点左子树加上右子树的高度，因为是求最大路径和，则最大不可能出现在中间节点，只可能是任意两个叶子节点之间的距离，该距离可以通过两个叶子节点之间连线经过的根节点的左右子树的高度相加来求解，如图二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200310165729.jpg" alt="二叉树"></p><p>节点1和节点2之间的路径为3，即为经过的根节点3的左右子树的高度和，同理，姐弟啊1和节点9之间的距离为5，即为即为经过的根节点6的左右子树的高度和.</p><p>所以问题转换为：求二叉树上所有节点的左右子树高度和的最大值，因此，可以将“求二叉树高度”的代码稍微进行改动即可。</p><p>注：因为每次要比较各个节点的高度和，所以需要传入一个maxvalue的值(传入的时候要加上取地址符号)，每次进行比较，一直更新，最终得出最大路径和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxTrack</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//求左右子树的高度</span></span><br><span class="line">  <span class="keyword">int</span> l=maxTrack(root-&gt;left,maxValue);</span><br><span class="line">  <span class="keyword">int</span> r=maxTrack(root-&gt;right,maxValue);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对当前的高度和即路径和进行比较</span></span><br><span class="line">  maxValue=<span class="built_in">max</span>(maxValue,l+r);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回左右子树高度较大的那个</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得出maxValue为最大路径和，maxTrack函数的最终返回值是根节点左右子树的高度和。</p><p>3.求二叉树的最大路径和，即从任意一个节点出发，到另一个节点之间的路径和的最大值。</p><p>思路同求二叉树的高度：从根节点开始递归，一直找到最左边的节点，计算此时的节点的左右子树较大的路径和，将值传递给当前父节点，父节点将自身值加上该值，继续传值给上一层节点，上一层的父节点也是在左右子树的较大值之间进行选择。保证每次都是在当前节点的左右子树中选择大的值进行回传，这样的保证路径和往大的方向走。</p><p>如图二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p><p>节点1的路径和是1,此时maxPath=0,更新为1，节点4的路径和是4，此时maxPath=1,更新为4，当求到节点7的路径和时，在它的左子树（节点1）和右子树（节点4）的路径和之间选择大的，即选择节点4，此时路径为7+4=11，此时maxPath=4,更新为11。再对节点3处理，左子树（11），右子树（2），选择左子树，此时路径和是11+3,此时maxPath=11,更新为14，以此类推，最终得到maxPath。</p><p>注：当当前左右子树加上当前节点值是负数，说明该条路径出现了“负贡献”，此时路径归0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//求左右子树的路径和</span></span><br><span class="line">  <span class="keyword">int</span> l=maxPath(root-&gt;left,maxValue);</span><br><span class="line">  <span class="keyword">int</span> r=maxPath(root-&gt;right,maxValue);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//更新当前最大路径</span></span><br><span class="line">  maxValue=<span class="built_in">max</span>(maxValue,l+r+root-&gt;value);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断路径有无出现负贡献</span></span><br><span class="line">  <span class="keyword">int</span> temp=<span class="built_in">max</span>(l,r)+root-&gt;val;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//每次选择左右子树中大的和自身相加！！！！</span></span><br><span class="line">  <span class="comment">//返回当前节点的路径和，作为上一次的子树值</span></span><br><span class="line">  <span class="keyword">return</span> temp&lt;<span class="number">0</span>?<span class="number">0</span>:temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到maxValue是最大路径和，maxPath返回值是根节点的左右子树加上自身的路径和。</p><h3 id="常规思路——bfs和dfs"><a href="#常规思路——bfs和dfs" class="headerlink" title="常规思路——bfs和dfs"></a>常规思路——bfs和dfs</h3><p>二叉树的题目大多数是遍历的变形题，往两个方向考虑：使用bfs——层次遍历还是dfs——深度遍历/回溯、递归，当使用非递归，即层次遍历的时候注意叶子节点的判断。</p><p>例如求二叉树从根节点出发的路径和，可以使用层次遍历，使用两个栈，一个用来存储每层的节点，另一个用来存储每层相加的和，当出现叶子节点的时候就把相加的和累加上去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(栈不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>=p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//存储每层累加的和</span></span><br><span class="line">  <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">width</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    r=p.front();</span><br><span class="line">    <span class="comment">//把当前节点的值加上上一次的和的10倍</span></span><br><span class="line">    val=numQue.front()*<span class="number">10</span>+r-&gt;val;<span class="comment">//numQue中存储每层节点累加的和</span></span><br><span class="line">    p.pop();</span><br><span class="line">    numQue.pop();</span><br><span class="line">    <span class="keyword">if</span>(叶子节点)</span><br><span class="line">      res+=val;</span><br><span class="line">    <span class="keyword">if</span>(左子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(左子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(右子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(右<span class="number">2</span>子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于树的算法&quot;&gt;&lt;a href=&quot;#关于树的算法&quot; class=&quot;headerlink&quot; title=&quot;关于树的算法&quot;&gt;&lt;/a&gt;关于树的算法&lt;/h2&gt;&lt;p&gt;除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。&lt;/p&gt;&lt;h3 id=&quot;层次遍历&quot;&gt;&lt;a href=&quot;#层次遍历&quot; class=&quot;headerlink&quot; title=&quot;层次遍历&quot;&gt;&lt;/a&gt;层次遍历&lt;/h3&gt;&lt;p&gt;队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点&lt;/p&gt;&lt;p&gt;伪代码：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//队列存储根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p.push(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(队列不为空)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//获取该层节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;=p.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//读取该层所有节点，并存储下一层节 点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i&amp;lt;&lt;span class=&quot;built_in&quot;&gt;width&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//读取队首节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r=p.front()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    出队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的左子树存在) 左子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r的右子树存在) 右子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  存储每层的结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://www.xiapf.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.xiapf.com/blogs/sort/"/>
    <id>https://www.xiapf.com/blogs/sort/</id>
    <published>2019-12-26T06:27:48.000Z</published>
    <updated>2020-01-20T12:17:50.705Z</updated>
    
    <content type="html"><![CDATA[<p>几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序</p><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后</p><p>​        第一次排序后：3，5，6，2，7，8，1，4，9</p><p>​        第二次排序后：3，5，2，6，7，1，4，8，9</p><a id="more"></a><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p>第一次：首先排第一个位置，先设min=0记录最小值位置，默认第一个位置，将6与3比较，3比6小，则min=1(代表3的位置)；再将3与5比较，3比5小，不改变min值；依次将min位置的数值依次与后续数字比较，比min小则更改min为更小值的位置，直到最后一个数字比完。此时min=7(1的位置)，将6与7对换，则第一次排序完成。</p><p>​        第一次排序后顺序是：1，3，5，7，2，9，8，6，4</p><p>第二次：排第二个位置，方法同上，设min=1代表默认第二个位置，即数值3默认最小值，将3依次与后续比较，找出最小值，min=最小值的位置，交换第二个位置的值3与min位置的值2，完成第二次排序。</p><p>​        第二次排序后：1，2，5，7，3，9，8，6，4</p><p>​        第三次排序后：1，2，3，7，5，9，8，6，4</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><p>​        第五次排序后顺序为：1，2，3，4，5，9，8，6，7</p><p>​        第六次排序后顺序为：1，2，3，4，5，6，8，9，7</p><p>​        第七次排序后顺序为：1，2，3，4，5，6，7，9，8</p><p>​        第八次排序后顺序为：1，2，3，4，5，6，7，8，9</p><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p>​        第一次排序后：6</p><p>​        第二次排序后：3，6</p><p>​        第三次排序后：3，5，6</p><p>​        。。。。。。。</p><p>时间复杂度：O(n^2)</p><h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h6><p>同直接插入排序，但是在比较的时候，是折半比较，思想同折半查找</p><p>时间复杂度：O(n^2)</p><h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p>第一次：设步长d=5，则6和9；3和8；5和1；7和4；直接插入排序</p><p>​        第一次排序后：6，3，1，4，2，9，8，5，7</p><p>第二次：d = d/2 = 2，则6，1，2，8，7；3，4，9，5；直接插入排序</p><p>​        第二次排序后：1，3，2，4，6，5，7，9，8</p><p>第三次：d = d/2 = 1，则所有数据直接插入排序</p><p>​        第三次排序后：1，2，3，4，5，6，7，8，9</p><p>时间复杂度：O(nlog2^n)</p><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>第一次：选取第一个数6为轴，将第一个6与最后一个数字4比较（从后往前比），如果大于比较的数字，则调换，然后与原位置后面开始比（从前往后比），以此类推，第一次排完后，轴6的左边都小于6，右边都大于6。</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226160921.png" alt="快速排序i,j变化"></p><p>​        第一次排序后：4，3，5，1，2，6，8，9，7</p><p>第二次：则将上个比较后的轴的左右依次做快速排序，直到所有子表的表长不超过1</p><p>时间复杂度：O(nlog2^n)</p><h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>首先建立初始堆，按照顺序方式建立完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p><p>然后建立大顶堆，分别将有子节点的7，3，5，6从底层开始，分别与子节点比较，选大的作为父节点，即可得到最大的根节点的二叉树，即大顶堆</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226140326.png" alt="大顶堆"></p><p>然后，将堆顶拿下来，将叶子节点放上去，再次按照大顶堆方法，得到根节点，以此类推，最终得到有序数列</p><p>时间复杂度：O(nlog2^n)</p><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><p>对数组递归折半分割，直到分割成单个，然后递归合并比较，直到合并为整个数组</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226142419.png" alt="归并排序"></p><p>时间复杂度：O(nlog2^n)</p><p>总结：时间复杂度是nlog2^n的是：快些(希)归队(堆)，不稳定的是：快些(希)选队(堆)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序&lt;/p&gt;&lt;h6 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h6&gt;&lt;p&gt;第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后&lt;/p&gt;&lt;p&gt;​        第一次排序后：3，5，6，2，7，8，1，4，9&lt;/p&gt;&lt;p&gt;​        第二次排序后：3，5，2，6，7，1，4，8，9&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.xiapf.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.xiapf.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.xiapf.com/blogs/hello-world/"/>
    <id>https://www.xiapf.com/blogs/hello-world/</id>
    <published>2019-12-13T12:52:51.111Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noopener noreferrer&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo部署时用户名密码设置</title>
    <link href="https://www.xiapf.com/blogs/hexo-deploy/"/>
    <id>https://www.xiapf.com/blogs/hexo-deploy/</id>
    <published>2019-12-13T06:48:37.000Z</published>
    <updated>2019-12-13T12:52:51.112Z</updated>
    
    <content type="html"><![CDATA[<p>hexo部署时用户名密码问题：</p><p>记住用户名密码，不用每次都输入用户名密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>清除用户名密码，防止用户名密码输入错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;hexo部署时用户名密码问题：&lt;/p&gt;&lt;p&gt;记住用户名密码，不用每次都输入用户名密码&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.xiapf.com/tags/hexo/"/>
    
      <category term="git" scheme="https://www.xiapf.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>docker简易教程</title>
    <link href="https://www.xiapf.com/blogs/docker/"/>
    <id>https://www.xiapf.com/blogs/docker/</id>
    <published>2019-12-12T05:44:29.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker：虚拟化容器技术"><a href="#Docker：虚拟化容器技术" class="headerlink" title="Docker：虚拟化容器技术"></a>Docker：虚拟化容器技术</h2><p>三大组件：镜像，容器，仓库</p><pre><code>镜像：想象成系统iso或者ghost镜像容器：想象成一个系统环境仓库：想象成GitHub</code></pre><p>优点：隔离性   便捷性–移植和集群     轻量级   云支持</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Cenos7下安装docker</p><p>1.把yum包更新到最新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.安装需要的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3.设置yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>4.可以查看所有仓库中所有docker版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>5.安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-17.12.1.ce</span><br></pre></td></tr></table></figure><p>6.启动Docker，加入开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>7.验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="编辑容器"><a href="#编辑容器" class="headerlink" title="编辑容器"></a>编辑容器</h2><p>从仓库中拉去一个centos7的镜像 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doucker pull centos:7</span><br></pre></td></tr></table></figure><p>启动镜像生成容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -i -t &lt;IMAGE ID&gt; bash</span><br></pre></td></tr></table></figure><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER ID&gt; bash</span><br></pre></td></tr></table></figure><p>此时就是进入了centos7的linux系统，可以在里安装jdk,tomcat等，然后部署war后，执行</p><p><code>curl localhost:端口号</code>    看看是否可以访问。</p><p>为了可以启动容器的时候，自动启动tomcat，可以写一个脚本，启动容器的时候，启动此脚本。<br>例如我在最根目录创建了runtomcat.sh的脚本<br>脚本内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/soft/jdk1.5.0_22</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">sh /soft/apache-tomcat-5.5.25/bin/catalina.sh run</span><br></pre></td></tr></table></figure><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>将原来的容器制成镜像–docker commit containerid new_image:tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit centos7_base centos:7.1</span><br></pre></td></tr></table></figure><p>使用新的镜像制成容器–docker run -d -p 主机端口:容器端口/tcp –name 容器名 镜像名:tag  </p><p>并执行docker内脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 18080:8080 --name centos7_1 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>宿主机端口是18080映射了容器内的8080tomcat端口，现在直接访问宿主机的ip:18080/cvbs就可以访问容器的web服务了。<br>查看docker运行情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144010.png" alt="查看docker运行情况"></p><p>可以看到此时新的容器已经启动了</p><p>再次制成一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 28080:8080 --name centos7_2 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure><p>查看docker运行情况–<code>docker ps –a</code></p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144100.png" alt="查看docker运行情况"></p><p>此时可以看到已经部署了两个服务了，分别映射在宿主机的18080和28080端口</p><p>外部浏览器访问：</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144117.png" alt="浏览器双端口访问"></p><p>可以看到两个端口都可以访问了</p><p>因为我是在虚拟机里安装，所以局域网中其他机器无法访问到此ip，</p><p>所以为了省略配置虚拟机对外暴露的ip等步骤，直接在主机中通过配置nginx做代理，配置如下</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144141.png" alt="nginx配置"></p><p>此时外部访问即可<code>http://10.45.12.120/cvbs</code>（我的局域网内ip）即可访问到docker中部署两个的应用。</p><p>注意：因为有些项目没有做分布式session处理，所以简单使用ip_hash策略解决session问题</p><h2 id="IDEA中配置docker"><a href="#IDEA中配置docker" class="headerlink" title="IDEA中配置docker"></a>IDEA中配置docker</h2><p>1.在根目录写Dockerfile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定基础镜像，在其上进行定制FROM java:8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制上下文目录下的target/demo-1.0.0.jar 到容器里</span></span><br><span class="line">ADD target/spring-boot-0.0.1-SNAPSHOT.jar test.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash方式执行，使test.jar可访问</span></span><br><span class="line"><span class="comment">#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。</span></span><br><span class="line">RUN bash -c <span class="string">"touch /test.jar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</span></span><br><span class="line">EXPOSE 8088</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器启动程序及参数   &lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"test.jar"</span>]</span><br></pre></td></tr></table></figure><p>2.在启动配置中配置dockerfile,image,container,port(宿主机和docker的端口映射)</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144221.png" alt="配置dockerfile"></p><p>3.Maven打包</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144237.png" alt="maven打包"></p><p>4.Docker部署</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144250.png" alt="docker部署"></p><p>5.启动Docker</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144304.png" alt="启动docker"></p><p>6.查看docker运行情况</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144319.png" alt="查看docker运行情况3"></p><p>7.浏览器访问成功</p><p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144335.png" alt="浏览器访问"></p><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p><p>可以对各种虚拟化容器技术做统一的管理</p><p>实际项目中大量用到docker时，可以在研究k8s的实际使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;a href=&quot;#Docker：虚拟化容器技术&quot; class=&quot;headerlink&quot; title=&quot;Docker：虚拟化容器技术&quot;&gt;&lt;/a&gt;Docker：虚拟化容器技术&lt;/h2&gt;&lt;p&gt;三大组件：镜像，容器，仓库&lt;/p&gt;&lt;pre&gt;&lt;code&gt;镜像：想象成系统iso或者ghost镜像

容器：想象成一个系统环境

仓库：想象成GitHub&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;优点：隔离性   便捷性–移植和集群     轻量级   云支持&lt;/p&gt;&lt;h2 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h2&gt;&lt;p&gt;Cenos7下安装docker&lt;/p&gt;&lt;p&gt;1.把yum包更新到最新&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://www.xiapf.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://www.xiapf.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>future与futuretask用法区别</title>
    <link href="https://www.xiapf.com/blogs/future-futuretask/"/>
    <id>https://www.xiapf.com/blogs/future-futuretask/</id>
    <published>2019-12-12T05:32:37.000Z</published>
    <updated>2019-12-13T12:52:51.111Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Future和FutureTask方法区别，主要在于获取返回结果上。"><a href="#Future和FutureTask方法区别，主要在于获取返回结果上。" class="headerlink" title="Future和FutureTask方法区别，主要在于获取返回结果上。"></a>Future和FutureTask方法区别，主要在于获取返回结果上。</h6><p>Future方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(<span class="keyword">new</span> Test7());</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>submit里放的是实现callable接口的类，通过返回值submit.get()，获取返回结果6，如果test抛出异常，此时，主线程会捕获，打印3，不调用submit.get()，将不会捕获异常。</p><p>FutureTask方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Test8());</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(ft);</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            Object o1 = ft.get();</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executor里放的是futuretask，futuretask包装了一层callable对象，此时要获取返回结果需要使用futuretask的get()方法，不能使用submit.get(),submit.get()会返回null;只用ft.get()会捕获异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;a href=&quot;#Future和FutureTask方法区别，主要在于获取返回结果上。&quot; class=&quot;headerlink&quot; title=&quot;Future和FutureTask方法区别，主要在于获取返回结果上。&quot;&gt;&lt;/a&gt;Future和FutureTask方法区别，主要在于获取返回结果上。&lt;/h6&gt;&lt;p&gt;Future方式：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test7&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService executor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,TimeUnit.SECONDS,&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Future&amp;lt;?&amp;gt; submit = executor.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test7());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object o = submit.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executor.shutdown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://www.xiapf.com/categories/java/"/>
    
    
      <category term="多线程" scheme="https://www.xiapf.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://www.xiapf.com/tags/java/"/>
    
      <category term="future" scheme="https://www.xiapf.com/tags/future/"/>
    
  </entry>
  
  <entry>
    <title>用bp网络预测绿萝叶片面积</title>
    <link href="https://www.xiapf.com/blogs/bp-net/"/>
    <id>https://www.xiapf.com/blogs/bp-net/</id>
    <published>2019-12-11T02:46:04.000Z</published>
    <updated>2020-01-20T12:17:50.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。</p></blockquote><hr><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p><em>测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。<br>数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。</em><br><strong>其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。</strong></p><a id="more"></a><ul><li>计算面积的MATLAB程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%% 分割</span><br><span class="line">k=graythresh(I);              %得到最优阈值</span><br><span class="line">j=im2bw(I,k);                  %转换成二值图，k为分割阈值</span><br><span class="line">%imshow(j); </span><br><span class="line">f = bwmorph(j,&apos;open&apos;);  %开运算</span><br><span class="line">figure, imshow(f)</span><br><span class="line">%% 像素点统计</span><br><span class="line">[m,n]=size(f);</span><br><span class="line">k=0;</span><br><span class="line">for i=1:1:m</span><br><span class="line">    for j=1:1:n</span><br><span class="line">        if f(i,j)==0</span><br><span class="line">            k=k+1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">p=k/(m*n);</span><br><span class="line">s=21*29.7*p;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="bp网络设计"><a href="#bp网络设计" class="headerlink" title="bp网络设计"></a>bp网络设计</h1><p>bp网络示意图及各变量含义<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%8F%8A%E5%90%84%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png" alt="bp结构图片"></p><ol><li><p>结构选取<br>a.隐含层数量选取：单隐层结构选择，当仅有一层隐含层时，测试数据正确率已达100%，为降低网络复杂度，所以选择单隐层结构。<br>b.隐含层神经元个数选取</p><table><thead><tr><th align="left">隐含层神经元个数</th><th align="left">达到最小误差时需要迭代的次数</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">1873</td></tr><tr><td align="left">10</td><td align="left">2009</td></tr><tr><td align="left">15</td><td align="left">2259</td></tr></tbody></table><p>根据程序运行来看，当隐藏层神经元个数选择过小（小于5）收敛速度很慢，当到达最大迭代次数时，误差仍很大，当个数选择过大（大于15），网络出现振荡，因此，考虑隐藏层神经元个数在5-15之间，因为本实验数据集属性少，因此选择隐藏层神经元个数为5个，减少复杂度。<br> c.误差函数选择均方差公式：$[    {E_{k} } =1/2*( \hat{y}-y) ]$<br> d.结束条件：<br> 训练结束条件：当误差函数值小于1e-3或者迭代次数大于50000次时结束训练<br> 测试误差判断：当测试集输出面积和实际面积误差函数值大于1e-5时，预测错误，反之预测正确。</p></li><li><p>初始值设置<br>a.权值矩阵的初始值<br>产生0-1之间的随机数作为权值的初始值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srand(time(NULL));//设置随机数种子，使每次产生的随机序列不同</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">    w[i] = rand() % (N + 1) / (float)(N + 1);//N为设置的精度</span><br></pre></td></tr></table></figure><p>b.学习率的初始值<br>学习率控制着算法每一轮的迭代的更新步长，若太大则容易振荡，太小则收敛速度又过慢因此需要选择适合的初始值。<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%8F%98%E5%8C%96.png" alt="学习率变化图片"><br>由图可以看出，当学习率小于1时，网络训练次数多集中在1000以上，但当学习率大于5时，测试集数据会出现错误，因此选择训练次数少并且误差低的学习率=5.</p></li><li><p>数据归一化<br>前三列属性取值∈[2,9]，因此采用对数函数y=log10(x) 以10为底的对数函数转换。<br>最后一列属性取值∈[10,100]，因此采用反余弦函数y=atan(x)*2/PI，保证输入的数据在0-1之间，让网络更快的收敛。</p></li><li><p>前向传播和反向传播<br>a.前向传播<br>激活函数选择sigmod函数，第i个输入层神经元到第h个隐藏层神经元的权值为Vih,第h个隐藏层神经元输入为α=∑Vih<em>Xi，输出为bh;第h个输入层神经元到第j个隐藏层神经元的权值为Whj,第j个输出层神经元的输入β=∑Whj</em>bh,输出为<br>求出激活值，代入sigmod函数中，求得输出值<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">   o1[j]=0.0;</span><br><span class="line">   for(int i=0;i&lt;inSum;i++)</span><br><span class="line">   //激活值</span><br><span class="line">   o1[j]=o1[j]+w[i][j]*x[i];</span><br><span class="line">   //实际输出</span><br><span class="line">   x1[j]=1.0/(1+exp(-o1[j]-b1[j])); //b1为偏置量</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>b.反向传播<br>网络在（Xk,Yk)上的均方差为，BP算法基于梯度下降的策略，以目标的负梯度方向进行调整在学习率下，采用链式法则对权值进行更新：<br>从输出层到隐藏层，有:<br>从隐藏层到输入层，有:</p></li></ol><ul><li>算法描述:<blockquote><p>在（0，1）范围内初始化权值和学习率<br>REPEAT<br>FOR all（Xk,Yk)：<br>输入正向传播公式计算输出<br>计算输出层需修改的梯度项gj<br>计算隐藏层层需修改的梯度项eh<br>根据公式更新权值wjh,vij<br>END FOR<br>UNTIL 达到停止条件</p></blockquote></li></ul><p>标准BP算法：上述算法是对每个样本更新权值，属于标准BP算法，参数更新的频繁<br>累积BP算法：当读取完所有样本之后才更新参数，参数更新的频率低<br>区别：累积BP算法在误差下降到一定阶段，下降回非常缓慢，所以往往标准BP算法能更快得到较好解。<br><em>使用标准BP算法：对每个样本更新权值</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        w1[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        w[i][j]+=rate_w*pp[j]*x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>使用累积BP算法：遍历完所有样本再更新权值<br>增加权值修改矩阵，将误差进行累加</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        chg_w2[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">        chg_b2[k]+=rate_b2*qq[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    &#125;</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        chg_w1[i][j]=chg_w1[i][j]+rate_w1*pp[j]*x[i];</span><br><span class="line">        chg_b1[j]+=rate_b1*pp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">548</td><td align="left">348</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">100%</td><td align="left">100%</td></tr></tbody></table><p>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>如果将长边短边合成一条边，效果还是一样吗？<br>将数据集中长边L1和短边L2相加得到叶子的长为L，输入的属性列变为长L,宽W,面积area<br>网络结构采取上述结构，训练效果如下图：<table><thead><tr><th align="left">对比</th><th align="left">标准BP算法</th><th align="left">累积BP算法</th></tr></thead><tbody><tr><td align="left">迭代次数</td><td align="left">566</td><td align="left">717</td></tr><tr><td align="left">训练平均误差</td><td align="left">小于1e-5</td><td align="left">小于1e-5</td></tr><tr><td align="left">识别结果</td><td align="left">94.5%</td><td align="left">97.3%</td></tr></tbody></table></li></ul><p>因实验所用的叶片有破损存在，直接用长边加上短边得到的叶片长度存在一定误差，因此使用BP算法时，识别结果略有下降.<br>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。&lt;/p&gt;
&lt;/blockquote&gt;&lt;hr&gt;&lt;h1 id=&quot;数据采集&quot;&gt;&lt;a href=&quot;#数据采集&quot; class=&quot;headerlink&quot; title=&quot;数据采集&quot;&gt;&lt;/a&gt;数据采集&lt;/h1&gt;&lt;p&gt;&lt;em&gt;测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。&lt;br&gt;数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。&lt;/em&gt;&lt;br&gt;&lt;strong&gt;其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://www.xiapf.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://www.xiapf.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="神经网络" scheme="https://www.xiapf.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
