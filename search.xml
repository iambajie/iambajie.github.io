<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>监督学习笔记（二）——朴素贝叶斯分类器</title>
    <url>/blogs/bayes/</url>
    <content><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>（1）问题原理：朴素贝叶斯分类的依据是概率，假设需要分为两类c1和c2，则某个数据点属于哪一类，需要计算p(c1|x)和p{c2|x)，即计算数据点x来自c1和来自c2中的概率哪个大，如果p(c1|x)&gt;p{c2|x)，则x被分到c1类别中，反之被分到c2类别中。</p><p>（2）计算原理：上述概率属于条件概率，根据公式p(c|x)=p(x|c) * p(c)/ p(x)可以得到，当求（x,y）来自哪个类别时，即用（x,y）替换x，即求p(c|x,y),代入条件概率公式中得，p(c|x,y)=p(x,y|c) * p(c)/p(x,y)，因此问题转换为求p(x,y|c) * p(c)/p(x,y)中三个概率的值。</p><a id="more"></a>

<p>求p(c)：对于所有数据点来说，p(c)是出现某类别的数据/总数据</p>
<p>求p(x,y|c)：因为朴素贝叶斯的假设是所有特征是独立的，那么p(x,y|c)=p(x1,y1|c) * p(x2,y2|c) *… * p(xn,yn|c)，p(xi,yi|c)是求在某个类别下，每个特征的数据占当前类别总数据的概率，每个特征的概率求解出后连乘即可得到该概率</p>
<p>求p(x,y)：因为对于所有类别来说p(x,y)都是相同的，所以只要比较上面两个概率乘积的大小即可</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>以二分类为例子：</p>
<p>（1）载入数据集</p>
<p>1.读取文件路径，并将读取的文件按照单词进行划分，划分使用正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">regex=re.compile(<span class="string">"\\W+"</span>)</span><br><span class="line">listToken=regex.split(file)</span><br></pre></td></tr></table></figure>

<p>2.将数据进行存储，同时存储数据标签</p>
<p>注：因为此时存储的数据集是文本，在测试和训练的时候需要转换为单词向量的形式</p>
<p>输入词汇表和需要变为单词向量的文本，在词汇表中出现的单词的位置，在单词向量中对应设置为1，其余为0，这样就能构造出单词向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> inputWord:</span><br><span class="line">  <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">    returnVec[vocaList.index(word)]+=<span class="number">1</span><span class="comment">#在词汇表中单词的位置的，对应的单词向量的位置设置为1</span></span><br></pre></td></tr></table></figure>

<p>（ * ）可增加的部分：删除高频词</p>
<p>因为有些词例如a,about,the等这些常用词在很多地方都会出现，这些高频出现的词，可能会对分类的概率产生影响，可以对所有数据进行遍历，找到出现频率最高的单词在词汇表中删除（可以取前20或30等，根据数据量决定）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcTopWord</span><span class="params">(fullText,vocabList)</span>:</span></span><br><span class="line">  //存储出现概率及单词，用到键值对</span><br><span class="line">  wordList=&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> word <span class="keyword">in</span> fullText:</span><br><span class="line">    wordlist[word]=fullText.(word)<span class="comment">#在整篇文档计算单词出现的次数，count</span></span><br><span class="line">  //从大到小排序,用值排序</span><br><span class="line">  rankList=sorted(wordList.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>（2）得出词汇表</p>
<p>找到数据集中不重复的单词作为词汇表，为后续统计每个单词出现的频率（即每个特征的概率）做准备</p>
<p>用set得到不重复的单词</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataWord <span class="keyword">in</span> dataSet:</span><br><span class="line">		vocaList=vocaList|set(dataWord)</span><br></pre></td></tr></table></figure>

<p>（3）随机选择一部分作为测试集和训练集</p>
<p>将训练集设置为总数据集数量，测试集用随机数设置（random.uniform）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainSet=list(range(lenData))</span><br><span class="line"><span class="comment">#假设随机选择5个测试集</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  <span class="comment">#得出位置 int类型</span></span><br><span class="line">  testIndex=(int)(random.uniform(<span class="number">0</span>,len(trainSet)))</span><br><span class="line">  <span class="comment">#测试集的数据位置</span></span><br><span class="line">  testSet.appen(trainSet[testIndex])</span><br><span class="line">  <span class="comment">#训练集的数据位置</span></span><br><span class="line">  <span class="keyword">del</span>(trainSet[testIndex])</span><br></pre></td></tr></table></figure>

<p>（4）根据训练集训练贝叶斯分类器</p>
<p>1.计算p(c)、p(x,y|c)</p>
<p>计算p(c)：因为是两个类别，只需要计算p(c)，用1-p(c)可以得出另一个类别出现的概率。p(c)通过对类别标记中1出现的次数求和即为1类别出现的次数，再除以文档总数，即为p(c)</p>
<p>计算p(x,y|c)：对所有数据进行遍历，分布对0类别和1类别下，所有单词出现的概率进行计算</p>
<p>注：为防止出现很多很小的数：计算概率时用log，即p(x,y|c)用logp(x,y|c)表示</p>
<p>为防止各个特征的概率相乘出现0：初始设置p(x,y|c)=1，p(c)=2</p>
<p>2.训练的结果就是得出训练集下数据属于不同类别的概率</p>
<p>以两个类别为例，即最终得出在0类别和1类别下所有特征的出现的概率p(x,y|c0)，p(x,y|c1)和0类别、1类别数据出现的概率p(c)，得出这两个概率后，用测试集数据乘以不同类别下的p(ci|x,y)（即用数据 *p(x,y|ci) * p(c)），比较p(x,y|c0)和p(x,y|c1)得出分属的类别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#已求出p0V,p1V,pAuixs</span></span><br><span class="line"><span class="comment">#属于两个类别的概率，进行比较即可</span></span><br><span class="line">p1=sum(inputMatrix*p1V)+log(pAuixs)</span><br><span class="line">p0=sum(inputMatrix*p0V)+log(<span class="number">1</span>-pAuixs)</span><br></pre></td></tr></table></figure>

<p>（5）在测试集上，使用贝叶斯分类器，分类结果和实际标记对比，得出总体错误率</p>
<p>1.计算条件概率，即比较两个类别的概率，确定分类的结果</p>
<p>2.与实际结果比对，分类错误则进行标记</p>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>广告内容倾向分类</p>
<p>该案例使用feedparse获取网页的rss源，对网页所有目录的列表读取其中的概要，输入两个网页，根据两个网页中单词出现的概率来进行分类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#获得不重复的单词列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">	<span class="comment">#set返回的是不重复的数据</span></span><br><span class="line">	vocaList=set([])</span><br><span class="line">	<span class="keyword">for</span> dataWord <span class="keyword">in</span> dataSet:</span><br><span class="line">		vocaList=vocaList|set(dataWord)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> list(vocaList)<span class="comment">#返回列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.0词袋模型，每个词可以出现多次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2Vec</span><span class="params">(vocaList,inputWord)</span>:</span></span><br><span class="line">	returnVec=[<span class="number">0</span>]*len(vocaList)</span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> inputWord:</span><br><span class="line">		<span class="keyword">if</span>(word <span class="keyword">in</span> vocaList):</span><br><span class="line">			returnVec[vocaList.index(word)]+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			print(<span class="string">"the word:"</span>+str(word)+<span class="string">" is not in the vocaList"</span>)</span><br><span class="line">	<span class="keyword">return</span> returnVec</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用朴素贝叶斯进行文档分类</span></span><br><span class="line"><span class="comment">#主要是进行概率比较，条件概率定义为p(c|w)=p(w|c)*p(c)/p(w),对所有类别来说，p(w)都是相同的，因此可以不计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCatalog)</span>:</span></span><br><span class="line">	<span class="comment">#0.计算不同类别下的文档概率即p(c)</span></span><br><span class="line">	<span class="comment">#此处是二值分类，另一个概率可以用1-p(c)来计算</span></span><br><span class="line">	<span class="comment">#0.0文档的个数</span></span><br><span class="line">	numDocu=len(trainMatrix)</span><br><span class="line">	<span class="comment">#0.1侮辱性文档的概率</span></span><br><span class="line"></span><br><span class="line">	pAuixs=sum(trainCatalog)/numDocu</span><br><span class="line">	<span class="comment">#0.2初始化累加值</span></span><br><span class="line">	<span class="comment">#每行词汇的长度</span></span><br><span class="line">	numWords=len(trainMatrix[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#因为是独立的概率，如果其中一个为0，整个为0，避免这种情况，初始化为1</span></span><br><span class="line">	<span class="comment">#p1num=zeros((numWords))</span></span><br><span class="line">	<span class="comment">#p0num=zeros(numWords)</span></span><br><span class="line">	<span class="comment">#p1Denom=0</span></span><br><span class="line">	<span class="comment">#p0Denom=0</span></span><br><span class="line">	p1num=ones((numWords))</span><br><span class="line">	p0num=ones(numWords)</span><br><span class="line">	p1Denom=<span class="number">2</span></span><br><span class="line">	p0Denom=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#1.按照不同类别计算p(w|c)即计算不同类别下词向量出现的次数</span></span><br><span class="line">	<span class="comment">#根据当前类别下每个词出现的次数除以在该类别下所有单词出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(numDocu):</span><br><span class="line">		<span class="comment">#1.0 侮辱类别</span></span><br><span class="line">		<span class="keyword">if</span>(trainCatalog[i]==<span class="number">1</span>):</span><br><span class="line">			p1num+=trainMatrix[i]</span><br><span class="line">			p1Denom+=sum(trainMatrix[i])</span><br><span class="line">		<span class="comment">#1.1 非侮辱类别</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			p0num+=trainMatrix[i]</span><br><span class="line">			p0Denom+=sum(trainMatrix[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment">#为了避免出现过小的数,出现下溢出，使用log</span></span><br><span class="line">	p1Vec=log(p1num/p1Denom)</span><br><span class="line">	p0Vec=log(p0num/p0Denom)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p0Vec,p1Vec,pAuixs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#朴素贝叶斯分类器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classfyNB</span><span class="params">(wordVec,p0Vec,p1Vec,pAuixs)</span>:</span></span><br><span class="line">	<span class="comment">#比较单词向量乘以p(w|c)*p(c),因为p(w|c)使用了log处理，所以，这边的pauixs也需要加上log,log相加代表相乘</span></span><br><span class="line">	<span class="comment">#因为是独立的，所以计算每个单词出现的概率p(wi|c)，因为做了log处理，这里sum等同于去掉log后概率相乘</span></span><br><span class="line">	p1=sum(wordVec*p1Vec)+log(pAuixs)</span><br><span class="line">	p0=sum(wordVec*p0Vec)+log(<span class="number">1</span>-pAuixs)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p1&gt;p0):</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试分类器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment">#0.载入实验样本</span></span><br><span class="line">	listPosts,listLabels=loadDataSet();</span><br><span class="line">	<span class="comment">#1.生成词汇表</span></span><br><span class="line">	vocabList=createVocabList(listPosts)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#2.文本转换为单词向量，方法中是对每行文本进行转换</span></span><br><span class="line">	m=len(listPosts)</span><br><span class="line">	wordVec=[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		wordVec.append(setOfWords2Vec(vocabList,listPosts[i]))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#3.构造贝叶斯分类器</span></span><br><span class="line">	p0Vec,p1Vec,pAuixs=trainNB0(wordVec,listLabels)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#4.测试数据进行测试</span></span><br><span class="line">	<span class="comment">#4.0构造测试数据</span></span><br><span class="line">	testList=[<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">	<span class="comment">#4.1转换为单词向量</span></span><br><span class="line">	testVec=setOfWords2Vec(vocabList,testList)</span><br><span class="line">	<span class="comment">#4.2计算概率</span></span><br><span class="line">	testP=classfyNB(testVec,p0Vec,p1Vec,pAuixs)</span><br><span class="line">	print(str(testList)+<span class="string">" is:"</span>+str(testP))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#4.测试数据进行测试</span></span><br><span class="line">	<span class="comment">#4.0构造测试数据</span></span><br><span class="line">	testList=[<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">	<span class="comment">#4.1转换为单词向量</span></span><br><span class="line">	testVec=setOfWords2Vec(vocabList,testList)</span><br><span class="line">	<span class="comment">#4.2计算概率</span></span><br><span class="line">	testP=classfyNB(testVec,p0Vec,p1Vec,pAuixs)</span><br><span class="line">	print(str(testList)+<span class="string">" is:"</span>+str(testP))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用贝叶斯分类器进行垃圾邮件过滤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件内的文本，对长度小于两个的单词进行过滤</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(file)</span>:</span></span><br><span class="line">	<span class="keyword">import</span> re</span><br><span class="line">	<span class="comment">#0.正则表达式进行分割</span></span><br><span class="line">	regex=re.compile(<span class="string">"\\W+"</span>)</span><br><span class="line">	<span class="comment">#1.对读入的问津进行分割</span></span><br><span class="line">	<span class="comment">#file=file.encode('utf-8')</span></span><br><span class="line"></span><br><span class="line">	listTokens=regex.split(file)</span><br><span class="line">	<span class="keyword">return</span> [token.lower() <span class="keyword">for</span> token <span class="keyword">in</span> listTokens <span class="keyword">if</span> len(token)&gt;<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#用朴素贝叶斯分类器对个人广告区域进行倾向分类</span></span><br><span class="line"><span class="comment">#从rss中获取文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本中出现频率前30的去掉</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcMostFreq</span><span class="params">(vocabList,fullList)</span>:</span></span><br><span class="line">	<span class="keyword">import</span> operator</span><br><span class="line">	<span class="comment">#代表键值对</span></span><br><span class="line">	wordFreq=&#123;&#125;</span><br><span class="line">	<span class="comment">#对整篇文档计算单词表中单词出现的频率</span></span><br><span class="line">	<span class="keyword">for</span> token <span class="keyword">in</span> vocabList:</span><br><span class="line">		wordFreq[token]=fullList.count(token)</span><br><span class="line">	<span class="comment">#按照字典中值进行排序（即出现的次数），以第几个域排序，按照降序排列</span></span><br><span class="line">	<span class="comment">#此时变为了列表，可以返回前30个</span></span><br><span class="line">	freqList=sorted(wordFreq.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> freqList[:<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入的参数为：从feedparse中获取的网页的rss源，feed0是0网页，里面的内容标记为0，feed1是1网页，里面的内容标记为1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loacWords</span><span class="params">(feed0,feed1)</span>:</span></span><br><span class="line">	<span class="keyword">import</span> feedparser</span><br><span class="line">	<span class="comment">#0.获取文本</span></span><br><span class="line">	docList=[]</span><br><span class="line">	classList=[]</span><br><span class="line">	wordList=[]</span><br><span class="line">	fullList=[]</span><br><span class="line">	<span class="comment">#feed0['entries']是获取所有条目的列表</span></span><br><span class="line">	minlen=min(len(feed0[<span class="string">'entries'</span>]),len(feed1[<span class="string">'entries'</span>]))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(minlen):</span><br><span class="line">		<span class="comment">#对第i个条目的概要提取内容，并进行单词划分</span></span><br><span class="line">		wordList=textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		classList.append(<span class="string">"0"</span>)</span><br><span class="line">		<span class="comment">#把所有单词加入到一个列表方便计数</span></span><br><span class="line">		fullList.extend(wordList)</span><br><span class="line"></span><br><span class="line">		wordList=textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		classList.append(<span class="string">"1"</span>)</span><br><span class="line">		<span class="comment">#把所有单词加入到一个列表方便计数</span></span><br><span class="line">		fullList.extend(wordList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#1.构建词汇表</span></span><br><span class="line">	vocabList=createVocabList(docList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">##0000.增加的部分，将文本中高频出现的前30个单词从词汇表中去除</span></span><br><span class="line">	mostFreq=calcMostFreq(vocabList,fullList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#freq是键值对，[0]第0个代表单词，[1]第一个代表出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> freq <span class="keyword">in</span> mostFreq:</span><br><span class="line">		<span class="keyword">if</span> freq[<span class="number">0</span>] <span class="keyword">in</span> vocabList:</span><br><span class="line">			vocabList.remove(freq[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">#2.文本转换为单词向量</span></span><br><span class="line">	<span class="comment">#inputWord=[]</span></span><br><span class="line">	<span class="comment">#for i in range(2*minlen):</span></span><br><span class="line">	<span class="comment">#	inputWord[i]=bagOfWords2Vec(vocabList,docList[i])</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#3.随机选取20个作为测试集</span></span><br><span class="line">	trainingSet=list(range(<span class="number">2</span>*minlen))</span><br><span class="line">	testingSet=[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">		<span class="comment">#生成随机浮点数 random.uniform</span></span><br><span class="line">		testIndex=(int)(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">		testingSet.append(trainingSet[testIndex])</span><br><span class="line">		<span class="keyword">del</span>(trainingSet[testIndex])</span><br><span class="line"></span><br><span class="line">	<span class="comment">#将字符串转换为数字</span></span><br><span class="line">	classList=[int(x) <span class="keyword">for</span> x <span class="keyword">in</span> classList]</span><br><span class="line">	<span class="comment">#4.剩余的作为训练集，计算分类器的概率，用于分类</span></span><br><span class="line">	traingData=[]</span><br><span class="line">	traingLabels=[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> trainingSet:</span><br><span class="line">		<span class="comment">#2.文本转换为单词向量</span></span><br><span class="line">		traingData.append(bagOfWords2Vec(vocabList,docList[i]))</span><br><span class="line">		traingLabels.append(classList[i])</span><br><span class="line">	p0Vec,p1Vec,pAuixs=trainNB0(traingData,traingLabels)</span><br><span class="line">	<span class="comment">#5.对测试集进行测试</span></span><br><span class="line">	error=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> testingSet:</span><br><span class="line">		testingData=bagOfWords2Vec(vocabList,docList[i])</span><br><span class="line">		testResult=classfyNB(testingData,p0Vec,p1Vec,pAuixs)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(testResult!=classList[i]):</span><br><span class="line">			error+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	print(<span class="string">"the error rate is:"</span>+str((float)(error)/<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> vocabList,p0Vec,p1Vec</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>贝叶斯分类</tag>
      </tags>
  </entry>
  <entry>
    <title>监督学习笔记（一）——支持向量机</title>
    <url>/blogs/svm/</url>
    <content><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>（1）支持向量：支持向量机用于解决分类问题，当给出一组线性可分的数据时，此时可以得出一条直线将数据分隔开，要求这条直线即求出了分类的依据，当根据距离分隔线最近的点，取其距离的最大值就能得到最优分割的直线。其中距离分隔线最近的点称为支持向量。</p><p>（2）机：机是指该方法是一个分类器，会产生二值决策机。</p><p>（3）优点：支持向量机方法只使用支持向量，并没有用全部的数据点，所以内存方面优于knn。</p><a id="more"></a>


<p>（4）缺点：支持向量机一般用于线性可分的数据，当数据线性不可分时无法使用。对于复杂数据需要借助核函数，将复杂数据映射到高维空间进行处理</p>
<h2 id="求解的理论依据"><a href="#求解的理论依据" class="headerlink" title="求解的理论依据"></a>求解的理论依据</h2><p>（1）确定分隔平面和输出函数</p>
<p>分隔平面：wT*x+b，其中w和b描述了所给数据的分隔平面</p>
<p>因为是二值分类器，输出值是-1和+1，所以使用signmoid函数，当点到直线的距离f(wT*x+b)&gt;0时属于 +1类，反之属于-1类。</p>
<p>（2）求距离：</p>
<p>数据点到分隔平面的距离记为<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150346.png" alt="点到平面的几何距离"></p>
<p>要求得最佳分隔平面就要找到距离平面最佳的点的距离将其最大化，则为最佳分类，所以即求<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150600.png" alt="求解目标"></p>
<p>但是该目标函数求解困难，因此使用拉格朗日乘子法进行转换带约束调节的目标函数：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306150813.png" alt="转换函数"></p>
<p>其中约束条件为：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件"></p>
<p>因为实际数据不可能存在100%线性可分所以此时加上一个松弛变量，可以允许一些点在分隔平面的另一边，此时前一个约束条件变为0&lt;=alpha&lt;=C，这里的常数C确保点距离平面的最大间隔和所有数据点的函数间隔小于1.0（因为是支持向量）</p>
<p>（3）问题转换</p>
<p>根据（2）中转换后的目标函数和约束条件可以看出，SVM（支持向量机，以下均简称为SVM）的主要求解目标转换为求alpha的值，通过alpha可以表示分隔平面。</p>
<h2 id="使用的算法"><a href="#使用的算法" class="headerlink" title="使用的算法"></a>使用的算法</h2><p>由求解的理论依据中可知，SVM需要求解的目标为带有约束条件的函数，一般采用二次规划求解方法，但是计算复杂，这里使用platt SMO算法求解。</p>
<p>（1）算法思路：每次选择一对alpha进行优化，当找到合适的两个alpha后，需要增大一个减小另一个，因为需要满足约束条件：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306151016.png" alt="约束条件">，合适是指两个alpha值要在间隔边界之外，同时没有被区间化处理或者不在边界上</p>
<p>（2）基本算法流程：以简单smo算法为例</p>
<blockquote>
<p>#0.初始化alpha向量为0</p>
<p>#1.当迭代次数小于最大迭代次数（外循环）<br>    #2.对数据集中每个向量（内循环）<br>        #3.如果该向量可以被优化<br>            #4.随机找另一个向量<br>            #5.优化这两个向量<br>            #6.如果这两个向量不能被优化，跳出内循环</p>
<p>#7.如果所有向量都不能被优化，增加迭代次数，进行下一次的循环</p>
</blockquote>
<p>（3）完整platt smo 算法</p>
<p>platt smo算法在简化smo算法基础上提升时间，对数据量大的数据集执行时间大大减少。</p>
<p>相比于传统的二次规划求解方法，每次选取两个alpha进行优化，时间效率大幅提高。</p>
<p>算法流程：</p>
<blockquote>
<p>#外循环 使用两种方式交替得到第一个alpha的值</p>
<p>#1.0 对所有数据点进行遍历扫描</p>
<p>#2.0 对非边界值即0&lt;alpha并且alpha&gt;c的alpha进行扫描</p>
<p>#内循环 采用最大化步长的方式得到第二个alpha的值</p>
</blockquote>
<h2 id="核函数的引入"><a href="#核函数的引入" class="headerlink" title="核函数的引入"></a>核函数的引入</h2><p>当面对非线性数据的时候，需要使用核函数，将复杂数据映射到高维空间，此时分类器易于理解，即可使用SVM方法。</p>
<p>主要使用径向基函数的高斯版本：<img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200306155004.png" alt="径向基函数"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X,A,kTup=<span class="params">()</span>)</span>:</span></span><br><span class="line">  m=shape(X)[<span class="number">0</span>]</span><br><span class="line">  K=zeros((m,<span class="number">1</span>))</span><br><span class="line">  <span class="comment">#对核函数的第一个参数进行不同情况的讨论</span></span><br><span class="line">  <span class="comment">#1.线性核</span></span><br><span class="line">  <span class="keyword">if</span>(kTup[<span class="number">0</span>]=<span class="string">"lin"</span>):</span><br><span class="line">    K=X*A.T</span><br><span class="line">  <span class="comment">#2.径向基核</span></span><br><span class="line">  <span class="keyword">elif</span>(kTup[<span class="number">0</span>]=<span class="string">"rbf"</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">      delta=X[i,:]-A</span><br><span class="line">      K[i]=delta*delta.T</span><br><span class="line">     K=exp(K/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))      </span><br><span class="line">  <span class="comment">#3.抛出异常</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError()</span><br><span class="line">  <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h2 id="应用实例——手写数字识别"><a href="#应用实例——手写数字识别" class="headerlink" title="应用实例——手写数字识别"></a>应用实例——手写数字识别</h2><p>识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</p>
<p>（1）将图像转换为向量</p>
<p>（2）读取文件夹列表中各个图像文件</p>
<p>（3）处理分类问题</p>
<p>为方便处理，只保留了1和9两个数字，当是数字1时，分类为+1，当是数字9时分类为-1</p>
<blockquote>
<p>#1.读入图像转换后的数据向量和标签属性</p>
<p>#2.调用platt smo算法得出alpha和b的值</p>
<p>#3.根据支持向量大于0的特性得出其中alpha&gt;0的支持向量，并得出支持向量的数据点和标签数据</p>
<p>#4.在训练集上得出分类结果</p>
<p>#5.将分类的结果应用于测试集</p>
</blockquote>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#plat smo可以处理数据量大的，上面simplesmo只能处理数据量较小的数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#platsmo的支持函数</span></span><br><span class="line"><span class="comment">#建立一个对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line">	<span class="comment">#各种变量初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMat,lableMat,C,toler,kTup)</span>:</span><span class="comment">#增加核函数初始化参数</span></span><br><span class="line">		self.dataMat=dataMat</span><br><span class="line">		self.lableMat=lableMat</span><br><span class="line">		self.C=C</span><br><span class="line">		self.toler=toler</span><br><span class="line">		self.m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">		self.alpha=mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">		self.b=<span class="number">0</span></span><br><span class="line">		self.echache=mat(zeros((self.m,<span class="number">2</span>)))<span class="comment">#第一列表示cache是否有效，第二列是实际的E（误差）值</span></span><br><span class="line">		<span class="comment">#构建k</span></span><br><span class="line">		self.k=mat(zeros((self.m,self.m)))</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">			<span class="comment">#调用函数，填充k</span></span><br><span class="line">			self.k[:,i]=kernelTras(self.dataMat,self.dataMat[i,:],kTup)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存误差缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEK</span><span class="params">(oS,ke)</span>:</span></span><br><span class="line">	fk=float(multiply(oS.alpha,oS.lableMat).T*oS.k[:,ke]+oS.b)</span><br><span class="line">	EK=fk-float(oS.lableMat[ke])</span><br><span class="line">	<span class="keyword">return</span> EK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算误差，并且存入缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEK</span><span class="params">(oS,k)</span>:</span></span><br><span class="line">	EK=calcEK(oS,k)</span><br><span class="line">	oS.echache[k]=[<span class="number">1</span>,EK]</span><br><span class="line"></span><br><span class="line"><span class="comment">#内循环中的启发方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择第二个alpha值，保证每次优化都是最大的步长，如果是第一次进入循环就先随机选择一个alpha[j],反之进入循环，根据最大步长选择alpha[j]的值</span></span><br><span class="line"><span class="comment">#alphaj的值和前一个alphai的下标和误差Ei有关</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i,oS,Ei)</span>:</span></span><br><span class="line">	maxk=<span class="number">-1</span></span><br><span class="line">	maxDeltaE=<span class="number">0</span></span><br><span class="line">	Ej=<span class="number">0</span></span><br><span class="line">	oS.echache[i]=[<span class="number">1</span>,Ei]</span><br><span class="line">	<span class="comment">#输入列表为目标的列表值，nozero返回不为空的值即非零alpha值</span></span><br><span class="line">	validDeltaList=nonzero(oS.echache[:,<span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span> (len(validDeltaList))&gt;<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> validDeltaList:</span><br><span class="line">			<span class="keyword">if</span>(k==i):</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			Ek=calcEK(oS,k)</span><br><span class="line">			delta=abs(Ek-Ei)</span><br><span class="line">			<span class="keyword">if</span>(delta&gt;maxDeltaE):</span><br><span class="line">				maxk=k</span><br><span class="line">				maxDeltaE=delta</span><br><span class="line">				Ej=Ek</span><br><span class="line">		<span class="keyword">return</span> maxk,Ej</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		j=selectRandom(i,oS.m)</span><br><span class="line">		Ej=calcEK(oS,j)</span><br><span class="line">	<span class="keyword">return</span> j,Ej</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerI</span><span class="params">(oS,i)</span>:</span></span><br><span class="line">	exi=calcEK(oS,i)</span><br><span class="line">	<span class="keyword">if</span> ((oS.lableMat[i]*exi&lt;-oS.toler) <span class="keyword">and</span> (oS.alpha[i]&lt;oS.C)) <span class="keyword">or</span> ((oS.lableMat[i]*exi&gt;oS.toler) <span class="keyword">and</span> (oS.alpha[i]&gt;<span class="number">0</span>)):</span><br><span class="line">		<span class="comment">#1.3启发式找另一个向量</span></span><br><span class="line">		j,exj=selectJ(i,oS,exi)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#1.4优化这两个向量</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">#记录旧的，看优化之后有无变换</span></span><br><span class="line">		alphaJold=oS.alpha[j].copy()</span><br><span class="line">		alphaIold=oS.alpha[i].copy()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(oS.lableMat[i]!=oS.lableMat[j]):</span><br><span class="line">			L=max(<span class="number">0</span>,oS.alpha[j]-oS.alpha[i])</span><br><span class="line">			H=min(oS.C,oS.C+oS.alpha[j]-oS.alpha[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			L=max(<span class="number">0</span>,oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line">			H=min(oS.C,oS.C+oS.alpha[j]+oS.alpha[i]-oS.C)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(L==H):</span><br><span class="line">			print(<span class="string">"L==H"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">#最优修改量</span></span><br><span class="line">		<span class="comment">#eta=2.0*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line">		<span class="comment">#使用核函数之后，修正eta的值</span></span><br><span class="line">		eta=<span class="number">2.0</span>*oS.k[i,j]-oS.k[i,i]-oS.k[j,j]</span><br><span class="line">		<span class="keyword">if</span>(eta&gt;=<span class="number">0</span>):</span><br><span class="line">			print(<span class="string">"eta&gt;=0"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		oS.alpha[j]-=oS.lableMat[j]*(exi-exj)/eta</span><br><span class="line">		oS.alpha[j]=adjustBig(oS.alpha[j],H,L)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#将j的更新存到缓存</span></span><br><span class="line">		updateEK(oS,j)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#优化j之后无变换</span></span><br><span class="line">		<span class="keyword">if</span> abs(alphaJold-oS.alpha[j])&lt;<span class="number">0.00001</span>:</span><br><span class="line">			print(<span class="string">"alphaJold-alpha[j])&lt;0.00001"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">#优化j有变化，接着优化i</span></span><br><span class="line">		oS.alpha[i]+=oS.lableMat[j]*oS.lableMat[i]*(alphaJold-oS.alpha[j])</span><br><span class="line"></span><br><span class="line">		<span class="comment">#将i的更新存到缓存</span></span><br><span class="line">		updateEK(oS,i)</span><br><span class="line"></span><br><span class="line">		<span class="comment">#设置偏置量</span></span><br><span class="line">		<span class="comment">#b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[i,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[i,:]*oS.dataMat[j,:].T</span></span><br><span class="line">		<span class="comment">#b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.dataMat[i,:]*oS.dataMat[j,:].T-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.dataMat[j,:]*oS.dataMat[j,:].T</span></span><br><span class="line">		<span class="comment">#使用核函数之后，修正b1,b2的值</span></span><br><span class="line">		b1=oS.b-exi-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,i]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[i,j]</span><br><span class="line">		b2=oS.b-exj-oS.lableMat[i]*(oS.alpha[i]-alphaIold)*oS.k[i,j]-oS.lableMat[j]*(oS.alpha[j]-alphaJold)*oS.k[j,j]</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> oS.alpha[i]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[i]&lt;oS.C:</span><br><span class="line">			oS.b=b1</span><br><span class="line">		<span class="keyword">elif</span> oS.alpha[j]&gt;<span class="number">0</span> <span class="keyword">and</span> oS.alpha[j]&lt;oS.C:</span><br><span class="line">			oS.b=b2</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			oS.b=(b1+b2)/<span class="number">2.0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#完整的platt smo 外循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn,labelArr,C,toler,maxIter,kTup=<span class="params">(<span class="string">"lin"</span>,<span class="number">0</span>)</span>)</span>:</span></span><br><span class="line">	<span class="comment">#0.相关变量初始化</span></span><br><span class="line">	oS=optStruct(mat(dataMatIn),mat(labelArr).transpose(),C,toler,kTup)</span><br><span class="line"></span><br><span class="line">	entireSet=<span class="literal">True</span></span><br><span class="line">	alphaChange=<span class="number">0</span></span><br><span class="line">	iter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#1.主循环</span></span><br><span class="line">	<span class="keyword">while</span> (iter&lt;maxIter) <span class="keyword">and</span> ((alphaChange&gt;<span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">		alphaChange=<span class="number">0</span></span><br><span class="line">		<span class="comment">#1.选择第一个alpha的两种循环</span></span><br><span class="line">		<span class="comment">#1.0对所有数据集进行遍历</span></span><br><span class="line">		<span class="keyword">if</span>(entireSet):</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):</span><br><span class="line">				alphaChange+=innerI(oS,i)</span><br><span class="line">				print(<span class="string">"fullset: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line">			iter+=<span class="number">1</span></span><br><span class="line">		<span class="comment">#1.1对非边界值进行遍历</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			nonBoundIs=nonzero((oS.alpha.A&gt;<span class="number">0</span>)*(oS.alpha.A&lt;C))[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">				alphaChange+=innerI(oS,i)</span><br><span class="line">				print(<span class="string">"nonbound: iter:"</span>+str(iter)+<span class="string">" i:"</span>+str(i)+<span class="string">" alphaChange:"</span>+str(alphaChange))</span><br><span class="line"></span><br><span class="line">			iter+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(entireSet):</span><br><span class="line">			entireSet=<span class="literal">False</span></span><br><span class="line">		<span class="keyword">elif</span>(alphaChange==<span class="number">0</span>):</span><br><span class="line">			entireSet=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> oS.alpha,oS.b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用求得的alpha值求得分类的超平面，其中可以求出w的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcW</span><span class="params">(alpha,dataMatIn,labelArr)</span>:</span></span><br><span class="line">	dataMat=mat(dataMatIn)</span><br><span class="line">	lableMat=mat(labelArr).transpose()</span><br><span class="line">	m,n=shape(dataMat)</span><br><span class="line">	w=zeros((n,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#其中起作用的只有支持向量，即不为0的alpha</span></span><br><span class="line">		w+=multiply((alpha[i]*lableMat[i]),dataMat[i,:].T)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在复杂数据上使用核函数</span></span><br><span class="line"><span class="comment">#将数据从一个特征空间映射到另一个空间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTras</span><span class="params">(X,A,kTup)</span>:</span></span><br><span class="line">	m,n=shape(X)</span><br><span class="line">	k=zeros((m,<span class="number">1</span>))</span><br><span class="line">	<span class="comment">#根据ktup的第一个参数来求核函数的值</span></span><br><span class="line">	<span class="keyword">if</span>(kTup[<span class="number">0</span>]==<span class="string">"lin"</span>):</span><br><span class="line">		k=X*A.T</span><br><span class="line">	<span class="keyword">elif</span>(kTup[<span class="number">0</span>]==<span class="string">"rbf"</span>):</span><br><span class="line">		<span class="comment">#对每个元素计算高斯值</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">			deltaRow=X[j,:]-A</span><br><span class="line">			k[j]=deltaRow*deltaRow.T</span><br><span class="line">		k=exp(k/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))</span><br><span class="line">	<span class="comment">#若元祖无法识别，则抛出异常</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">raise</span> NameError(<span class="string">"the keneral name wrong"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="comment">#识别手写字——使用svm比knn效率高，占内存小，因为svm只需用到支持向量来进行分类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.将图像转换为向量——将32*32的图像转换为1*1024的向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="comment">#0.构造转换后返回的向量</span></span><br><span class="line">	returnVect=zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">	<span class="comment">#1.处理图像</span></span><br><span class="line">	fr=open(filename)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32行的</span></span><br><span class="line">		lineArr=fr.readline() <span class="comment">#每次读入一行</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):<span class="comment">#因为图像是32列的</span></span><br><span class="line">			returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j]=int(lineArr[j])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.从文件夹中读入所有图片信息并存储为向量和标签——,为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImage</span><span class="params">(dirname)</span>:</span></span><br><span class="line">	<span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line">	<span class="comment">#0.用于存储标签</span></span><br><span class="line">	hwLabels=[]</span><br><span class="line"></span><br><span class="line">	<span class="comment">#1.用于存储数据向量</span></span><br><span class="line">	<span class="comment">#得到文件夹下图像名称的列表 例：1_20.txt</span></span><br><span class="line">	trainDirList=listdir(dirname)</span><br><span class="line">	m=len(trainDirList)</span><br><span class="line">	<span class="comment">#用于存储数据向量</span></span><br><span class="line">	trainMat=zeros((m,<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#2.处理图像文件中的内容</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#图像文件完整名称</span></span><br><span class="line">		fullName=trainDirList[i]</span><br><span class="line">		<span class="comment">#图像文件去除后缀后的名称</span></span><br><span class="line">		fileName=fullName.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line">		<span class="comment">#图像文件去除下划线后的名称</span></span><br><span class="line">		className=int(fileName.split(<span class="string">"_"</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#为方便，只保留了1和9两个数字，出现1的标签记为1，出现9的标签记为-1</span></span><br><span class="line">		<span class="keyword">if</span>(className==<span class="number">1</span>):</span><br><span class="line">			hwLabels.append(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			hwLabels.append(<span class="number">-1</span>)</span><br><span class="line">		<span class="comment">#将图像文件中的内容转换为向量进行存储</span></span><br><span class="line">		trainMat[i,:]=img2vector(<span class="string">"%s/%s"</span>%(dirname,fullName))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> trainMat,hwLabels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.使用核函数进行分类测试的径向基函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup=<span class="params">(<span class="string">"rbf"</span>,<span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">	dataMatIn,labelArr=loadImage(<span class="string">"trainingDigits"</span>)</span><br><span class="line">	dataMat=mat(dataMatIn)</span><br><span class="line">	lableMat=mat(labelArr).transpose()</span><br><span class="line">	m,n=shape(dataMat)</span><br><span class="line">	<span class="comment">#根据platt smo算法得到alpha,b的值</span></span><br><span class="line">	alpha,b=smoP(dataMatIn,labelArr,<span class="number">200</span>,<span class="number">0.0001</span>,<span class="number">10000</span>,kTup)</span><br><span class="line">	print(alpha[alpha&gt;<span class="number">0</span>])</span><br><span class="line">	print(b)</span><br><span class="line">	<span class="comment">#得到支持向量</span></span><br><span class="line">	sVInd=nonzero(alpha.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">	sVs=dataMat[sVInd]</span><br><span class="line">	sVlabel=lableMat[sVInd]</span><br><span class="line">	print(<span class="string">"tere are "</span>+str(shape(sVs)[<span class="number">0</span>])+<span class="string">" support vectors"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#在训练集上使用核函数</span></span><br><span class="line">	error=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">		precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line">		<span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">			error+=<span class="number">1</span></span><br><span class="line">	print(<span class="string">"train error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br><span class="line"></span><br><span class="line">	<span class="comment">#在测试集上使用核函数</span></span><br><span class="line">	dataMatIn,labelArr=loadImage(<span class="string">"testDigits"</span>)</span><br><span class="line">	dataMat=mat(dataMatIn)</span><br><span class="line">	lableMat=mat(labelArr).transpose()</span><br><span class="line">	m=shape(dataMat)[<span class="number">0</span>]</span><br><span class="line">	error=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		kernel=kernelTras(sVs,dataMat[i,:],kTup)</span><br><span class="line">		precdit=kernel.T*multiply(sVlabel,alpha[sVInd])+b</span><br><span class="line">		<span class="keyword">if</span>(sign(precdit)!=sign(lableMat[i])):</span><br><span class="line">			error+=<span class="number">1</span></span><br><span class="line">	print(<span class="string">"test error rate: "</span>+str(float(error)/m)+<span class="string">"——————"</span>+str(error))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>Leecode算法学习笔记（四）</title>
    <url>/blogs/movStateNote/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>（1）明确状态含义</p><p>首先要明确dp[i]的含义，例如在求分割回文字符串的次数中，dp[i]表示i个回文字符串的分割次数</p><p>（2）确定初始状态</p><p>可以考虑最多…的时候dp的状态</p><p>例如求分割回文字符串的次数，初始状态即为i个字符串最多分割i次</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求分割回文字符串的次数</span></span><br><span class="line"><span class="comment">//初始状态</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">  dp[i]=i;</span><br><span class="line"><span class="comment">//i个字符串，最多分割i次</span></span><br></pre></td></tr></table></figure><a id="more"></a>






<p>（3）确定状态转移方程</p>
<p>假设已知dp[i]的状态，列出dp[i+1]和dp[i]之间的关系式，即为状态转移方程</p>
<p>明确目标：要求dp{i]的值</p>
<p>例如求分割回文字符串的次数，其中状态转移方程如下：</p>
<p>当i从1变化到len之间，求dp[i]。当0~i本身是回文时，不需要分割，即dp[i]=0。该题dp[i+1]和dp[i]之间没有明确联系，可以从分割边界考虑。假设分割边界为j，已知dp[j]，求dp[i]，就需要分两种情况考虑</p>
<p>a）j+1~i之间是回文，那么dp[j]再分割一次就可以得到j之前的字符串和后面的回文，即dp[i]=dp[j]+1，但dp[i]有可能更小，所以dp[i]在dp[i]和dp[j]+1之间取小的</p>
<p>b）j+1~i之间不是回文，继续移动j，找到符合回文的子串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>~i是回文)</span><br><span class="line">    dp[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(j+<span class="number">1</span>~i是回文)</span><br><span class="line">      dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）最终输出</p>
<p>一般输出为dp[len-1]，例如在求分割回文字符串的次数中，最终是求len个字符串的分割次数，即求dp[len-1]</p>
<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p>（1）明确状态含义</p>
<p>股票有三种状态：买入，卖出，休息（不买入也不卖出）    最终状态为持有股票设置为0，不持有股票1</p>
<p>转换关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200304222109.png" alt="stock"></p>
<p>设置dp[i] [k] [s]表示第天股票的持有情况，k表示至今最多进行k笔交易，整个数组表示可以得到的最大利润</p>
<p>（2）确定状态转移方程</p>
<p>转换关系中就两种状态，因此分别考虑两种情况下的转移方程：</p>
<p>a）今天持有股票，即求dp[i] [k] [1]</p>
<p>持有股票有两种情况，一种是前一天本来就有股票，并且今天休息，即dp[i-1] [k] [1]；另一种是前一天没有股票，今天购入了，此时前一天进行了k-1笔交易，买入股票，说明利润减少，需要减掉买入的价格,即dp[i-1] [k-1] [0]-price[i]</p>
<p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i])</p>
<p>b）今天不持有股票，即求dp[i] [k] [0]</p>
<p>不持有股票也有两种情况，一种是前一天本来就没有股票，并且今天休息，即dp[i-1] [k] [0]；另一种是前一天有股票，今天卖出了，卖出股票，说明利润增加，需要加上卖出的价格,即dp[i-1] [k] [1]+price[i]</p>
<p>综上，求利润最大，即求两种情况的最大者，dp[i] [k] [0]=max(dp[i-1] [k] [0]]，dp[i-1] [k] [1]+price[i])</p>
<p>综合a和b，可以得出状态转移方程</p>
<p>（3）确定初始状态</p>
<p>因为状态转移方程中只有两个最终状态，所以对两个最终状态的初始情况进行讨论：</p>
<p>a）刚开始没有持有股票时，没有利润，即dp[0] [0]=0</p>
<p>b）刚开四持有股票，之前没有利润，亏损买入的价格，即dp[0] [1]=-price[0]</p>
<p>（4）最终输出</p>
<p>最后一天利润是最大的，此时不持有股票的利润肯定大于持有的，即dp[len-1] [k] [0]&gt;dp[len-1] [k] [1]，所以选择dp[len-1] [k] [1]</p>
<p>（5）实际应用</p>
<p>a）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p>
<p>此时k=1，代入方程得</p>
<p>dp[i] [1] [1]=max(dp[i-1] [1] [1]，dp[i-1] [0] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p>
<p>dp[i] [1] [0]=max(dp[i-1] [1] [0]，dp[i-1] [1] [1]+price[i])</p>
<p>可以看出，方程中k=1对转换无影响，所以省去k</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>此时k=无穷，那么k的值和k-1的值近似一样，因此k同样可以省略，此时的方程为</p>
<p>dp[i] [1]=max(dp[i-1] [1]，dp[i-1] [0]-price[i]) 其中dp[i-1] [0]不可以省略，因为其值已经不等于0</p>
<p>dp[i] [0]=max(dp[i-1] [0]，dp[i-1]  [1]+price[i])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始状态</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>]=-price[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]，dp[i<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">  dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]，dp[i<span class="number">-1</span>][<span class="number">1</span>]+price[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c）给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>此时k从1变换到2，不为0是因为要有利润至少会有一笔交易，此时代码中将多一重循环</p>
<p>dp[i] [k] [1]=max(dp[i-1] [k] [1]，dp[i-1] [k-1] [0]-price[i]) 其中dp[i-1] [0] [0]=0</p>
<p>dp[i] [k] [0]=max(dp[i-1] [k] [0]，dp[i-1] [k] [1]+price[i])</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转移方程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//定义初始状态</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//刚开始时，不持有股票，利润为0</span></span><br><span class="line">      dp[i][k][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//刚开始时，持有股票，利润为亏损买入对应的股票</span></span><br><span class="line">      dp[i][k][<span class="number">1</span>]=-price[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][k][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">1</span>]，dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]-price[i]);</span><br><span class="line">    dp[i][k][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][k][<span class="number">0</span>]，dp[i<span class="number">-1</span>][k][<span class="number">1</span>]+price[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下搭建和使用mve</title>
    <url>/blogs/useMVE/</url>
    <content><![CDATA[<p>mve可以将多角度的图片序列重构成三维点云</p><h2 id="搭建mve"><a href="#搭建mve" class="headerlink" title="搭建mve"></a>搭建mve</h2><p>搭建过程参照官方文档<a href="https://github.com/simonfuhrmann/mve" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/simonfuhrmann/mve</a></p><p>以下均在终端进行操作</p><p>1.从github上下载代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/simonfuhrmann/mve.git</span><br></pre></td></tr></table></figure><p>下载之后会在根目录建立mve文件夹</p><a id="more"></a>






<p>2.进入mve文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd mve</span><br></pre></td></tr></table></figure>

<p>进行编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>3.添加依赖库</p>
<p>编译过程中报错，是因为缺少依赖库，需要手动安装。主要是对图片处理的函数库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libjpeg</span><br><span class="line">brew install libpng</span><br><span class="line">brew install libtiff</span><br></pre></td></tr></table></figure>

<p>此时就能成功编译，打开mve下的apps文件夹，当所有的文件夹下生成了”.o”后缀的文件，说明环境已经搭建好。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.在官网下载数据集</p>
<p><a href="http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/" target="_blank" rel="external nofollow noopener noreferrer">http://download.hrz.tu-darmstadt.de/media/FB20/GCC/mve_datasets/</a></p>
<p>我选择的是der_hass-20140923数据集，里面包含雕像不同角度的79张图像，下载后进行解压</p>
<p>2.设置环境变量</p>
<p>生成点云过程中是使用apps下中的子文件夹实现，所以需要设置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入根目录</span><br><span class="line">cd ~</span><br><span class="line">#给任意一个文件添加环境变量</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>输入vim命令后，进入输入环境变量页面，输入“O”，进入写模式，将apps下所有文件夹路径加入环境变量中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=/Users/mve/apps/bundle2pset:$PATH</span><br><span class="line">#以下省略</span><br></pre></td></tr></table></figure>

<p>输入结束后，按esc，在文末输入”:wq”，退出并保存环境变量</p>
<p>生效环境变量，将环境变量应用到下载好的数据集下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source 数据集路径名称</span><br></pre></td></tr></table></figure>

<p>查看环境变量是否生效，在数据集文件夹下打开终端，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<p>当环境变量中包含了apps下文件夹的路径，说明环境变量设置成功</p>
<p>3.重建三维生成点云</p>
<p>der_hass-20140923是下载的数据集，der_hass是生成数据所在的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makescene -i der_hass-20140923 der_hass</span><br></pre></td></tr></table></figure>

<p>按以下命令一个个运行，der_hass是生成的散文图所在的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sfmrecon der_hass</span><br><span class="line">dmrecon -s2 der_hass</span><br><span class="line">scene2pset -F2 der_hass der_hass/pset-L2.ply</span><br><span class="line">fssrecon der_hass/pset-L2.ply der_hass/surface-L2.ply</span><br><span class="line">meshclean -t10 der_hass/surface-L2.ply der_hass/surface-L2-clean.ply</span><br></pre></td></tr></table></figure>

<p>运行过程比较慢，需要耐心等待，大约需3小时左右，最终生成的点云文件为surface-L2-clean.ply</p>
<p>4.效果展示</p>
<p>使用meshlab打开点云文件，效果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200120193729.png" alt="效果图"></p>
<p>可以看出生成的点云完整，不存在不连续的部分，实现了从图像-&gt;稀疏点云-&gt;稠密点云-&gt;点云表面重建的全过程。</p>
]]></content>
      <categories>
        <category>点云</category>
      </categories>
      <tags>
        <tag>mve</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title>Leecode算法学习笔记（三）</title>
    <url>/blogs/listbNote/</url>
    <content><![CDATA[<h2 id="关于链表的算法"><a href="#关于链表的算法" class="headerlink" title="关于链表的算法"></a>关于链表的算法</h2><p>链表节点的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表常用算法思想包括：快慢指针（对空间复杂度有要求，可以考虑使用快慢指针）</p><a id="more"></a>



<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>新建两个指针，快指针走两步，慢指针走一步</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针法只使用两个指针，空间复杂度很小，只有O(1)</span></span><br><span class="line">ListNode* fast=head;<span class="comment">//快指针</span></span><br><span class="line">ListNode* slow=head;<span class="comment">//慢指针</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//慢指针走一步</span></span><br><span class="line">  slow=slow-&gt;next;</span><br><span class="line">  <span class="comment">//快指针走两步</span></span><br><span class="line">  fast=fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>环形链表（判断链表中是否存在环）：</p>
<p>（1）判断有无环：可以利用快慢指针，如果存在环，那么在某一个链表节点快指针指向的节点就等于慢指针指向的节点（是节点整体相等，包括val和next，不能只用val判断），反之，则不存在环，整体问题抽象成追赶问题，因为存在环，所以一定能追赶上。</p>
<p>（2）求环的入口节点：当需要求环形入口节点的时候，首先将判断有无环，在相遇的时候break，此时假设链表中无环部分长度为a，环长度b，相遇时快指针比慢指针走了n个环长度，f=s+nb，又因为f=2s，所以s=nb，慢指针要走到环入口，需要长度为a+nb，所以慢指针需要再走a个长度，此时将fast设置为head，从head走到环入口长度正好为a，当两个指针指向相同链节点的时候，就到达了环的入口</p>
<h2 id="关于括号的算法"><a href="#关于括号的算法" class="headerlink" title="关于括号的算法"></a>关于括号的算法</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="comment">//用map存储括号的键值对</span></span><br><span class="line">unorder_map&lt;<span class="keyword">char</span>&gt; <span class="built_in">map</span>&#123;&#123;<span class="string">')'</span>,<span class="string">'('</span>&#125;,&#123;&#125;&#125;;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//用栈存储读入的字符</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span>(字符串不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(当字符是左半边括号时)</span><br><span class="line">    左括号入栈；</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    [</span><br><span class="line">    <span class="comment">//取栈顶元素</span></span><br><span class="line">    q=s.top();</span><br><span class="line">    <span class="keyword">if</span>(栈顶元素==<span class="built_in">map</span>[q])</span><br><span class="line">      出栈</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      未能匹配上</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//先出栈，当出栈后栈为空，说明当前右括号前面没有匹配的左括号，此时右括号入栈作为一个位置标记，计算后面的长度，如果在else里出栈，那么会面临出栈后，s.top()不存在的现象</span></span><br><span class="line">      s.pop();</span><br><span class="line">      <span class="comment">//栈为空，存入当前括号</span></span><br><span class="line">      <span class="keyword">if</span>(s.empty())</span><br><span class="line">      	s.push(i)</span><br><span class="line">      <span class="comment">//栈不为空，获得长度</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        length=<span class="built_in">max</span>(length,i-s.top())</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>有效的括号（给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。）：在map中存储括号的键值对，利用map[值]=键，每次读入字符串的字符时，如果是左边括号就入栈，否则就是右边括号，需要进行检测是否配对，取这时栈顶的括号，如果键值对匹配上，则出栈，检测下一个，否则是没有匹配上。</p>
<p>最长有效括号（给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。）：</p>
<p>（1）初始化：用栈来存储括号，栈里保存括号位置的下标，为了保证获取长度，初始化栈为-1。</p>
<p>（2）当扫描到左括号的时候，入栈，当扫描到右括号的时候，此时将栈顶元素出栈，分为两种情况，一种是当栈为空的时候，说明之前没有匹配的左括号，把当前括号入栈，另一种栈不为空，说明有匹配的左括号，用当前位置减去栈顶的位置，并更新长度</p>
<h3 id="深度遍历-剪枝"><a href="#深度遍历-剪枝" class="headerlink" title="深度遍历+剪枝"></a>深度遍历+剪枝</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入参数为当前由括号组成的路径，左子树括号的个数，右子树括号的个数，以及最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt;&gt; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件,此时出现了一条满足条件的路径:左右子树的括号个数都为0</span></span><br><span class="line">  <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)</span><br><span class="line">    res.push(str)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//剪枝：左子树的括号个数大于右子树的括号个数,出现不匹配</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//左边括号多，先生成左括号</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'('</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">  <span class="comment">//右边括号多，再生成右括号</span></span><br><span class="line">  <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">    dfs(str+<span class="string">'）'</span>,left<span class="number">-1</span>,right,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>括号的生成（给出 n 代表生成括号的对数，写出一个函数，使其能够生成所有可能的并且有效的括号组合）：实质是对括号做减法，当左括号数量大于0，就不断生成左括号，右括号数量大于0，生成右括号，但是存在不满足括号匹配的条件，当左括号数量大于右括号，此时需要剪枝（加一个判断条件，return）,当左右括号数量都为0，说明找到了一个合适的路径，将其存储下来。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>括号</tag>
      </tags>
  </entry>
  <entry>
    <title>Leecode算法学习笔记（二）</title>
    <url>/blogs/backTrackNote/</url>
    <content><![CDATA[<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯一般用于找到满足要求的的所有解，即相当于构造一棵树，从跟节点出发，找到满足条件的所有路径，并进行保存，当目前的路径不符合条件的时候，需要回溯，即剪枝，删除不符合的分支，当到达结束的条件时，即找到了一个满足条件的解，再继续构造下一个符合条件的路径。</p><p>常用于解决树种求得所有解的问题和排列组合中求解问题，或者问题可以转换为求树中一条路径的问题，可以画图。</p><a id="more"></a>

<h3 id="关于树的回溯"><a href="#关于树的回溯" class="headerlink" title="关于树的回溯"></a>关于树的回溯</h3><p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//result存储最终结果，res存储中间结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&gt; result,<span class="built_in">vector</span> res，….)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//处理当前节点</span></span><br><span class="line">   res.push(root-&gt;val)</span><br><span class="line"></span><br><span class="line">   …</span><br><span class="line"></span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（一般是值相等）并且到达根节点)</span><br><span class="line">  	result.push(res)</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;left,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">  &#123;</span><br><span class="line">    doTree(root-&gt;right,其他参数)</span><br><span class="line">    <span class="comment">//不满足条件，需要回溯</span></span><br><span class="line">    res.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>应用场景：</p>
<p>找到所有满足目标节点的路径：每次把当前节点加入，并将目标值减去当前节点的值，判断当前叶子节点值（左右子树为空）与0是否相等，相等，则找到一个满足的结果，否则，继续对左右子树递归，此时若存在不满足条件的，需要回溯（pop）</p>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p>排列组合求所有符合问题的解，基本框架：</p>
<p>组合问题按顺序读取，不需要设置used数组，排列问题则需要设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件：找到满足要求的一个解</span></span><br><span class="line">  <span class="keyword">if</span>(满足值为<span class="number">0</span>或者其他条件)</span><br><span class="line">  &#123;</span><br><span class="line">    result.push(res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;数组长度&amp;&amp;target-num[i]&gt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//避免重复元素得出重复组合</span></span><br><span class="line">      <span class="keyword">if</span>(i&gt;start&amp;&amp;num[i]==num[i<span class="number">-1</span>])</span><br><span class="line">      	<span class="keyword">continue</span>;</span><br><span class="line">    ]</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//全排列中不能使用上一层使用的元素</span></span><br><span class="line">      <span class="comment">//设置标志位或者其他判断条件</span></span><br><span class="line">      <span class="keyword">if</span>(!use[i])&#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//当时排列问题，并且有重复数字的时候，需要将上面两个条件结合</span></span><br><span class="line">    <span class="comment">//选择当前节点</span></span><br><span class="line">    res.push(num[i]);</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//选择了该节点，需要设置标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//[可以重复使用]</span></span><br><span class="line">    dfs(i,target-num[i]);</span><br><span class="line">    [<span class="comment">//不可以重复使用</span></span><br><span class="line">    [dfs(i+<span class="number">1</span>,target-num[i]);</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">//回溯，取消当前选择，返回上一层</span></span><br><span class="line">    res.pop();</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">//撤销选择，需要还原标志位</span></span><br><span class="line">      used[i]=<span class="literal">true</span>;</span><br><span class="line">    ]</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 应用场景：</p>
<p>组合求和（数组元素内部不重复，在数组中找到和为目标值的组合）：首先对数组排序，排序能更方便去重。在dfs函数中，每次传入数组中数据的位置和目标值，当剩余值大于等于0，进入循环，将当前数组值存入路径中，再继续递归，做下一次决策，由于可重复，所以下一次可以仍然从i开始，当满足条件时，将当前路径存入结果，此时回溯到上一层，继续寻找合适的路径。</p>
<p>组合求和（数组元素内部可能有重复，在数组中找到和为目标值的组合，此时不能重复使用数组的元素，解集不能包含重复的组合）：思路同上，因为不能重复使用数组元素，所以在for循环中dfs函数传值只鞥从i+1开始。与此同时，由于解集不能包含重复的组合，所以在排序后数组，当前一个数组元素和当前数组元素相同，那么当前元素得出的路径和上一个元素必定相同，因此这时需要跳过当前元素，对下一个元素处理。</p>
<p>全排列（给定一个没有重复数字的序列，返回其所有可能的全排列）：排列题是上一次选择的节点，这次不能再选择。每一层都可以选择一个未出现的元素，需要对数组元素设置标志位，当使用过，就将标志位置为1，此时也需要在for循环中加一层判断，查看当前数组是否被使用，当使用过时，需要跳过该元素，下一层继续选择，找到一个合适的结果后存储下来，接着撤销本次选择，返回上一层查看是否有其他结果。</p>
<p>全排列（给定一个可包含重复数字的序列，返回所有不重复的全排列）：思路同上，此时需要额外加个判断，看是否有重复的数字，有重复的数字则跳过。具体为：本次节点与前一个相同，并且前一个已使用过，说明已有相同的排列，则本次排列跳过。</p>
<p>n皇后问题：转换为全排列问题，在每一个的n个位置中选一个作为当前选择，n行做n个选择，并且是做做不重复的选择，正好构成一个排列，此时的排列满足不在同一行不在同一列，只要对当前的排列需要再满足题设条件即可，即不在主对角线，不在副对角线，vector<bool> master1;//副对角线和相同，都为i+j i为行，j为列，两者相加和是当前行，vector<bool> master2;//主对角线差相同，为i-j+n-1 i为行，j为列，再设置两个标志位进行判断，最后将得到的排列用题目中格式打印出来作为结果。</bool></bool></p>
<p>子集（给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集））：对不同子集个数进行深度遍历，此时需要在主函数中加一个循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>;i++)<span class="comment">//i的长度为0~nums.size(),所以需要加一</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//----通过i控制子集大小</span></span><br><span class="line">  dfs(start,i);</span><br><span class="line">  <span class="comment">//start是从数组中取元素的开始的位置，i是深度，即子集中元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分割字符串（给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串）：每次判断当前的起始至末尾位置是否是回文，如果是就将结果压入res，继续递归。通过不断变换分割的位置，来构造决策树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(start~i之间不是回文)</span><br><span class="line">    继续找下一个回文的位置</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//start~i之间是回文，压入结果内</span></span><br><span class="line">    res.push(s.substr(start,start+i+<span class="number">1</span>))</span><br><span class="line">    <span class="comment">//继续看下一个分割位置</span></span><br><span class="line">    dfs(i+<span class="number">1</span>,depth)</span><br><span class="line">    <span class="comment">//撤销选择，回到上一层决策</span></span><br><span class="line">    res.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leecode算法学习笔记（一）</title>
    <url>/blogs/treeNote/</url>
    <content><![CDATA[<h2 id="关于树的算法"><a href="#关于树的算法" class="headerlink" title="关于树的算法"></a>关于树的算法</h2><p>除了基本的遍历，其余关于树的处理基本都是依赖递归算法，总体思路，是对当前节点进行处理，再将剩余的交给左子树和右子树分别递归处理。</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>队列：每次把同一层的节点入队，根据先进先出的特点，依次读取队首节点，再把当前节点的左右子树入队，作为下一层需要遍历的节点</p><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列存储根节点</span></span><br><span class="line">p.push(root)</span><br><span class="line"><span class="keyword">while</span>(队列不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取该层节点个数</span></span><br><span class="line">  <span class="built_in">width</span>=p.<span class="built_in">size</span>()</span><br><span class="line">  <span class="comment">//读取该层所有节点，并存储下一层节 点</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;<span class="built_in">width</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//读取队首节点</span></span><br><span class="line">    r=p.front()</span><br><span class="line">    出队</span><br><span class="line">    <span class="keyword">if</span>(r的左子树存在) 左子树入队</span><br><span class="line">    <span class="keyword">if</span>(r的右子树存在) 右子树入队</span><br><span class="line">  &#125;</span><br><span class="line">  存储每层的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>应用场景：</p>
<p>锯齿形层次遍历：需要把偶数行反序排列</p>
<p>求最大深度：每层入队时，增加一个层数</p>
<p>求最小深度（从根节点到最近叶子节点的最短路径上的节点数量）：每层遇到左右节点均为空的节点时，输出此时的层数</p>
<h3 id="前、中、后序遍历"><a href="#前、中、后序遍历" class="headerlink" title="前、中、后序遍历"></a>前、中、后序遍历</h3><p>a.前序 遍历特点：根-左-右</p>
<p>栈：每次先访问当前节点，并依次将右子树压入栈，再循环遍历左子树，根据先进后出的特点，循环结束后，下次将从最左边子树的右子树开始循环</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line"></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//右子树入栈</span></span><br><span class="line">    s.push(p-&gt;right)</span><br><span class="line">    <span class="comment">//不断遍历左子树</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top();</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.后序 遍历特点：左-右-根</p>
<p>栈：因为先对根节点访问较为简单，原理类似前序遍历，因此，可以先访问当前根节点，将左子树压入栈，再循环遍历右子树。循环结束，下一次是对最右边的左子树开始循环。形成结果是根-右-左，最后将结果逆序即可</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//访问当前根节点</span></span><br><span class="line">    res.push(p-&gt;val)</span><br><span class="line">    <span class="comment">//左子树入栈</span></span><br><span class="line">    s.push(p-&gt;left)</span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    p=p-&gt;right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理下一个节点</span></span><br><span class="line">  p=s.top;</span><br><span class="line">  出栈</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将最终结果逆序</span></span><br><span class="line">reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure>

<p>c.中序 遍历特点：左-根-右</p>
<p>栈：中序处理方法和上两种有所不同，需要不断循环先找到最左边叶子节点，在此过程中需要不断把当前遍历到的根节点入栈，栈中存储根节点和左子树节点，当循环结束时，从栈尾中取出节点，再不断对该节点的右子树循环，</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个树节点</span></span><br><span class="line">p=root</span><br><span class="line"><span class="comment">//p不为空说明还有未遍历到的节点，s不为空说明栈里还有存储的子树</span></span><br><span class="line"><span class="keyword">while</span>(p不为空||s不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//循环过程中不断将根节点和左子树节点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(p不为空)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//根节点入栈</span></span><br><span class="line">    s.push(p)</span><br><span class="line">    <span class="comment">//找到最左边的子树节点</span></span><br><span class="line">    p=p-&gt;left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//访问当前栈尾节点，</span></span><br><span class="line">  p=s,top();</span><br><span class="line">  res.push(p-&gt;val)</span><br><span class="line">  <span class="comment">//从栈中取出根节点</span></span><br><span class="line">  出栈</span><br><span class="line">  <span class="comment">//循环右子树</span></span><br><span class="line">  p=p-&gt;right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>验证一棵树是否是二叉搜索树（二叉搜索树的特点是左子树小于根节点，根节点小于右子树）：可以通过中序遍历比较节点值来判断</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>总体框架：明确一个节点需要做的事，剩余的分别扔给左子树和右子树处理</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//递归结束的条件：一个节点需要做的事（可能有多个结束条件）</span></span><br><span class="line">  <span class="keyword">if</span>(到达树的末尾)</span><br><span class="line">  	<span class="keyword">do</span>….</span><br><span class="line">  <span class="comment">//递归循环的条件剩余的交给左右子树处理</span></span><br><span class="line">  doTree(root-&gt;left,其他参数)</span><br><span class="line">  doTree(root-&gt;right,其他参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>具体而言，可以分为以下几类：</p>
<p>根据前序、中序遍历或者中序、后序遍历构造二叉树：根据前序根节点在首位，可以在中序遍历确定左右子树；根据后序根节点在尾部，可以在中序遍历确定左右子树</p>
<p> 伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">getTree</span><span class="params">(<span class="built_in">vector</span> p, <span class="keyword">int</span> pl,<span class="keyword">int</span> pr, <span class="built_in">vector</span> i, <span class="keyword">int</span> il,<span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(左位置大于右位置)</span><br><span class="line">  	<span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//循环的条件</span></span><br><span class="line">  <span class="comment">//根据前序或者后序遍历的特点找到根节点</span></span><br><span class="line">  pivot=p[pl]</span><br><span class="line">  <span class="comment">//根据根节点生成树节点</span></span><br><span class="line">  TreeNode root=<span class="keyword">new</span> TreeNode(pivot)</span><br><span class="line">  <span class="comment">//在中序遍历中找到根节点的位置</span></span><br><span class="line">  pivotindex=il</span><br><span class="line">  <span class="keyword">while</span>(i[pivotindex]!=pivot)</span><br><span class="line">  &#123;</span><br><span class="line">  	pivotindex++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确定左子树</span></span><br><span class="line">  root-&gt;left= getTree(p,I,左子树的位置)</span><br><span class="line">  <span class="comment">//确定右子树</span></span><br><span class="line">  root-&gt;right= getTree(p,I,右子树的位置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">doTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(递归到树的最后，即某一结束的条件)</span><br><span class="line">  ….</span><br><span class="line">  <span class="keyword">if</span>(满足题目要求（达到某一个值）&amp;&amp; doTree（root-&gt;left）&amp;&amp; doTree（root-&gt;right）(左右子树分别满足条件，此时递归，位置也可放到<span class="keyword">return</span>后面))</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<p>判断树的结构和值是否相同，即是否是相同的树：一个节点判断值是否相同，且左右子树的值和结构是否一致（调用函数，即递归）</p>
<p>对称二叉树：克隆一个数，和原来的树比较结构是否一致，思路同上</p>
<p>平衡二叉树（每个节点的左右子树的高度差绝对值小于1）：判断当前节点的高度，且左右子树的高度是否满足高度差小于1（调用函数，即递归）  注：里面包含求树的高度，可以找出左右子树高的那边再加1（也是使用递归）</p>
<p>判断一个树的路径和是否和目标值相同：每次判断当前叶子节点值（左右子树为空）与目标值是否相等，否则，将目标值减去当前节点值继续对左右子树递归</p>
<p>转换为二叉搜索树：需要利用中点，将原有数据进行排序,每次需要确定构造的数据的左右位置</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transBTS</span><span class="params">(<span class="built_in">vector</span> num，<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束的条件</span></span><br><span class="line">  <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">  	<span class="keyword">return</span> null</span><br><span class="line">  <span class="comment">//找到中点,构造根节点</span></span><br><span class="line">  <span class="comment">//(1)数组可以直接利用索引的1/2</span></span><br><span class="line">  <span class="comment">//(2)链表需要利用快慢指针，快指针走两步，慢指针走一步，快指针到末尾的时候，慢指针正好到中点</span></span><br><span class="line">  mid=…</span><br><span class="line">  TreeNode* root=<span class="keyword">new</span> TreeNode(num(mid))</span><br><span class="line">  <span class="comment">//递归构造左子树</span></span><br><span class="line">  root-&gt;left= transBTS(root-&gt;left,left,mid<span class="number">-1</span>)</span><br><span class="line">  <span class="comment">//递归构造右子树</span></span><br><span class="line">  root-&gt;right= transBTS(root-&gt;right, mid<span class="number">-1</span>,right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关于二叉搜索树的框架：利用左小右大的特点（类似二分查找）</p>
<p>​    伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BTS</span><span class="params">(TreeNode* root,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//结束条件</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val==num)</span><br><span class="line">  	<span class="keyword">do</span>..(可以做增删改之类的操作)</span><br><span class="line">  <span class="comment">//循环条件</span></span><br><span class="line">  <span class="comment">//大于：对左子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&gt;num)</span><br><span class="line">  	<span class="keyword">return</span> BTS(root-&gt;left,num)</span><br><span class="line">  <span class="comment">//小于：对右子树</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;val&lt;num)</span><br><span class="line">  	<span class="keyword">return</span> BTS(root-&gt;right,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求“树的高度”类型题"><a href="#求“树的高度”类型题" class="headerlink" title="求“树的高度”类型题"></a>求“树的高度”类型题</h3><p>1.求树的高度</p>
<p>采用递归，自底向上</p>
<p>找到最底层节点，每次返回当前节点的左子树高度和右子树高度的较大值，则当前节点的高度为max(left,right)+1，一直向上递归。如图所示的二叉树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p>
<p>从根节点递归，一直找到最左边的节点1，此时它的左右子树均为空，left=0,right=0,所以它的高度为1，接着返回上一层节点7的右子树4的高度，同理，节点4的高度为1，因此7的高度为max(depth(1),depth(4))+1，以此类推，一直向上找到根节点的高度即为树的高度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//当前节点的左子树高度</span></span><br><span class="line">  <span class="keyword">int</span> l=depth(root-&gt;left);</span><br><span class="line">  <span class="comment">//当前节点的右子树高度</span></span><br><span class="line">  <span class="keyword">int</span> r=depth(root-&gt;left);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回当前节点的高度为两者中大的那个再加一</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.求二叉树直径，即任意两个结点路径长度中的最大值</p>
<p>思路同求树的高度：任意两个节点之间的距离是当前节点左子树加上右子树的高度，因为是求最大路径和，则最大不可能出现在中间节点，只可能是任意两个叶子节点之间的距离，该距离可以通过两个叶子节点之间连线经过的根节点的左右子树的高度相加来求解，如图二叉树</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20200310165729.jpg" alt="二叉树"></p>
<p>节点1和节点2之间的路径为3，即为经过的根节点3的左右子树的高度和，同理，姐弟啊1和节点9之间的距离为5，即为即为经过的根节点6的左右子树的高度和.</p>
<p>所以问题转换为：求二叉树上所有节点的左右子树高度和的最大值，因此，可以将“求二叉树高度”的代码稍微进行改动即可。</p>
<p>注：因为每次要比较各个节点的高度和，所以需要传入一个maxvalue的值(传入的时候要加上取地址符号)，每次进行比较，一直更新，最终得出最大路径和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxTrack</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//求左右子树的高度</span></span><br><span class="line">  <span class="keyword">int</span> l=maxTrack(root-&gt;left,maxValue);</span><br><span class="line">  <span class="keyword">int</span> r=maxTrack(root-&gt;right,maxValue);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对当前的高度和即路径和进行比较</span></span><br><span class="line">  maxValue=<span class="built_in">max</span>(maxValue,l+r);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回左右子树高度较大的那个</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得出maxValue为最大路径和，maxTrack函数的最终返回值是根节点左右子树的高度和。</p>
<p>3.求二叉树的最大路径和，即从任意一个节点出发，到另一个节点之间的路径和的最大值。</p>
<p>思路同求二叉树的高度：从根节点开始递归，一直找到最左边的节点，计算此时的节点的左右子树较大的路径和，将值传递给当前父节点，父节点将自身值加上该值，继续传值给上一层节点，上一层的父节点也是在左右子树的较大值之间进行选择。保证每次都是在当前节点的左右子树中选择大的值进行回传，这样的保证路径和往大的方向走。</p>
<p>如图二叉树</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p>
<p>节点1的路径和是1,此时maxPath=0,更新为1，节点4的路径和是4，此时maxPath=1,更新为4，当求到节点7的路径和时，在它的左子树（节点1）和右子树（节点4）的路径和之间选择大的，即选择节点4，此时路径为7+4=11，此时maxPath=4,更新为11。再对节点3处理，左子树（11），右子树（2），选择左子树，此时路径和是11+3,此时maxPath=11,更新为14，以此类推，最终得到maxPath。</p>
<p>注：当当前左右子树加上当前节点值是负数，说明该条路径出现了“负贡献”，此时路径归0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; maxValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==null)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//求左右子树的路径和</span></span><br><span class="line">  <span class="keyword">int</span> l=maxPath(root-&gt;left,maxValue);</span><br><span class="line">  <span class="keyword">int</span> r=maxPath(root-&gt;right,maxValue);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//更新当前最大路径</span></span><br><span class="line">  maxValue=<span class="built_in">max</span>(maxValue,l+r+root-&gt;value);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断路径有无出现负贡献</span></span><br><span class="line">  <span class="keyword">int</span> temp=<span class="built_in">max</span>(l,r)+root-&gt;val;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//每次选择左右子树中大的和自身相加！！！！</span></span><br><span class="line">  <span class="comment">//返回当前节点的路径和，作为上一次的子树值</span></span><br><span class="line">  <span class="keyword">return</span> temp&lt;<span class="number">0</span>?<span class="number">0</span>:temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到maxValue是最大路径和，maxPath返回值是根节点的左右子树加上自身的路径和。</p>
<h3 id="常规思路——bfs和dfs"><a href="#常规思路——bfs和dfs" class="headerlink" title="常规思路——bfs和dfs"></a>常规思路——bfs和dfs</h3><p>二叉树的题目大多数是遍历的变形题，往两个方向考虑：使用bfs——层次遍历还是dfs——深度遍历/回溯、递归，当使用非递归，即层次遍历的时候注意叶子节点的判断。</p>
<p>例如求二叉树从根节点出发的路径和，可以使用层次遍历，使用两个栈，一个用来存储每层的节点，另一个用来存储每层相加的和，当出现叶子节点的时候就把相加的和累加上去。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(栈不为空)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>=p.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//存储每层累加的和</span></span><br><span class="line">  <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">width</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    r=p.front();</span><br><span class="line">    <span class="comment">//把当前节点的值加上上一次的和的10倍</span></span><br><span class="line">    val=numQue.front()*<span class="number">10</span>+r-&gt;val;<span class="comment">//numQue中存储每层节点累加的和</span></span><br><span class="line">    p.pop();</span><br><span class="line">    numQue.pop();</span><br><span class="line">    <span class="keyword">if</span>(叶子节点)</span><br><span class="line">      res+=val;</span><br><span class="line">    <span class="keyword">if</span>(左子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(左子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(右子树存在)</span><br><span class="line">    &#123;</span><br><span class="line">      p.push(右<span class="number">2</span>子树)</span><br><span class="line">      <span class="comment">//之前累加的和入栈</span></span><br><span class="line">      numQue.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/blogs/sort/</url>
    <content><![CDATA[<p>几种排序算法的比较，对原始序列：6，3，5，7，2，9，8，1，4  进行排序</p><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>第一次：从第一个数字开始，依次相邻比较，前面大于后面则调换位置，比到最后一位，则选出了最大值放在最后</p><p>​        第一次排序后：3，5，6，2，7，8，1，4，9</p><p>​        第二次排序后：3，5，2，6，7，1，4，8，9</p><a id="more"></a>



<p>​        。。。。。。。</p>
<p>时间复杂度：O(n^2)</p>
<h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p>第一次：首先排第一个位置，先设min=0记录最小值位置，默认第一个位置，将6与3比较，3比6小，则min=1(代表3的位置)；再将3与5比较，3比5小，不改变min值；依次将min位置的数值依次与后续数字比较，比min小则更改min为更小值的位置，直到最后一个数字比完。此时min=7(1的位置)，将6与7对换，则第一次排序完成。</p>
<p>​        第一次排序后顺序是：1，3，5，7，2，9，8，6，4</p>
<p>第二次：排第二个位置，方法同上，设min=1代表默认第二个位置，即数值3默认最小值，将3依次与后续比较，找出最小值，min=最小值的位置，交换第二个位置的值3与min位置的值2，完成第二次排序。</p>
<p>​        第二次排序后：1，2，5，7，3，9，8，6，4</p>
<p>​        第三次排序后：1，2，3，7，5，9，8，6，4</p>
<p>​        。。。。。。。</p>
<p>时间复杂度：O(n^2)</p>
<p>​        第五次排序后顺序为：1，2，3，4，5，9，8，6，7</p>
<p>​        第六次排序后顺序为：1，2，3，4，5，6，8，9，7</p>
<p>​        第七次排序后顺序为：1，2，3，4，5，6，7，9，8</p>
<p>​        第八次排序后顺序为：1，2，3，4，5，6，7，8，9</p>
<h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p>​        第一次排序后：6</p>
<p>​        第二次排序后：3，6</p>
<p>​        第三次排序后：3，5，6</p>
<p>​        。。。。。。。</p>
<p>时间复杂度：O(n^2)</p>
<h6 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h6><p>同直接插入排序，但是在比较的时候，是折半比较，思想同折半查找</p>
<p>时间复杂度：O(n^2)</p>
<h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p>第一次：设步长d=5，则6和9；3和8；5和1；7和4；直接插入排序</p>
<p>​        第一次排序后：6，3，1，4，2，9，8，5，7</p>
<p>第二次：d = d/2 = 2，则6，1，2，8，7；3，4，9，5；直接插入排序</p>
<p>​        第二次排序后：1，3，2，4，6，5，7，9，8</p>
<p>第三次：d = d/2 = 1，则所有数据直接插入排序</p>
<p>​        第三次排序后：1，2，3，4，5，6，7，8，9</p>
<p>时间复杂度：O(nlog2^n)</p>
<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>第一次：选取第一个数6为轴，将第一个6与最后一个数字4比较（从后往前比），如果大于比较的数字，则调换，然后与原位置后面开始比（从前往后比），以此类推，第一次排完后，轴6的左边都小于6，右边都大于6。</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226160921.png" alt="快速排序i,j变化"></p>
<p>​        第一次排序后：4，3，5，1，2，6，8，9，7</p>
<p>第二次：则将上个比较后的轴的左右依次做快速排序，直到所有子表的表长不超过1</p>
<p>时间复杂度：O(nlog2^n)</p>
<h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>首先建立初始堆，按照顺序方式建立完全二叉树</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226110659.png" alt="二叉树"></p>
<p>然后建立大顶堆，分别将有子节点的7，3，5，6从底层开始，分别与子节点比较，选大的作为父节点，即可得到最大的根节点的二叉树，即大顶堆</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226140326.png" alt="大顶堆"></p>
<p>然后，将堆顶拿下来，将叶子节点放上去，再次按照大顶堆方法，得到根节点，以此类推，最终得到有序数列</p>
<p>时间复杂度：O(nlog2^n)</p>
<h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><p>对数组递归折半分割，直到分割成单个，然后递归合并比较，直到合并为整个数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191226142419.png" alt="归并排序"></p>
<p>时间复杂度：O(nlog2^n)</p>
<p>总结：时间复杂度是nlog2^n的是：快些(希)归队(堆)，不稳定的是：快些(希)选队(堆)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blogs/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external nofollow noopener noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external nofollow noopener noreferrer">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external nofollow noopener noreferrer">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external nofollow noopener noreferrer">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external nofollow noopener noreferrer">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="external nofollow noopener noreferrer">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo部署时用户名密码设置</title>
    <url>/blogs/hexo-deploy/</url>
    <content><![CDATA[<p>hexo部署时用户名密码问题：</p><p>记住用户名密码，不用每次都输入用户名密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>清除用户名密码，防止用户名密码输入错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>docker简易教程</title>
    <url>/blogs/docker/</url>
    <content><![CDATA[<h2 id="Docker：虚拟化容器技术"><a href="#Docker：虚拟化容器技术" class="headerlink" title="Docker：虚拟化容器技术"></a>Docker：虚拟化容器技术</h2><p>三大组件：镜像，容器，仓库</p><pre><code>镜像：想象成系统iso或者ghost镜像

容器：想象成一个系统环境

仓库：想象成GitHub</code></pre><p>优点：隔离性   便捷性–移植和集群     轻量级   云支持</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Cenos7下安装docker</p><p>1.把yum包更新到最新</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><a id="more"></a>





<p>2.安装需要的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>3.设置yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>4.可以查看所有仓库中所有docker版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure>

<p>5.安装Docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-17.12.1.ce</span><br></pre></td></tr></table></figure>

<p>6.启动Docker，加入开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<p>7.验证安装是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>



<h2 id="编辑容器"><a href="#编辑容器" class="headerlink" title="编辑容器"></a>编辑容器</h2><p>从仓库中拉去一个centos7的镜像 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">doucker pull centos:7</span><br></pre></td></tr></table></figure>

<p>启动镜像生成容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -i -t &lt;IMAGE ID&gt; bash</span><br></pre></td></tr></table></figure>

<p>进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER ID&gt; bash</span><br></pre></td></tr></table></figure>

<p>此时就是进入了centos7的linux系统，可以在里安装jdk,tomcat等，然后部署war后，执行</p>
<p><code>curl localhost:端口号</code>    看看是否可以访问。</p>
<p>为了可以启动容器的时候，自动启动tomcat，可以写一个脚本，启动容器的时候，启动此脚本。<br>例如我在最根目录创建了runtomcat.sh的脚本<br>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/soft/jdk1.5.0_22</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">sh /soft/apache-tomcat-5.5.25/bin/catalina.sh run</span><br></pre></td></tr></table></figure>



<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>将原来的容器制成镜像–docker commit containerid new_image:tag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit centos7_base centos:7.1</span><br></pre></td></tr></table></figure>

<p>使用新的镜像制成容器–docker run -d -p 主机端口:容器端口/tcp –name 容器名 镜像名:tag  </p>
<p>并执行docker内脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 18080:8080 --name centos7_1 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure>

<p>宿主机端口是18080映射了容器内的8080tomcat端口，现在直接访问宿主机的ip:18080/cvbs就可以访问容器的web服务了。<br>查看docker运行情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144010.png" alt="查看docker运行情况"></p>
<p>可以看到此时新的容器已经启动了</p>
<p>再次制成一个容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 28080:8080 --name centos7_2 centos:7.1 /runtomcat.sh</span><br></pre></td></tr></table></figure>

<p>查看docker运行情况–<code>docker ps –a</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144100.png" alt="查看docker运行情况"></p>
<p>此时可以看到已经部署了两个服务了，分别映射在宿主机的18080和28080端口</p>
<p>外部浏览器访问：</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144117.png" alt="浏览器双端口访问"></p>
<p>可以看到两个端口都可以访问了</p>
<p>因为我是在虚拟机里安装，所以局域网中其他机器无法访问到此ip，</p>
<p>所以为了省略配置虚拟机对外暴露的ip等步骤，直接在主机中通过配置nginx做代理，配置如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144141.png" alt="nginx配置"></p>
<p>此时外部访问即可<code>http://10.45.12.120/cvbs</code>（我的局域网内ip）即可访问到docker中部署两个的应用。</p>
<p>注意：因为有些项目没有做分布式session处理，所以简单使用ip_hash策略解决session问题</p>
<h2 id="IDEA中配置docker"><a href="#IDEA中配置docker" class="headerlink" title="IDEA中配置docker"></a>IDEA中配置docker</h2><p>1.在根目录写Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定基础镜像，在其上进行定制FROM java:8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制上下文目录下的target/demo-1.0.0.jar 到容器里</span></span><br><span class="line">ADD target/spring-boot-0.0.1-SNAPSHOT.jar test.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#bash方式执行，使test.jar可访问</span></span><br><span class="line"><span class="comment">#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。</span></span><br><span class="line">RUN bash -c <span class="string">"touch /test.jar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</span></span><br><span class="line">EXPOSE 8088</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器启动程序及参数   &lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"test.jar"</span>]</span><br></pre></td></tr></table></figure>

<p>2.在启动配置中配置dockerfile,image,container,port(宿主机和docker的端口映射)</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144221.png" alt="配置dockerfile"></p>
<p>3.Maven打包</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144237.png" alt="maven打包"></p>
<p>4.Docker部署</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144250.png" alt="docker部署"></p>
<p>5.启动Docker</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144304.png" alt="启动docker"></p>
<p>6.查看docker运行情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144319.png" alt="查看docker运行情况3"></p>
<p>7.浏览器访问成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/20191212144335.png" alt="浏览器访问"></p>
<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</p>
<p>可以对各种虚拟化容器技术做统一的管理</p>
<p>实际项目中大量用到docker时，可以在研究k8s的实际使用。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>future与futuretask用法区别</title>
    <url>/blogs/future-futuretask/</url>
    <content><![CDATA[<h6 id="Future和FutureTask方法区别，主要在于获取返回结果上。"><a href="#Future和FutureTask方法区别，主要在于获取返回结果上。" class="headerlink" title="Future和FutureTask方法区别，主要在于获取返回结果上。"></a>Future和FutureTask方法区别，主要在于获取返回结果上。</h6><p>Future方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(<span class="keyword">new</span> Test7());</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>submit里放的是实现callable接口的类，通过返回值submit.get()，获取返回结果6，如果test抛出异常，此时，主线程会捕获，打印3，不调用submit.get()，将不会捕获异常。</p>
<p>FutureTask方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        FutureTask ft = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Test8());</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;?&gt; submit = executor.submit(ft);</span><br><span class="line">            Object o = submit.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            Object o1 = ft.get();</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executor里放的是futuretask，futuretask包装了一层callable对象，此时要获取返回结果需要使用futuretask的get()方法，不能使用submit.get(),submit.get()会返回null;只用ft.get()会捕获异常。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>future</tag>
      </tags>
  </entry>
  <entry>
    <title>用bp网络预测绿萝叶片面积</title>
    <url>/blogs/bp-net/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote>
<p>测量绿萝叶片使用kinect相机对图像做标定，将图像映射到坐标系中，使用matlab程序计算叶片整体占图像的像素从而计算面积，对绿萝每层的叶片都需要分次进行标定求解过程较为复杂，因此针对这种情况，采用bp网络来预测绿萝叶片面积。</p>
</blockquote><hr><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p><em>测量9盆绿萝叶片，实测数据共557片。训练集1-7盆，共449片，测试集8-9盆，共108片。<br>数据集中共四个属性，分别是宽度为w，长边为L1,短边为L2，面积area。</em><br><strong>其中宽度，长边，短边为手动实测，面积根据叶片像素点占图片整体像素点计算得出。</strong></p><a id="more"></a>


<ul>
<li>计算面积的MATLAB程序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% 分割</span><br><span class="line">k=graythresh(I);              %得到最优阈值</span><br><span class="line">j=im2bw(I,k);                  %转换成二值图，k为分割阈值</span><br><span class="line">%imshow(j); </span><br><span class="line">f = bwmorph(j,&apos;open&apos;);  %开运算</span><br><span class="line">figure, imshow(f)</span><br><span class="line">%% 像素点统计</span><br><span class="line">[m,n]=size(f);</span><br><span class="line">k=0;</span><br><span class="line">for i=1:1:m</span><br><span class="line">    for j=1:1:n</span><br><span class="line">        if f(i,j)==0</span><br><span class="line">            k=k+1;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">p=k/(m*n);</span><br><span class="line">s=21*29.7*p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="bp网络设计"><a href="#bp网络设计" class="headerlink" title="bp网络设计"></a>bp网络设计</h1><p>bp网络示意图及各变量含义<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%8F%8A%E5%90%84%E5%8F%98%E9%87%8F%E5%90%AB%E4%B9%89.png" alt="bp结构图片"></p>
<ol>
<li><p>结构选取<br>a.隐含层数量选取：单隐层结构选择，当仅有一层隐含层时，测试数据正确率已达100%，为降低网络复杂度，所以选择单隐层结构。<br>b.隐含层神经元个数选取</p>
<table>
<thead>
<tr>
<th align="left">隐含层神经元个数</th>
<th align="left">达到最小误差时需要迭代的次数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5</td>
<td align="left">1873</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">2009</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">2259</td>
</tr>
</tbody></table>
<p>根据程序运行来看，当隐藏层神经元个数选择过小（小于5）收敛速度很慢，当到达最大迭代次数时，误差仍很大，当个数选择过大（大于15），网络出现振荡，因此，考虑隐藏层神经元个数在5-15之间，因为本实验数据集属性少，因此选择隐藏层神经元个数为5个，减少复杂度。<br> c.误差函数选择均方差公式：$[    {E_{k} } =1/2*( \hat{y}-y) ]$<br> d.结束条件：<br> 训练结束条件：当误差函数值小于1e-3或者迭代次数大于50000次时结束训练<br> 测试误差判断：当测试集输出面积和实际面积误差函数值大于1e-5时，预测错误，反之预测正确。</p>
</li>
<li><p>初始值设置<br>a.权值矩阵的初始值<br>产生0-1之间的随机数作为权值的初始值<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srand(time(NULL));//设置随机数种子，使每次产生的随机序列不同</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">    w[i] = rand() % (N + 1) / (float)(N + 1);//N为设置的精度</span><br></pre></td></tr></table></figure>
<p>b.学习率的初始值<br>学习率控制着算法每一轮的迭代的更新步长，若太大则容易振荡，太小则收敛速度又过慢因此需要选择适合的初始值。<br><img src="https://cdn.jsdelivr.net/gh/iamxpf/pageImage/images/bp%E5%AD%A6%E4%B9%A0%E7%8E%87%E5%8F%98%E5%8C%96.png" alt="学习率变化图片"><br>由图可以看出，当学习率小于1时，网络训练次数多集中在1000以上，但当学习率大于5时，测试集数据会出现错误，因此选择训练次数少并且误差低的学习率=5.</p>
</li>
<li><p>数据归一化<br>前三列属性取值∈[2,9]，因此采用对数函数y=log10(x) 以10为底的对数函数转换。<br>最后一列属性取值∈[10,100]，因此采用反余弦函数y=atan(x)*2/PI，保证输入的数据在0-1之间，让网络更快的收敛。</p>
</li>
<li><p>前向传播和反向传播<br>a.前向传播<br>激活函数选择sigmod函数，第i个输入层神经元到第h个隐藏层神经元的权值为Vih,第h个隐藏层神经元输入为α=∑Vih<em>Xi，输出为bh;第h个输入层神经元到第j个隐藏层神经元的权值为Whj,第j个输出层神经元的输入β=∑Whj</em>bh,输出为<br>求出激活值，代入sigmod函数中，求得输出值<br>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">   o1[j]=0.0;</span><br><span class="line">   for(int i=0;i&lt;inSum;i++)</span><br><span class="line">   //激活值</span><br><span class="line">   o1[j]=o1[j]+w[i][j]*x[i];</span><br><span class="line">   //实际输出</span><br><span class="line">   x1[j]=1.0/(1+exp(-o1[j]-b1[j])); //b1为偏置量</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>b.反向传播<br>网络在（Xk,Yk)上的均方差为，BP算法基于梯度下降的策略，以目标的负梯度方向进行调整在学习率下，采用链式法则对权值进行更新：<br>从输出层到隐藏层，有:<br>从隐藏层到输入层，有:</p>
</li>
</ol>
<ul>
<li>算法描述:<blockquote>
<p>在（0，1）范围内初始化权值和学习率<br>REPEAT<br>FOR all（Xk,Yk)：<br>输入正向传播公式计算输出<br>计算输出层需修改的梯度项gj<br>计算隐藏层层需修改的梯度项eh<br>根据公式更新权值wjh,vij<br>END FOR<br>UNTIL 达到停止条件</p>
</blockquote>
</li>
</ul>
<p>标准BP算法：上述算法是对每个样本更新权值，属于标准BP算法，参数更新的频繁<br>累积BP算法：当读取完所有样本之后才更新参数，参数更新的频率低<br>区别：累积BP算法在误差下降到一定阶段，下降回非常缓慢，所以往往标准BP算法能更快得到较好解。<br><em>使用标准BP算法：对每个样本更新权值</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        w1[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        w[i][j]+=rate_w*pp[j]*x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>使用累积BP算法：遍历完所有样本再更新权值<br>增加权值修改矩阵，将误差进行累加</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出层</span><br><span class="line">for(int k=0;k&lt;outSum;k++)</span><br><span class="line">&#123;</span><br><span class="line">    //与实际输出的偏差</span><br><span class="line">    qq[k]=(yd[k]-x2[k])*x2[k]*(1-x2[k]);</span><br><span class="line">    for (int j = 0; j&lt; hideSum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整隐藏层到输出层之间的连接权</span><br><span class="line">        chg_w2[j][k]+=rate_w1*qq[k]*x1[j];</span><br><span class="line">        chg_b2[k]+=rate_b2*qq[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//隐藏层</span><br><span class="line">for(int j=0;j&lt;hideSum;j++)</span><br><span class="line">&#123;</span><br><span class="line">    pp[j]=0;</span><br><span class="line">    //隐藏层的偏差</span><br><span class="line">    for (int k = 0; k&lt; outSum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        pp[j]=pp[j]+qq[k]*w1[j][k];  //隐藏层的偏差和后面所有连接的对应输出层都有关系</span><br><span class="line">    &#125;</span><br><span class="line">    pp[j]=pp[j]*x1[j]*(1-x1[j]);</span><br><span class="line">   for (int i = 0; i &lt; inSum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //调整输入层到隐藏层之间的连接权</span><br><span class="line">        chg_w1[i][j]=chg_w1[i][j]+rate_w1*pp[j]*x[i];</span><br><span class="line">        chg_b1[j]+=rate_b1*pp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><table>
<thead>
<tr>
<th align="left">对比</th>
<th align="left">标准BP算法</th>
<th align="left">累积BP算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">迭代次数</td>
<td align="left">548</td>
<td align="left">348</td>
</tr>
<tr>
<td align="left">训练平均误差</td>
<td align="left">小于1e-5</td>
<td align="left">小于1e-5</td>
</tr>
<tr>
<td align="left">识别结果</td>
<td align="left">100%</td>
<td align="left">100%</td>
</tr>
</tbody></table>
<p>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p>
<hr>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li>如果将长边短边合成一条边，效果还是一样吗？<br>将数据集中长边L1和短边L2相加得到叶子的长为L，输入的属性列变为长L,宽W,面积area<br>网络结构采取上述结构，训练效果如下图：<table>
<thead>
<tr>
<th align="left">对比</th>
<th align="left">标准BP算法</th>
<th align="left">累积BP算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">迭代次数</td>
<td align="left">566</td>
<td align="left">717</td>
</tr>
<tr>
<td align="left">训练平均误差</td>
<td align="left">小于1e-5</td>
<td align="left">小于1e-5</td>
</tr>
<tr>
<td align="left">识别结果</td>
<td align="left">94.5%</td>
<td align="left">97.3%</td>
</tr>
</tbody></table>
</li>
</ul>
<p>因实验所用的叶片有破损存在，直接用长边加上短边得到的叶片长度存在一定误差，因此使用BP算法时，识别结果略有下降.<br>使用标准BP算法和累积BP算法识别率都能达到100%，但是因数据量小，使用累积BP 算法训练时间更短。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
</search>
